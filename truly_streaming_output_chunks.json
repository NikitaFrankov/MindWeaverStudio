{"metadata":{"generatedAt":"2025-10-22T15:16:44.35285","isStreaming":true},"chunks":[{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/app/App.kt","className":null,"methodName":"App","startLine":24,"endLine":31,"content":"package com.example.mindweaverstudio.ui.app\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\n\nfun App(component: RootComponent) {\n    MindWeaverTheme {\n        RootContent(\n            component = component,\n            modifier = Modifier.background(MindWeaverTheme.colors.rootBackground)\n        )\n    }\n}","chunkType":"FUNCTION","tokens":87,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.app","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.*","androidx.compose.material3.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/app/App.kt","className":null,"methodName":"RootContent","startLine":35,"endLine":53,"content":"package com.example.mindweaverstudio.ui.app\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\n\nfun RootContent(component: RootComponent, modifier: Modifier = Modifier) {\n    Scaffold(\n        modifier = modifier,\n    ) { innerPadding ->\n        Children(\n            stack = component.stack,\n            modifier = modifier.padding(innerPadding),\n            animation = stackAnimation(animator = fade() + scale()),\n        ) {\n            when (val child = it.instance) {\n                is Child.Authentication -> AuthenticationScreen(child.component)\n                is Child.ProjectSelection -> ProjectSelectionScreen(child.component)\n                is Child.CodeEditor -> CodeEditorScreen(child.component)\n                is Child.UserConfiguration -> UserConfigurationScreen(child.component)\n                is Child.RepoInfoInput -> RepoInfoInputDialog(child.component)\n            }\n        }\n    }\n}","chunkType":"FUNCTION","tokens":237,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.app","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.*","androidx.compose.material3.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarScreen","startLine":27,"endLine":34,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nfun SidebarScreen(component: SidebarComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    SidebarScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":86,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarScreen","startLine":37,"endLine":37,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarScreen(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarHeader","startLine":90,"endLine":90,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarHeader(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarMenuItemRow","startLine":118,"endLine":118,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarMenuItemRow(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"UserConfigurationScreen","startLine":25,"endLine":33,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nfun UserConfigurationScreen(component: UserConfigurationComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    UserConfigurationScreen(\n        state = state,\n        intentHandler = component::onIntent,\n        onBackPressed = component::onBackPressed\n    )\n}","chunkType":"FUNCTION","tokens":111,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"UserConfigurationScreen","startLine":37,"endLine":37,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun UserConfigurationScreen(","chunkType":"FUNCTION","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":183,"endLine":183,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val role = WorkRole.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":214,"endLine":214,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val level = ExperienceLevel.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":67,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":228,"endLine":228,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val format = ResponseFormat.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":67,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"ConfigurationSection","startLine":282,"endLine":282,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun ConfigurationSection(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"DropdownField","startLine":311,"endLine":311,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun DropdownField(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":317,"endLine":317,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n    var expanded by remember { mutableStateOf(false) }","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":29,"endLine":29,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nenum class Language { KOTLIN, JAVA, JSON, PLAIN }","chunkType":"CLASS","tokens":49,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"CodeEditor","startLine":32,"endLine":32,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nfun CodeEditor(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":39,"endLine":39,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n    var selectedLanguage by remember { mutableStateOf(language) }","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":40,"endLine":40,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n    var searchQuery by remember { mutableStateOf(\"\") }","chunkType":"PROPERTY","tokens":50,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":41,"endLine":41,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n    var wrapLines by remember { mutableStateOf(false) }","chunkType":"PROPERTY","tokens":51,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":42,"endLine":42,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n    var fontSize by remember { mutableStateOf(14f) }","chunkType":"PROPERTY","tokens":50,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"LanguageDropdown","startLine":60,"endLine":72,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun LanguageDropdown(selected: Language, onSelect: (Language) -> Unit) {\n    var expanded by remember { mutableStateOf(false) }\n    Box {\n        TextButton(onClick = { expanded = true }) { Text(selected.name) }\n        DropdownMenu(expanded = expanded, onDismissRequest = { expanded = false }) {\n            Language.values().forEach { lang ->\n                DropdownMenuItem(onClick = { onSelect(lang); expanded = false }) {\n                    Text(lang.name)\n                }\n            }\n        }\n    }\n}","chunkType":"FUNCTION","tokens":167,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"CodeEditor","startLine":75,"endLine":75,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun CodeEditor(","chunkType":"FUNCTION","tokens":43,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":86,"endLine":86,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n    val focusRequester = remember { FocusRequester() }","chunkType":"PROPERTY","tokens":50,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":122,"endLine":124,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\n            val highlighted = remember(text, language, searchQuery) {\n                highlightSyntax(text, language, searchQuery)\n            }","chunkType":"PROPERTY","tokens":73,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"highlightSyntax","startLine":159,"endLine":166,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun highlightSyntax(text: String, language: Language, searchQuery: String): AnnotatedString {\n    return when (language) {\n        Language.KOTLIN -> highlightWithRules(text, kotlinRules(), searchQuery)\n        Language.JAVA -> highlightWithRules(text, javaRules(), searchQuery)\n        Language.JSON -> highlightWithRules(text, jsonRules(), searchQuery)\n        Language.PLAIN -> AnnotatedString(text)\n    }\n}","chunkType":"FUNCTION","tokens":141,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"highlightWithRules","startLine":168,"endLine":195,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun highlightWithRules(text: String, rules: List<SyntaxRule>, searchQuery: String): AnnotatedString {\n    val builder = androidx.compose.ui.text.AnnotatedString.Builder().apply {\n        append(text)\n    }\n\n    // apply rules\n    rules.forEach { rule ->\n        val regex = rule.regex.toRegex()\n        regex.findAll(text).forEach { match ->\n            // addStyle доступен на AnnotatedString.Builder\n            builder.addStyle(rule.style, match.range.first, match.range.last + 1)\n        }\n    }\n\n    // highlight search matches with underline style\n    if (searchQuery.isNotEmpty()) {\n        val q = Regex(Regex.escape(searchQuery), RegexOption.IGNORE_CASE)\n        q.findAll(text).forEach { m ->\n            builder.addStyle(\n                SpanStyle(textDecoration = androidx.compose.ui.text.style.TextDecoration.Underline),\n                m.range.first,\n                m.range.last + 1\n            )\n        }\n    }\n\n    return builder.toAnnotatedString()\n}","chunkType":"FUNCTION","tokens":281,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":null,"startLine":197,"endLine":219,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate data class SyntaxRule(val regex: String, val style: SpanStyle)\n\nprivate fun kotlinRules(): List<SyntaxRule> {\n    val keywordStyle = SpanStyle(color = Color(0xFF7C4DFF))\n    val typeStyle = SpanStyle(color = Color(0xFF1E88E5))\n    val stringStyle = SpanStyle(color = Color(0xFF43A047))\n    val commentStyle = SpanStyle(color = Color(0xFF9E9E9E))\n    val numberStyle = SpanStyle(color = Color(0xFFFB8C00))\n\n    val keywords = listOf(\n        \"fun\", \"val\", \"var\", \"if\", \"else\", \"for\", \"while\", \"return\", \"when\", \"is\", \"in\", \"object\", \"class\", \"interface\", \"sealed\", \"data\", \"package\", \"import\", \"override\"\n    ).joinToString(\"\\\\b|\") { it }\n\n    return listOf(\n        SyntaxRule(\"//.*\", commentStyle),\n        SyntaxRule(\"/\\\\*(.|\\\\R)*?\\\\*/\", commentStyle),\n        SyntaxRule(\"\\\"([^\\\\\\\"\\\\\\\\]|\\\\\\\\.)*\\\"\", stringStyle),\n        SyntaxRule(\"'([^'\\\\\\\\]|\\\\\\\\.)*'\", stringStyle),\n        SyntaxRule(\"\\\\b($keywords)\\\\b\", keywordStyle),\n        SyntaxRule(\"\\\\b[0-9]+(\\\\.[0-9]+)?\\\\b\", numberStyle),\n        SyntaxRule(\"\\\\b[A-Z][A-Za-z0-9_]*\\\\b\", typeStyle)\n    )\n}","chunkType":"CLASS","tokens":302,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"javaRules","startLine":221,"endLine":234,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun javaRules(): List<SyntaxRule> {\n    val keywordStyle = SpanStyle(color = Color(0xFF7C4DFF))\n    val stringStyle = SpanStyle(color = Color(0xFF43A047))\n    val commentStyle = SpanStyle(color = Color(0xFF9E9E9E))\n\n    val keywords = listOf(\"public\", \"private\", \"protected\", \"class\", \"static\", \"final\", \"void\", \"new\", \"if\", \"else\", \"for\", \"while\", \"return\").joinToString(\"\\\\b|\") { it }\n\n    return listOf(\n        SyntaxRule(\"//.*\", commentStyle),\n        SyntaxRule(\"/\\\\*(.|\\\\R)*?\\\\*/\", commentStyle),\n        SyntaxRule(\"\\\"([^\\\\\\\"\\\\\\\\]|\\\\\\\\.)*\\\"\", stringStyle),\n    SyntaxRule(\"\\\\b($keywords)\\\\b\", keywordStyle)\n    )\n}","chunkType":"FUNCTION","tokens":194,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditor.kt","className":null,"methodName":"jsonRules","startLine":236,"endLine":246,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.border\n\nprivate fun jsonRules(): List<SyntaxRule> {\n    val keyStyle = SpanStyle(color = Color(0xFF7C4DFF))\n    val stringStyle = SpanStyle(color = Color(0xFF43A047))\n    val numberStyle = SpanStyle(color = Color(0xFFFB8C00))\n\n    return listOf(\n        SyntaxRule(\"\\\"(.*?)\\\"(?=\\\\s*:)\", keyStyle),\n        SyntaxRule(\"\\\"([^\\\\\\\"\\\\\\\\]|\\\\\\\\.)*\\\"\", stringStyle),\n        SyntaxRule(\"\\\\b-?\\\\d+(\\\\.\\\\d+)?([eE][+-]?\\\\d+)?\\\\b\", numberStyle)\n    )\n}","chunkType":"FUNCTION","tokens":145,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.background","androidx.compose.foundation.border","androidx.compose.foundation.gestures.detectTapGestures"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":"SyntaxHighlightedEditor","startLine":21,"endLine":21,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\nfun SyntaxHighlightedEditor(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":null,"startLine":27,"endLine":27,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\n    var text by remember { mutableStateOf(initialContent) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":null,"startLine":29,"endLine":94,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\n    val textArea = remember {\n        RSyntaxTextArea().apply {\n            syntaxEditingStyle = if (isKotlin) SyntaxConstants.SYNTAX_STYLE_JAVA else SyntaxConstants.SYNTAX_STYLE_GROOVY\n            isCodeFoldingEnabled = true\n            antiAliasingEnabled = true\n            isBracketMatchingEnabled = true\n            font = java.awt.Font(\"JetBrains Mono\", java.awt.Font.PLAIN, 14)\n\n            // Тема Atom One Dark (адаптирована под доступные token types)\n            val theme = Theme(this).apply {\n                bgColor = java.awt.Color.decode(\"#282c34\") // Background\n                caretColor = java.awt.Color.decode(\"#528bff\") // Caret\n                currentLineHighlightColor = java.awt.Color.decode(\"#2c323c\")\n                fadeCurrentLineHighlight = true\n\n                // Цвета для токенов (расширенные для большего количества типов)\n                baseFont = font // Monospace\n//                baseStyle = Style().withForeground(java.awt.Color.decode(\"#abb2bf\")) // Default text\n//\n//                // Keywords (val, fun ~ reserved words in Java)\n//                keyword = Style().withForeground(java.awt.Color.decode(\"#c678dd\")).withBold(true)\n//\n//                // Identifiers (variables)\n//                identifier = Style().withForeground(java.awt.Color.decode(\"#abb2bf\"))\n//\n//                // Data types/classes\n//                dataType = Style().withForeground(java.awt.Color.decode(\"#e5c07b\"))\n//\n//                // Functions (обрабатываются как identifiers, но можно override в custom если нужно)\n//                function = Style().withForeground(java.awt.Color.decode(\"#61afef\"))\n//\n//                // Strings\n//                literalString = Style().withForeground(java.awt.Color.decode(\"#98c379\"))\n//\n//                // Numbers/literals\n//                literalNumber = Style().withForeground(java.awt.Color.decode(\"#d19a66\"))\n//\n//                // Operators\n//                operator = Style().withForeground(java.awt.Color.decode(\"#56b6c2\"))\n//\n//                // Comments\n//                comment = Style().withForeground(java.awt.Color.decode(\"#5c6370\")).withItalic(true)\n//                commentMultiline = Style().withForeground(java.awt.Color.decode(\"#5c6370\")).withItalic(true)\n//\n//                // Annotations (@)\n//                annotation = Style().withForeground(java.awt.Color.decode(\"#e5c07b\"))\n//\n//                // Errors\n//                errorIdentifier = Style().withForeground(java.awt.Color.decode(\"#e06c75\")).withUnderline(true)\n\n                // Brackets/marks\n                matchedBracketBorderColor = java.awt.Color.decode(\"#3a3f4b\")\n                matchedBracketFG = java.awt.Color.decode(\"#abb2bf\")\n                matchedBracketBG = java.awt.Color.decode(\"#3a3f4b\")\n            }\n            theme.apply(this)\n\n            this.text = initialContent\n\n            document.addDocumentListener(object : DocumentListener {\n                override fun insertUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n                override fun removeUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n                override fun changedUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n            })\n        }\n    }","chunkType":"PROPERTY","tokens":862,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"CodeEditorScreen","startLine":48,"endLine":56,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nfun CodeEditorScreen(component: CodeEditorComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    CodeEditorScreen(\n        state = state,\n        intentHandler = component::onIntent,\n        onNavigateToUserConfiguration = component::onNavigateToUserConfiguration\n    )\n}","chunkType":"FUNCTION","tokens":114,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"CodeEditorScreen","startLine":60,"endLine":60,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun CodeEditorScreen(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":68,"endLine":73,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    val menuActionHandler = remember {\n        MenuActionHandler(\n            onEditorIntent = intentHandler,\n            onNavigateToUserConfiguration = onNavigateToUserConfiguration\n        )\n    }","chunkType":"PROPERTY","tokens":90,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":75,"endLine":75,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var leftPanelWidth by remember { mutableStateOf(250.dp) }","chunkType":"PROPERTY","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":76,"endLine":76,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var rightPanelWidth by remember { mutableStateOf(250.dp) }","chunkType":"PROPERTY","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":77,"endLine":77,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var bottomPanelHeight by remember { mutableStateOf(100.dp) }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":87,"endLine":87,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n        val maxWidthDp = with(density) { constraints.maxWidth.toDp() }","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":109,"endLine":109,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dx = with(density) { drag.x.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":138,"endLine":138,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dx = with(density) { drag.x.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":170,"endLine":170,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dy = with(density) { drag.y.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ProjectTreePanel","startLine":190,"endLine":190,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ProjectTreePanel(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"FileNodeItem","startLine":232,"endLine":232,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun FileNodeItem(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"EditorPanel","startLine":317,"endLine":317,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun EditorPanel(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ChatPanel","startLine":352,"endLine":352,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ChatPanel(","chunkType":"FUNCTION","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"UserChatMessageItem","startLine":492,"endLine":525,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun UserChatMessageItem(message: UiChatMessage.UserMessage) {\n    val timeFormat = SimpleDateFormat(\"HH:mm\", Locale.getDefault())\n\n    Row(\n        modifier = Modifier.fillMaxWidth(),\n        horizontalArrangement = Arrangement.End\n    ) {\n        Card(\n            colors = CardDefaults.cardColors(\n                containerColor = MindWeaverTheme.colors.surface2\n            ),\n            modifier = Modifier.widthIn(max = 280.dp)\n        ) {\n            Column(\n                modifier = Modifier.padding(12.dp)\n            ) {\n                SelectionContainer {\n                    Text(\n                        text = message.content,\n                        style = MaterialTheme.typography.bodyMedium,\n                        color = MindWeaverTheme.colors.textPrimary\n                    )\n                }\n                Spacer(modifier = Modifier.height(4.dp))\n\n                Text(\n                    text = timeFormat.format(Date(message.timestamp)),\n                    style = MaterialTheme.typography.labelSmall,\n                    color = MindWeaverTheme.colors.textSecondary\n                )\n            }\n        }\n    }\n}","chunkType":"FUNCTION","tokens":329,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"AssistantChatMessageItem","startLine":528,"endLine":528,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun AssistantChatMessageItem(","chunkType":"FUNCTION","tokens":49,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":532,"endLine":532,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    val timeFormat = SimpleDateFormat(\"HH:mm\", Locale.getDefault())","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ThinkingChatMessageItem","startLine":577,"endLine":595,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ThinkingChatMessageItem(message: UiChatMessage.ThinkingMessage) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 16.dp, vertical = 8.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        CircularProgressIndicator(\n            modifier = Modifier.size(16.dp),\n            strokeWidth = 2.dp\n        )\n        Spacer(modifier = Modifier.width(8.dp))\n        Text(\n            text = message.content,\n            style = MaterialTheme.typography.bodyMedium,\n            color = MindWeaverTheme.colors.textSecondary\n        )\n    }\n}","chunkType":"FUNCTION","tokens":194,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"LogsPanel","startLine":598,"endLine":598,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun LogsPanel(","chunkType":"FUNCTION","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"LogEntryItem","startLine":639,"endLine":681,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun LogEntryItem(log: LogEntry) {\n    val timeFormat = SimpleDateFormat(\"HH:mm:ss\", Locale.getDefault())\n\n    Row(\n        modifier = Modifier.fillMaxWidth(),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = timeFormat.format(Date(log.timestamp)),\n            style = MaterialTheme.typography.labelSmall.copy(\n                fontFamily = FontFamily.Monospace\n            ),\n            color = MindWeaverTheme.colors.textSecondary,\n            modifier = Modifier.width(60.dp)\n        )\n        Spacer(modifier = Modifier.width(4.dp))\n\n        Text(\n            text = when (log.level) {\n                UiLogLevel.INFO -> \"ℹ️\"\n                UiLogLevel.WARNING -> \"⚠️\"\n                UiLogLevel.ERROR -> \"❌\"\n                UiLogLevel.DEBUG -> \"🐛\"\n            },\n            modifier = Modifier.width(24.dp)\n        )\n        Spacer(modifier = Modifier.width(4.dp))\n\n        SelectionContainer {\n            Text(\n                text = log.message,\n                style = MaterialTheme.typography.bodySmall.copy(\n                    fontFamily = FontFamily.Monospace\n                ),\n                color = when (log.level) {\n                    UiLogLevel.ERROR -> MindWeaverTheme.colors.error\n                    UiLogLevel.WARNING -> MindWeaverTheme.colors.warning\n                    else -> MindWeaverTheme.colors.textPrimary\n                }\n            )\n        }\n    }\n}","chunkType":"FUNCTION","tokens":401,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"ProjectSelectionScreen","startLine":25,"endLine":32,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nfun ProjectSelectionScreen(component: ProjectSelectionComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n    \n    ProjectSelectionScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":99,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"ProjectSelectionScreen","startLine":36,"endLine":36,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nprivate fun ProjectSelectionScreen(","chunkType":"FUNCTION","tokens":49,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"RecentProjectCard","startLine":184,"endLine":184,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nprivate fun RecentProjectCard(","chunkType":"FUNCTION","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":null,"startLine":189,"endLine":189,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\n    val dateFormat = remember { SimpleDateFormat(\"MMM dd, yyyy\", Locale.getDefault()) }","chunkType":"PROPERTY","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":null,"startLine":190,"endLine":192,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\n    val formattedDate = remember(project.lastOpened) { \n        dateFormat.format(Date(project.lastOpened)) \n    }","chunkType":"PROPERTY","tokens":69,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/repoInfoInput/RepoInfoInputDialog.kt","className":null,"methodName":"RepoInfoInputDialog","startLine":28,"endLine":35,"content":"package com.example.mindweaverstudio.ui.screens.repoInfoInput\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\n\nfun RepoInfoInputDialog(component: RepoInfoInputComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    RepoInfoInputDialog(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":95,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.repoInfoInput","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.Box","androidx.compose.foundation.layout.Column"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/repoInfoInput/RepoInfoInputDialog.kt","className":null,"methodName":"RepoInfoInputDialog","startLine":38,"endLine":38,"content":"package com.example.mindweaverstudio.ui.screens.repoInfoInput\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.Box\n\nprivate fun RepoInfoInputDialog(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.repoInfoInput","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.Box","androidx.compose.foundation.layout.Column"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":"AuthenticationScreen","startLine":23,"endLine":30,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nfun AuthenticationScreen(component: AuthenticationComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n    \n    AuthenticationScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":96,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":"AuthenticationScreen","startLine":34,"endLine":34,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nprivate fun AuthenticationScreen(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":null,"startLine":38,"endLine":38,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\n    var isPasswordVisible by remember { mutableStateOf(false) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":"EditorMenuBar","startLine":22,"endLine":22,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\nfun EditorMenuBar(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\n    var openMenuId by remember { mutableStateOf<String?>(null) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":"MenuBarItem","startLine":59,"endLine":59,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\nprivate fun MenuBarItem(","chunkType":"FUNCTION","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":null,"startLine":8,"endLine":10,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\nclass MenuActionHandler(\n    private val onEditorIntent: (CodeEditorStore.Intent) -> Unit,\n    private val onNavigateToUserConfiguration: () -> Unit = {}","chunkType":"CLASS","tokens":90,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"logAction","startLine":13,"endLine":19,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun logAction(message: String) {\n        val logEntry = LogEntry(\n            message = message,\n            level = UiLogLevel.INFO\n        )\n        onEditorIntent(CodeEditorStore.Intent.AddLogEntry(logEntry))\n    }","chunkType":"FUNCTION","tokens":109,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleAction","startLine":21,"endLine":29,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    fun handleAction(action: ToolbarAction) {\n        when (action) {\n            is ToolbarAction.MenuItemClicked -> handleMenuItemClick(action.menuId, action.itemId)\n            is ToolbarAction.MenuToggled -> {\n                // Menu toggle actions can be handled here if needed\n                // For now, we just track which menu is open in the component state\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":151,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleMenuItemClick","startLine":31,"endLine":39,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleMenuItemClick(menuId: String, itemId: String) {\n        when (menuId) {\n            \"FILE\" -> handleFileMenuAction(itemId)\n            \"EDIT\" -> handleEditMenuAction(itemId)\n            \"VIEW\" -> handleViewMenuAction(itemId)\n            \"TOOLS\" -> handleToolsMenuAction(itemId)\n            \"CONFIGURATION\" -> handleConfigurationMenuAction(itemId)\n        }\n    }","chunkType":"FUNCTION","tokens":148,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleFileMenuAction","startLine":41,"endLine":80,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleFileMenuAction(itemId: String) {\n        when (itemId) {\n            \"new_file\" -> {\n                // Log the action for now - could be extended to create new file\n                logAction(\"Creating new file...\")\n            }\n            \"open_file\" -> {\n                // Log the action for now - could be extended to open file dialog\n                logAction(\"Opening file dialog...\")\n            }\n            \"save\" -> {\n                // Could save current editor content\n                logAction(\"Saving current file...\")\n            }\n            \"save_as\" -> {\n                // Could open save as dialog\n                logAction(\"Opening Save As dialog...\")\n            }\n            \"save_all\" -> {\n                // Could save all open files\n                logAction(\"Saving all files...\")\n            }\n            \"close_file\" -> {\n                // Could close current file\n                logAction(\"Closing current file...\")\n            }\n            \"close_all\" -> {\n                // Could close all open files\n                logAction(\"Closing all files...\")\n            }\n            \"recent_files\" -> {\n                // Could show recent files menu\n                logAction(\"Showing recent files...\")\n            }\n            \"exit\" -> {\n                // Could exit the application\n                logAction(\"Exiting application...\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":409,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleEditMenuAction","startLine":82,"endLine":112,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleEditMenuAction(itemId: String) {\n        when (itemId) {\n            \"undo\" -> {\n                logAction(\"Undo operation performed\")\n            }\n            \"redo\" -> {\n                logAction(\"Redo operation performed\")\n            }\n            \"cut\" -> {\n                logAction(\"Text cut to clipboard\")\n            }\n            \"copy\" -> {\n                logAction(\"Text copied to clipboard\")\n            }\n            \"paste\" -> {\n                logAction(\"Text pasted from clipboard\")\n            }\n            \"select_all\" -> {\n                logAction(\"All text selected\")\n            }\n            \"find\" -> {\n                logAction(\"Find dialog opened\")\n            }\n            \"replace\" -> {\n                logAction(\"Replace dialog opened\")\n            }\n            \"find_in_files\" -> {\n                logAction(\"Find in Files dialog opened\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":283,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleViewMenuAction","startLine":114,"endLine":141,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleViewMenuAction(itemId: String) {\n        when (itemId) {\n            \"zoom_in\" -> {\n                logAction(\"Zooming in...\")\n            }\n            \"zoom_out\" -> {\n                logAction(\"Zooming out...\")\n            }\n            \"reset_zoom\" -> {\n                logAction(\"Zoom reset to 100%\")\n            }\n            \"fullscreen\" -> {\n                logAction(\"Toggled full screen mode\")\n            }\n            \"toggle_project\" -> {\n                logAction(\"Project tree panel visibility toggled\")\n            }\n            \"toggle_chat\" -> {\n                logAction(\"Chat panel visibility toggled\")\n            }\n            \"toggle_logs\" -> {\n                logAction(\"Logs panel visibility toggled\")\n            }\n            \"appearance\" -> {\n                logAction(\"Appearance settings opened\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":271,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleToolsMenuAction","startLine":143,"endLine":174,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleToolsMenuAction(itemId: String) {\n        when (itemId) {\n            \"terminal\" -> {\n                // TODO: Implement terminal\n                println(\"Terminal action\")\n            }\n            \"version_control\" -> {\n                // TODO: Implement version control\n                println(\"Version Control action\")\n            }\n            \"build\" -> {\n                // TODO: Implement build\n                println(\"Build Project action\")\n            }\n            \"run\" -> {\n                // TODO: Implement run\n                println(\"Run action\")\n            }\n            \"debug\" -> {\n                // TODO: Implement debug\n                println(\"Debug action\")\n            }\n            \"generate\" -> {\n                // TODO: Implement code generation\n                println(\"Generate Code action\")\n            }\n            \"database\" -> {\n                // TODO: Implement database tools\n                println(\"Database Tools action\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":306,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleConfigurationMenuAction","startLine":176,"endLine":207,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleConfigurationMenuAction(itemId: String) {\n        when (itemId) {\n            \"user_configuration\" -> {\n                logAction(\"Opening User Configuration...\")\n                onNavigateToUserConfiguration()\n            }\n            \"plugins\" -> {\n                // TODO: Implement plugins\n                println(\"Plugins action\")\n            }\n            \"appearance_behavior\" -> {\n                // TODO: Implement appearance & behavior settings\n                println(\"Appearance & Behavior action\")\n            }\n            \"keymap\" -> {\n                // TODO: Implement keymap settings\n                println(\"Keymap action\")\n            }\n            \"import_settings\" -> {\n                // TODO: Implement import settings\n                println(\"Import Settings action\")\n            }\n            \"export_settings\" -> {\n                // TODO: Implement export settings\n                println(\"Export Settings action\")\n            }\n            \"about\" -> {\n                // TODO: Implement about dialog\n                println(\"About action\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":332,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/models/ToolbarMenu.kt","className":null,"methodName":null,"startLine":7,"endLine":105,"content":"package com.example.mindweaverstudio.ui.components.toolbar.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\ndata class ToolbarMenuItem(\n    val id: String,\n    val title: String,\n    val icon: ImageVector? = null,\n    val shortcut: String? = null,\n    val enabled: Boolean = true,\n    val separator: Boolean = false\n)\n\nenum class ToolbarMenu(\n    val title: String,\n    val items: List<ToolbarMenuItem>\n) {\n    FILE(\n        title = \"File\",\n        items = listOf(\n            ToolbarMenuItem(\"new_file\", \"New File\", Icons.Default.Add, \"Ctrl+N\"),\n            ToolbarMenuItem(\"open_file\", \"Open File\", Icons.Default.FolderOpen, \"Ctrl+O\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"save\", \"Save\", Icons.Default.Save, \"Ctrl+S\"),\n            ToolbarMenuItem(\"save_as\", \"Save As...\", Icons.Default.SaveAs, \"Ctrl+Shift+S\"),\n            ToolbarMenuItem(\"save_all\", \"Save All\", Icons.Default.Save, \"Ctrl+Alt+S\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"close_file\", \"Close File\", Icons.Default.Close, \"Ctrl+W\"),\n            ToolbarMenuItem(\"close_all\", \"Close All\", Icons.Default.CloseFullscreen, \"Ctrl+Shift+W\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"recent_files\", \"Recent Files\", Icons.Default.History),\n            ToolbarMenuItem(\"separator_4\", \"\", separator = true),\n            ToolbarMenuItem(\"exit\", \"Exit\", Icons.Default.ExitToApp, \"Ctrl+Q\")\n        )\n    ),\n    \n    EDIT(\n        title = \"Edit\",\n        items = listOf(\n            ToolbarMenuItem(\"undo\", \"Undo\", Icons.Default.Undo, \"Ctrl+Z\"),\n            ToolbarMenuItem(\"redo\", \"Redo\", Icons.Default.Redo, \"Ctrl+Y\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"cut\", \"Cut\", Icons.Default.ContentCut, \"Ctrl+X\"),\n            ToolbarMenuItem(\"copy\", \"Copy\", Icons.Default.ContentCopy, \"Ctrl+C\"),\n            ToolbarMenuItem(\"paste\", \"Paste\", Icons.Default.ContentPaste, \"Ctrl+V\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"select_all\", \"Select All\", Icons.Default.SelectAll, \"Ctrl+A\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"find\", \"Find\", Icons.Default.Search, \"Ctrl+F\"),\n            ToolbarMenuItem(\"replace\", \"Replace\", Icons.Default.FindReplace, \"Ctrl+H\"),\n            ToolbarMenuItem(\"find_in_files\", \"Find in Files\", Icons.Default.FolderOpen, \"Ctrl+Shift+F\")\n        )\n    ),\n    \n    VIEW(\n        title = \"View\",\n        items = listOf(\n            ToolbarMenuItem(\"zoom_in\", \"Zoom In\", Icons.Default.ZoomIn, \"Ctrl++\"),\n            ToolbarMenuItem(\"zoom_out\", \"Zoom Out\", Icons.Default.ZoomOut, \"Ctrl+-\"),\n            ToolbarMenuItem(\"reset_zoom\", \"Reset Zoom\", Icons.Default.CenterFocusStrong, \"Ctrl+0\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"fullscreen\", \"Toggle Full Screen\", Icons.Default.Fullscreen, \"F11\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"toggle_project\", \"Toggle Project Tree\", Icons.Default.AccountTree, \"Alt+1\"),\n            ToolbarMenuItem(\"toggle_chat\", \"Toggle Chat Panel\", Icons.Default.Chat, \"Alt+2\"),\n            ToolbarMenuItem(\"toggle_logs\", \"Toggle Logs Panel\", Icons.Default.Article, \"Alt+3\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"appearance\", \"Appearance\", Icons.Default.Palette)\n        )\n    ),\n    \n    TOOLS(\n        title = \"Tools\",\n        items = listOf(\n            ToolbarMenuItem(\"terminal\", \"Terminal\", Icons.Default.Terminal, \"Alt+F12\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"version_control\", \"Version Control\", Icons.Default.Source, \"Alt+9\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"build\", \"Build Project\", Icons.Default.Build, \"Ctrl+F9\"),\n            ToolbarMenuItem(\"run\", \"Run\", Icons.Default.PlayArrow, \"Shift+F10\"),\n            ToolbarMenuItem(\"debug\", \"Debug\", Icons.Default.BugReport, \"Shift+F9\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"generate\", \"Generate Code\", Icons.Default.AutoFixHigh, \"Alt+Insert\"),\n            ToolbarMenuItem(\"database\", \"Database Tools\", Icons.Default.Storage)\n        )\n    ),\n    \n    CONFIGURATION(\n        title = \"Configuration\",\n        items = listOf(\n            ToolbarMenuItem(\"user_configuration\", \"User configuration\", Icons.Default.Settings, \"Ctrl+Alt+S\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"plugins\", \"Plugins\", Icons.Default.Extension),\n            ToolbarMenuItem(\"appearance_behavior\", \"Appearance & Behavior\", Icons.Default.Tune),\n            ToolbarMenuItem(\"keymap\", \"Keymap\", Icons.Default.Keyboard),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"import_settings\", \"Import Settings\", Icons.Default.GetApp),\n            ToolbarMenuItem(\"export_settings\", \"Export Settings\", Icons.Default.Publish),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"about\", \"About\", Icons.Default.Info)\n        )\n    )\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/models/ToolbarMenu.kt","className":null,"methodName":null,"startLine":107,"endLine":110,"content":"package com.example.mindweaverstudio.ui.components.toolbar.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\nsealed class ToolbarAction {\n    data class MenuItemClicked(val menuId: String, val itemId: String) : ToolbarAction()\n    data class MenuToggled(val menuId: String, val isOpen: Boolean) : ToolbarAction()\n}","chunkType":"CLASS","tokens":91,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorToolbar.kt","className":null,"methodName":"EditorToolbar","startLine":16,"endLine":16,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nfun EditorToolbar(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorToolbar.kt","className":null,"methodName":"ToolbarButton","startLine":85,"endLine":85,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nprivate fun ToolbarButton(","chunkType":"FUNCTION","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverTheme.kt","className":null,"methodName":null,"startLine":5,"endLine":5,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.runtime.*\n\nval LocalColors = staticCompositionLocalOf { DarkPalette }","chunkType":"PROPERTY","tokens":35,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.runtime.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverTheme.kt","className":null,"methodName":"MindWeaverTheme","startLine":15,"endLine":15,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.runtime.*\n\nfun MindWeaverTheme(","chunkType":"FUNCTION","tokens":25,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.runtime.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverPalette.kt","className":null,"methodName":null,"startLine":5,"endLine":109,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\ndata class MindWeaverPalette(\n    // Background and Surfaces\n    val rootBackground: Color,\n    val surface1: Color,\n    val surface2: Color,\n    val surface3: Color,\n    val surface4: Color,\n    \n    // Borders\n    val borderSubtle: Color,\n    val borderNeutral: Color,\n    val borderStrong: Color,\n    \n    // Text Colors\n    val textPrimary: Color,\n    val textSecondary: Color,\n    val textMuted: Color,\n    val textDisabled: Color,\n    val textInvert: Color,\n    \n    // Accent Colors\n    val accent300: Color,\n    val accent400: Color,\n    val accent500: Color,\n    val accent600: Color,\n    val accent700: Color,\n    \n    // Semantic Colors - Success\n    val success: Color,\n    val successSurface: Color,\n    val successBorder: Color,\n    \n    // Semantic Colors - Warning\n    val warning: Color,\n    val warningSurface: Color,\n    val warningBorder: Color,\n    \n    // Semantic Colors - Error\n    val error: Color,\n    val errorSurface: Color,\n    val errorBorder: Color,\n    \n    // Semantic Colors - Info\n    val info: Color,\n    val infoSurface: Color,\n    val infoBorder: Color,\n    \n    // Editor Specific Colors\n    val selection: Color,\n    val caret: Color,\n    val matchBrackets: Color,\n)\n\nval DarkPalette = MindWeaverPalette(\n    // Background and Surfaces\n    rootBackground = MindWeaverDarkColors.RootBackground,\n    surface1 = MindWeaverDarkColors.Surface1,\n    surface2 = MindWeaverDarkColors.Surface2,\n    surface3 = MindWeaverDarkColors.Surface3,\n    surface4 = MindWeaverDarkColors.Surface4,\n\n    // Borders\n    borderSubtle = MindWeaverDarkColors.BorderSubtle,\n    borderNeutral = MindWeaverDarkColors.BorderNeutral,\n    borderStrong = MindWeaverDarkColors.BorderStrong,\n\n    // Text Colors\n    textPrimary = MindWeaverDarkColors.TextPrimary,\n    textSecondary = MindWeaverDarkColors.TextSecondary,\n    textMuted = MindWeaverDarkColors.TextMuted,\n    textDisabled = MindWeaverDarkColors.TextDisabled,\n    textInvert = MindWeaverDarkColors.TextInvert,\n\n    // Accent Colors\n    accent300 = MindWeaverDarkColors.Accent300,\n    accent400 = MindWeaverDarkColors.Accent400,\n    accent500 = MindWeaverDarkColors.Accent500,\n    accent600 = MindWeaverDarkColors.Accent600,\n    accent700 = MindWeaverDarkColors.Accent700,\n\n    // Semantic Colors - Success\n    success = MindWeaverDarkColors.Success,\n    successSurface = MindWeaverDarkColors.SuccessSurface,\n    successBorder = MindWeaverDarkColors.SuccessBorder,\n\n    // Semantic Colors - Warning\n    warning = MindWeaverDarkColors.Warning,\n    warningSurface = MindWeaverDarkColors.WarningSurface,\n    warningBorder = MindWeaverDarkColors.WarningBorder,\n\n    // Semantic Colors - Error\n    error = MindWeaverDarkColors.Error,\n    errorSurface = MindWeaverDarkColors.ErrorSurface,\n    errorBorder = MindWeaverDarkColors.ErrorBorder,\n\n    // Semantic Colors - Info\n    info = MindWeaverDarkColors.Info,\n    infoSurface = MindWeaverDarkColors.InfoSurface,\n    infoBorder = MindWeaverDarkColors.InfoBorder,\n\n    // Editor Specific Colors\n    selection = MindWeaverDarkColors.Selection,\n    caret = MindWeaverDarkColors.Caret,\n    matchBrackets = MindWeaverDarkColors.MatchBrackets,\n)","chunkType":"CLASS","tokens":809,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.ui.graphics.Color"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/AppModule.kt","className":null,"methodName":null,"startLine":21,"endLine":57,"content":"package com.example.mindweaverstudio.di\n\nimport com.arkivanov.mvikotlin.core.store.StoreFactory\nimport com.arkivanov.mvikotlin.main.store.DefaultStoreFactory\n\nval appModule = module {\n\n    single<Settings> { Settings.createDefault(\"com.example.mindweaverstudio\") }\n    singleOf(::AuthManager)\n    singleOf(::LimitManager)\n\n    // Configuration\n    singleOf(ApiConfiguration::load) bind ApiConfiguration::class\n\n    // Receivers\n    singleOf(::CodeEditorLogReceiver)\n\n    // Clients\n    includes(clientsModule)\n\n    // Tools\n    includes(toolsModule)\n\n    // Pipelines\n    includes(pipelinesModule)\n\n    //Orchestrator\n    factory<CodeOrchestrator> {\n        CodeOrchestrator(\n            tools = get(),\n            configuration = get(),\n        )\n    }\n\n    // Stores\n    singleOf(::DefaultStoreFactory) bind StoreFactory::class\n    factoryOf(::AuthenticationStoreFactory)\n    factoryOf(::ProjectSelectionStoreFactory)\n    factoryOf(::CodeEditorStoreFactory)\n    factoryOf(::UserConfigurationStoreFactory)\n    factoryOf(::RepoInfoInputStoreFactory)\n}","chunkType":"PROPERTY","tokens":262,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.arkivanov.mvikotlin.core.store.StoreFactory","com.arkivanov.mvikotlin.main.store.DefaultStoreFactory","com.example.mindweaverstudio.components.authentication.AuthenticationStoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/PipelinesModule.kt","className":null,"methodName":null,"startLine":10,"endLine":43,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.ai.pipelines.architecture.ArchitecturePipeline\nimport com.example.mindweaverstudio.ai.pipelines.chat.ChatPipeline\n\nval pipelinesModule = module {\n\n    factory<ArchitecturePipeline> {\n        ArchitecturePipeline(\n            config = get(),\n        )\n    }\n\n    factory<ChatPipeline> {\n        ChatPipeline(\n            config = get(),\n        )\n    }\n\n    factory<CodeCreatorPipeline> {\n        CodeCreatorPipeline(\n            config = get(),\n            codeCheckTools = get(),\n        )\n    }\n\n    factory<CodeFixPipeline> {\n        CodeFixPipeline(\n            config = get(),\n        )\n    }\n\n    factory<GithubReleasePipeline> {\n        GithubReleasePipeline(\n            tools = get(),\n            configuration = get(),\n        )\n    }\n}","chunkType":"PROPERTY","tokens":205,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.ai.pipelines.architecture.ArchitecturePipeline","com.example.mindweaverstudio.ai.pipelines.chat.ChatPipeline","com.example.mindweaverstudio.ai.pipelines.codeCreator.CodeCreatorPipeline"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/ToolsModule.kt","className":null,"methodName":null,"startLine":8,"endLine":32,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.ai.tools.codeCheck.CodeCheckTools\nimport com.example.mindweaverstudio.ai.tools.github.GithubTools\n\nval toolsModule = module {\n\n    factory<GithubTools> {\n        GithubTools(\n            githubClient = get()\n        )\n    }\n\n    factory<CodeCheckTools> {\n        CodeCheckTools(\n            dockerClient = get(),\n        )\n    }\n\n    factory<CodePipelineTools> {\n        CodePipelineTools(\n            githubReleasePipeline = get(),\n            architecturePipeline = get(),\n            codeCreatorPipeline = get(),\n            codeFixPipeline = get(),\n            chatPipeline = get(),\n            settings = get(),\n        )\n    }\n}","chunkType":"PROPERTY","tokens":177,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.ai.tools.codeCheck.CodeCheckTools","com.example.mindweaverstudio.ai.tools.github.GithubTools","com.example.mindweaverstudio.ai.tools.pipelines.CodePipelineTools"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/ClientsModule.kt","className":null,"methodName":null,"startLine":7,"endLine":16,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.data.clients.DockerClient\nimport com.example.mindweaverstudio.data.clients.GithubClient\n\nval clientsModule = module {\n    factory<GithubClient> {\n        GithubClient(\n            config = get()\n        )\n    }\n    factory<DockerClient> {\n        DockerClient()\n    }\n}","chunkType":"PROPERTY","tokens":86,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.data.clients.DockerClient","com.example.mindweaverstudio.data.clients.GithubClient","org.koin.dsl.module"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/main.kt","className":null,"methodName":"main","startLine":14,"endLine":36,"content":"package com.example.mindweaverstudio\n\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() {\n    startKoin {\n        modules(appModule)\n    }\n\n    application {\n        val lifecycle = LifecycleRegistry()\n        val root = DefaultRootComponent(componentContext = DefaultComponentContext(lifecycle = lifecycle),)\n\n        val windowState = rememberWindowState()\n        LifecycleController(lifecycle, windowState)\n\n        Window(\n            onCloseRequest = ::exitApplication,\n            state = windowState,\n            title = \"mindweaverstudio\"\n        ) {\n            window.minimumSize = java.awt.Dimension(1800, 900)\n\n            App(component = root)\n        }\n    }\n}","chunkType":"FUNCTION","tokens":181,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio","imports":["androidx.compose.ui.window.Window","androidx.compose.ui.window.application","androidx.compose.ui.window.rememberWindowState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":9,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface SidebarComponent {\n    val state: StateFlow<SidebarStore.State>\n\n    fun onIntent(intent: SidebarStore.Intent)\n}","chunkType":"INTERFACE","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/DefaultSidebarComponent.kt","className":null,"methodName":null,"startLine":9,"endLine":24,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultSidebarComponent(\n    private val sidebarStoreFactory: SidebarStoreFactory,\n    componentContext: ComponentContext,\n) : SidebarComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        sidebarStoreFactory.create()\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<SidebarStore.State> = store.stateFlow\n\n    override fun onIntent(intent: SidebarStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":165,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarStoreFactory.kt","className":null,"methodName":null,"startLine":14,"endLine":77,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass SidebarStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): SidebarStore =\n        object : SidebarStore, Store<SidebarStore.Intent, SidebarStore.State, SidebarStore.Label> by storeFactory.create(\n            name = \"SidebarStore\",\n            initialState = SidebarStore.State(),\n            bootstrapper = SimpleBootstrapper(SidebarStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<SidebarStore.Intent, SidebarStore.Action, SidebarStore.State, Msg, SidebarStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: SidebarStore.Action) = when(action) {\n            SidebarStore.Action.Init -> {\n                // Initialize any required resources\n            }\n        }\n\n        override fun executeIntent(intent: SidebarStore.Intent) {\n            when (intent) {\n                SidebarStore.Intent.ToggleSidebar -> {\n                    dispatch(SidebarToggled)\n                }\n                \n                SidebarStore.Intent.CloseSidebar -> {\n                    dispatch(SidebarClosed)\n                }\n                \n                is SidebarStore.Intent.SelectMenuItem -> {\n                    dispatch(MenuItemSelected(intent.menuItem))\n                }\n                \n                is SidebarStore.Intent.ToggleMenuExpansion -> {\n                    dispatch(MenuItemExpansionToggled(intent.menuItem))\n                }\n                \n                is SidebarStore.Intent.ExecuteSubMenuAction -> {\n                    publish(SidebarStore.Label.SubMenuActionRequested(intent.action, intent.menuItem))\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<SidebarStore.State, Msg> {\n        override fun SidebarStore.State.reduce(msg: Msg): SidebarStore.State =\n            when (msg) {\n                is SidebarToggled -> copy(isVisible = !isVisible)\n                is SidebarClosed -> copy(isVisible = false, selectedMenuItem = null, expandedMenuItems = emptySet())\n                is MenuItemSelected -> copy(selectedMenuItem = msg.menuItem)\n                is MenuItemExpansionToggled -> {\n                    val updatedExpanded = if (expandedMenuItems.contains(msg.menuItem)) {\n                        expandedMenuItems - msg.menuItem\n                    } else {\n                        expandedMenuItems + msg.menuItem\n                    }\n                    copy(expandedMenuItems = updatedExpanded)\n                }\n            }\n    }\n}","chunkType":"CLASS","tokens":697,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarStore.kt","className":null,"methodName":null,"startLine":6,"endLine":36,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.components.codeeditor.models.SidebarMenuItem\n\ninterface SidebarStore : Store<SidebarStore.Intent, SidebarStore.State, SidebarStore.Label> {\n\n    data class State(\n        val isVisible: Boolean = false,\n        val selectedMenuItem: SidebarMenuItem? = null,\n        val expandedMenuItems: Set<SidebarMenuItem> = emptySet()\n    )\n\n    sealed class Intent {\n        data object ToggleSidebar : Intent()\n        data class SelectMenuItem(val menuItem: SidebarMenuItem) : Intent()\n        data class ToggleMenuExpansion(val menuItem: SidebarMenuItem) : Intent()\n        data class ExecuteSubMenuAction(val action: String, val menuItem: SidebarMenuItem) : Intent()\n        data object CloseSidebar : Intent()\n    }\n\n    sealed class Label {\n        data class SubMenuActionRequested(val action: String, val menuItem: SidebarMenuItem) : Label()\n    }\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        data object SidebarToggled : Msg()\n        data object SidebarClosed : Msg()\n        data class MenuItemSelected(val menuItem: SidebarMenuItem) : Msg()\n        data class MenuItemExpansionToggled(val menuItem: SidebarMenuItem) : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":332,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.components.codeeditor.models.SidebarMenuItem"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/DefaultUserConfigurationComponent.kt","className":null,"methodName":null,"startLine":9,"endLine":29,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultUserConfigurationComponent(\n    private val userConfigurationStoreFactory: UserConfigurationStoreFactory,\n    componentContext: ComponentContext,\n    private val onNavigateBack: () -> Unit\n) : UserConfigurationComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        userConfigurationStoreFactory.create()\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<UserConfigurationStore.State> = store.stateFlow\n\n    override fun onIntent(intent: UserConfigurationStore.Intent) {\n        store.accept(intent)\n    }\n\n    override fun onBackPressed() {\n        onNavigateBack()\n    }\n}","chunkType":"CLASS","tokens":213,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationStoreFactory.kt","className":null,"methodName":null,"startLine":16,"endLine":176,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass UserConfigurationStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): UserConfigurationStore =\n        object : UserConfigurationStore, Store<UserConfigurationStore.Intent, UserConfigurationStore.State, UserConfigurationStore.Label> by storeFactory.create(\n            name = \"UserConfigurationStore\",\n            initialState = UserConfigurationStore.State(),\n            bootstrapper = SimpleBootstrapper(UserConfigurationStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<UserConfigurationStore.Intent, UserConfigurationStore.Action, UserConfigurationStore.State, Msg, UserConfigurationStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: UserConfigurationStore.Action) = when(action) {\n            UserConfigurationStore.Action.Init -> {\n                loadUserConfiguration()\n            }\n        }\n\n        override fun executeIntent(intent: UserConfigurationStore.Intent) = when(intent) {\n            is UserConfigurationStore.Intent.UpdateName -> {\n                dispatch(NameUpdated(intent.name))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateRole -> {\n                dispatch(RoleUpdated(intent.role))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdatePreferredLanguage -> {\n                dispatch(PreferredLanguageUpdated(intent.language))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateResponseFormat -> {\n                dispatch(ResponseFormatUpdated(intent.format))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateExperienceLevel -> {\n                dispatch(ExperienceLevelUpdated(intent.level))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateTimeZone -> {\n                dispatch(TimeZoneUpdated(intent.timeZone))\n                checkForUnsavedChanges()\n            }\n            UserConfigurationStore.Intent.SaveConfiguration -> {\n                saveUserConfiguration()\n            }\n            UserConfigurationStore.Intent.ResetConfiguration -> {\n                resetToDefaults()\n            }\n            UserConfigurationStore.Intent.ClearError -> {\n                dispatch(ErrorCleared)\n            }\n        }\n\n        private fun loadUserConfiguration() {\n            dispatch(LoadingStarted)\n            scope.launch {\n                try {\n                    val userPersonalization = PersonalizationConfig.load()\n                    dispatch(UserPersonalizationLoaded(userPersonalization))\n                } catch (e: Exception) {\n                    dispatch(ErrorOccurred(\"Failed to load user configuration: ${e.message}\"))\n                } finally {\n                    dispatch(LoadingFinished)\n                }\n            }\n        }\n\n        private fun saveUserConfiguration() {\n            dispatch(ConfigurationSaveStarted)\n            scope.launch {\n                try {\n                    PersonalizationConfig.save(state().userPersonalization)\n                    dispatch(ConfigurationSaved)\n                    dispatch(UnsavedChangesUpdated(false))\n                    publish(UserConfigurationStore.Label.ConfigurationSaved)\n                } catch (e: Exception) {\n                    dispatch(ErrorOccurred(\"Failed to save user configuration: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun resetToDefaults() {\n            val defaultPersonalization = UserPersonalization()\n            dispatch(UserPersonalizationLoaded(defaultPersonalization))\n            checkForUnsavedChanges()\n        }\n\n        private fun checkForUnsavedChanges() {\n            scope.launch {\n                try {\n                    val savedConfig = PersonalizationConfig.load()\n                    val currentConfig = state().userPersonalization\n                    val hasChanges = savedConfig != currentConfig\n                    dispatch(UnsavedChangesUpdated(hasChanges))\n                } catch (e: Exception) {\n                    // If we can't load saved config, assume we have changes\n                    dispatch(UnsavedChangesUpdated(true))\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<UserConfigurationStore.State, Msg> {\n        override fun UserConfigurationStore.State.reduce(msg: Msg): UserConfigurationStore.State =\n            when (msg) {\n                is UserPersonalizationLoaded -> copy(\n                    userPersonalization = msg.userPersonalization,\n                    hasUnsavedChanges = false\n                )\n                is NameUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(name = msg.name)\n                )\n                is RoleUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(role = msg.role)\n                )\n                is PreferredLanguageUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(preferredLanguage = msg.language)\n                )\n                is ResponseFormatUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(responseFormat = msg.format)\n                )\n                is ExperienceLevelUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(experienceLevel = msg.level)\n                )\n                is TimeZoneUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(timeZone = msg.timeZone)\n                )\n                is ConfigurationSaveStarted -> copy(\n                    isSaving = true,\n                    error = null\n                )\n                is ConfigurationSaved -> copy(\n                    isSaving = false,\n                    error = null\n                )\n                is ErrorOccurred -> copy(\n                    error = msg.error,\n                    isLoading = false,\n                    isSaving = false\n                )\n                is ErrorCleared -> copy(\n                    error = null\n                )\n                is LoadingStarted -> copy(\n                    isLoading = true,\n                    error = null\n                )\n                is LoadingFinished -> copy(\n                    isLoading = false\n                )\n                is UnsavedChangesUpdated -> copy(\n                    hasUnsavedChanges = msg.hasChanges\n                )\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationStore.kt","className":null,"methodName":null,"startLine":9,"endLine":56,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\n\ninterface UserConfigurationStore : Store<UserConfigurationStore.Intent, UserConfigurationStore.State, UserConfigurationStore.Label> {\n\n    data class State(\n        val userPersonalization: UserPersonalization = UserPersonalization(),\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isSaving: Boolean = false,\n        val hasUnsavedChanges: Boolean = false\n    )\n\n    sealed class Intent {\n        data class UpdateName(val name: String) : Intent()\n        data class UpdateRole(val role: WorkRole) : Intent()\n        data class UpdatePreferredLanguage(val language: String) : Intent()\n        data class UpdateResponseFormat(val format: ResponseFormat) : Intent()\n        data class UpdateExperienceLevel(val level: ExperienceLevel) : Intent()\n        data class UpdateTimeZone(val timeZone: String) : Intent()\n        data object SaveConfiguration : Intent()\n        data object ResetConfiguration : Intent()\n        data object ClearError : Intent()\n    }\n\n    sealed class Label {\n        data object ConfigurationSaved : Label()\n        data class NavigationRequested(val destination: String) : Label()\n    }\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        data class UserPersonalizationLoaded(val userPersonalization: UserPersonalization) : Msg()\n        data class NameUpdated(val name: String) : Msg()\n        data class RoleUpdated(val role: WorkRole) : Msg()\n        data class PreferredLanguageUpdated(val language: String) : Msg()\n        data class ResponseFormatUpdated(val format: ResponseFormat) : Msg()\n        data class ExperienceLevelUpdated(val level: ExperienceLevel) : Msg()\n        data class TimeZoneUpdated(val timeZone: String) : Msg()\n        data object ConfigurationSaveStarted : Msg()\n        data object ConfigurationSaved : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        data object LoadingStarted : Msg()\n        data object LoadingFinished : Msg()\n        data class UnsavedChangesUpdated(val hasChanges: Boolean) : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":579,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.data.models.profile.UserPersonalization","com.example.mindweaverstudio.data.models.profile.WorkRole"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":10,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface UserConfigurationComponent {\n    val state: StateFlow<UserConfigurationStore.State>\n\n    fun onIntent(intent: UserConfigurationStore.Intent)\n    fun onBackPressed()\n}","chunkType":"INTERFACE","tokens":71,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":null,"startLine":16,"endLine":49,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultCodeEditorComponent(\n    private val codeEditorStoreFactory: CodeEditorStoreFactory,\n    private val project: Project,\n    private val callbackHandler: (Callback) -> Unit,\n    componentContext: ComponentContext,\n) : CodeEditorComponent, ComponentContext by componentContext {\n\n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n    private val store = instanceKeeper\n        .getStore { codeEditorStoreFactory.create(project = project) }\n\n    init {\n        componentScope.launch {\n            store.labels.collect { label ->\n                when (label) {\n                    is CodeEditorStore.Label.ShowGithubInfoInputDialog ->\n                        callbackHandler.invoke(Callback.ShowRepoInfoInput)\n                }\n            }\n        }\n    }\n\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<CodeEditorStore.State> = store.stateFlow\n\n    override fun onIntent(intent: CodeEditorStore.Intent) {\n        store.accept(intent)\n    }\n\n    override fun onNavigateToUserConfiguration() {\n        callbackHandler.invoke(Callback.ShowUserConfiguration)\n    }\n}","chunkType":"CLASS","tokens":327,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.labels"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorStoreFactory.kt","className":null,"methodName":null,"startLine":28,"endLine":213,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass CodeEditorStoreFactory(\n    private val orchestrator: CodeOrchestrator,\n    private val logReceiver: CodeEditorLogReceiver,\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(project: Project): CodeEditorStore =\n        object : CodeEditorStore, Store<CodeEditorStore.Intent, CodeEditorStore.State, CodeEditorStore.Label> by storeFactory.create(\n            name = \"CodeEditorStore\",\n            initialState = CodeEditorStore.State(project = project),\n            bootstrapper = SimpleBootstrapper(CodeEditorStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<CodeEditorStore.Intent, CodeEditorStore.Action, CodeEditorStore.State, Msg, CodeEditorStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: CodeEditorStore.Action) = when(action) {\n            CodeEditorStore.Action.Init -> {\n                fetchRootNode(state().project.path)\n                setupLogListener()\n                checkRepositoryInfo()\n            }\n        }\n\n        private fun fetchRootNode(filePath: String) {\n            scope.launch {\n                val node = scanDirectoryToFileNode(rootPathStr = filePath)\n                dispatch(OnNodesReceived(node))\n            }\n        }\n\n        private fun setupLogListener() {\n            scope.launch {\n                logReceiver.logFlow.collect { logEntry ->\n                    dispatch(LogEntryAdded(logEntry))\n                }\n            }\n        }\n\n        private fun checkRepositoryInfo() {\n            scope.launch {\n                delay(1000L)\n                publish(CodeEditorStore.Label.ShowGithubInfoInputDialog)\n            }\n        }\n\n        private fun toggleFolderExpansion(nodes: List<FileNode>, targetPath: String): List<FileNode> {\n            return nodes.map { node ->\n                if (node.path == targetPath && node.isDirectory) {\n                    node.copy(expanded = !node.expanded)\n                } else if (node.isDirectory && node.children.isNotEmpty()) {\n                    node.copy(children = toggleFolderExpansion(node.children, targetPath))\n                } else {\n                    node\n                }\n            }\n        }\n\n        override fun executeIntent(intent: CodeEditorStore.Intent) {\n            when (intent) {\n                is CodeEditorStore.Intent.SelectFile -> {\n                    if (!intent.file.isDirectory) {\n                        dispatch(FileSelected(intent.file))\n                        dispatch(EditorContentUpdated(intent.file.content.orEmpty()))\n                        dispatch(\n                            LogEntryAdded(\n                                LogEntry(\n                                    \"Opened file: ${intent.file.name}\",\n                                    UiLogLevel.INFO\n                                )\n                            )\n                        )\n                    }\n                }\n                \n                is CodeEditorStore.Intent.ToggleFolderExpanded -> {\n                    val currentTree = state().projectTree\n                    val updatedTree = toggleFolderExpansion(currentTree, intent.folderPath)\n                    dispatch(ProjectTreeUpdated(updatedTree))\n                }\n                \n                is CodeEditorStore.Intent.UpdateEditorContent -> {\n                    dispatch(EditorContentUpdated(intent.content))\n                }\n                \n                is CodeEditorStore.Intent.UpdateChatInput -> {\n                    dispatch(ChatInputUpdated(intent.input))\n                }\n                \n                is CodeEditorStore.Intent.SendChatMessage -> {\n                    val currentState = state()\n                    if (currentState.chatInput.isNotBlank() && !currentState.isLoading) {\n                        sendMessage(currentState.chatInput, currentState.chatMessages)\n                    }\n                }\n                \n                is CodeEditorStore.Intent.ClearError -> dispatch(ErrorCleared)\n\n                is CodeEditorStore.Intent.UpdatePanelWidth -> {\n                    val clampedWidth = min(0.8f, max(0.1f, intent.width))\n                    dispatch(PanelWidthUpdated(intent.uiPanel, clampedWidth))\n                }\n                \n                is CodeEditorStore.Intent.UpdateBottomPanelHeight -> {\n                    val clampedHeight = min(0.7f, max(0.1f, intent.height))\n                    dispatch(BottomPanelHeightUpdated(clampedHeight))\n                }\n                \n                is CodeEditorStore.Intent.AddLogEntry -> {\n                    dispatch(LogEntryAdded(intent.entry))\n                }\n\n                CodeEditorStore.Intent.RecordVoiceClick -> {\n\n                }\n\n                is CodeEditorStore.Intent.PlayMessage -> playMessage(intent.message)\n            }\n        }\n\n        private fun playMessage(message: String) {\n            ProcessBuilder(\"say\", message).start()\n        }\n\n        private fun sendMessage(\n            message: String,\n            currentMessages: List<UiChatMessage>,\n        ) {\n            val userMessage = UiChatMessage.createUserMessage(message)\n            val thinkingMessage = UiChatMessage.createThinkingMessage()\n\n            val updatedMessages = currentMessages + userMessage + thinkingMessage\n            dispatch(MessagesUpdated(updatedMessages))\n            dispatch(ChatInputUpdated(\"\"))\n            dispatch(LoadingChanged(true))\n\n            scope.launch(Dispatchers.IO) {\n                try {\n                    val result = orchestrator.run(message)\n\n//                    if (result.isError) {\n//                        dispatch(ErrorOccurred(result.message))\n//                    }\n                    val finalMessages = currentMessages + userMessage + listOf(UiChatMessage.createAssistantMessage(result))\n\n                    withContext(Dispatchers.Main) {\n                        dispatch(MessagesUpdated(finalMessages))\n                        dispatch(LoadingChanged(false))\n                    }\n                } catch (e: Exception) {\n                    val errorMessages = currentMessages + userMessage\n                    withContext(Dispatchers.Main) {\n                        dispatch(MessagesUpdated(errorMessages))\n                        dispatch(ErrorOccurred(e.message ?: \"Unknown error occurred\"))\n                        dispatch(LoadingChanged(false))\n                    }\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<CodeEditorStore.State, Msg> {\n        override fun CodeEditorStore.State.reduce(msg: Msg): CodeEditorStore.State =\n            when (msg) {\n                is FileSelected -> copy(selectedFile = msg.file)\n                is EditorContentUpdated -> copy(editorContent = msg.content)\n                is ChatInputUpdated -> copy(chatInput = msg.input)\n                is ChatMessageAdded -> copy(chatMessages = chatMessages + msg.message)\n                is PanelWidthUpdated -> when (msg.uiPanel) {\n                    UiPanel.LEFT -> copy(leftPanelWidth = msg.width)\n                    UiPanel.RIGHT -> copy(rightPanelWidth = msg.width)\n                }\n                is BottomPanelHeightUpdated -> copy(bottomPanelHeight = msg.height)\n                is LogEntryAdded -> copy(logs = logs + msg.entry)\n                is OnNodesReceived -> copy(projectTree = msg.node.children)\n                is ProjectTreeUpdated -> copy(projectTree = msg.tree)\n                is MessagesUpdated -> copy(chatMessages = msg.messages)\n                is LoadingChanged -> copy(isLoading = msg.isLoading)\n                is ErrorOccurred -> copy(error = msg.error, isLoading = false)\n                is ErrorCleared -> copy(error = null)\n                is VoiceRecordingStateChange -> copy(isVoiceRecording = !isVoiceRecording)\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"scanDirectoryToFileNode","startLine":19,"endLine":19,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\nsuspend fun scanDirectoryToFileNode(","chunkType":"FUNCTION","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    val rootReal = try { rootPath.toRealPath(LinkOption.NOFOLLOW_LINKS) } catch (e: IOException) { rootPath.toAbsolutePath() }","chunkType":"PROPERTY","tokens":76,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"uiPathFor","startLine":31,"endLine":39,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    fun uiPathFor(p: Path): String {\n        return try {\n            val rel = rootReal.relativize(p).toString().replace(File.separatorChar, '/')\n            if (rel.isEmpty()) \"/${rootReal.fileName?.toString() ?: \"\"}\" else \"/$rel\"\n        } catch (e: IllegalArgumentException) {\n            // p is on different root (shouldn't happen for normal recursion) — use absolute\n            p.toAbsolutePath().toString().replace(File.separatorChar, '/')\n        }\n    }","chunkType":"FUNCTION","tokens":160,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"walk","startLine":41,"endLine":115,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    fun walk(p: Path, depth: Int): FileNode {\n        if (fileCounter >= maxFiles) return FileNode(\n            name = p.fileName?.toString() ?: p.toString(),\n            path = uiPathFor(p),\n            isDirectory = Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS),\n            children = emptyList(),\n            expanded = depth == 0 // Only root level expanded by default\n        )\n\n        val isDir = Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS)\n        val name = p.fileName?.toString() ?: p.toString()\n        val pathStr = uiPathFor(p)\n\n        if (!includeHidden) {\n            try {\n                if (Files.isHidden(p)) {\n                    return FileNode(\n                        name = name,\n                        path = pathStr,\n                        isDirectory = isDir,\n                        children = emptyList(),\n                        expanded = depth == 0\n                    )\n                }\n            } catch (_: IOException) {}\n        }\n\n        if (!isDir) {\n            fileCounter++\n            val content = try {\n                Files.readString(p) // читаем содержимое файла\n            } catch (_: IOException) {\n                null // если не удалось прочитать (например бинарник или нет доступа)\n            }\n            return FileNode(\n                name = name,\n                path = pathStr,\n                isDirectory = false,\n                content = content,\n                expanded = false // Files don't need expanded state\n            )\n        }\n\n        // directory: protect against symlink loops\n        val real = try { p.toRealPath(LinkOption.NOFOLLOW_LINKS) } catch (e: IOException) { p.toAbsolutePath() }\n        if (!visited.add(real)) {\n            // already visited (symlink loop) — return empty children to avoid recursion\n            return FileNode(name = name, path = pathStr, isDirectory = true, children = emptyList(), expanded = depth == 0)\n        }\n\n        if (depth >= maxDepth) {\n            return FileNode(name = name, path = pathStr, isDirectory = true, children = emptyList(), expanded = depth == 0)\n        }\n\n        val children = ArrayList<FileNode>()\n        try {\n            Files.newDirectoryStream(p).use { ds ->\n                for (child in ds) {\n                    // re-check fileCounter limit\n                    if (fileCounter >= maxFiles) break\n                    // try skip hidden\n                    if (!includeHidden) {\n                        try { if (Files.isHidden(child)) continue } catch (_: IOException) {}\n                    }\n                    children.add(walk(child, depth + 1))\n                }\n            }\n        } catch (e: IOException) {\n            // On permission error or I/O error — just skip children\n        }\n\n        // sort children by name for stable UI order\n        children.sortBy { it.name }\n        return FileNode(name = name, path = pathStr, isDirectory = true, children = children, expanded = depth == 0)\n    }","chunkType":"FUNCTION","tokens":788,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorStore.kt","className":null,"methodName":null,"startLine":10,"endLine":66,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\n\ninterface CodeEditorStore : Store<CodeEditorStore.Intent, CodeEditorStore.State, CodeEditorStore.Label> {\n\n    data class State(\n        val project: Project,\n        val projectTree: List<FileNode> = emptyList(),\n        val selectedFile: FileNode? = null,\n        val editorContent: String = \"\",\n        val chatMessages: List<UiChatMessage> = emptyList(),\n        val chatInput: String = \"\",\n        val logs: List<LogEntry> = emptyList(),\n        val leftPanelWidth: Float = 0.2f,\n        val rightPanelWidth: Float = 0.3f,\n        val bottomPanelHeight: Float = 0.3f,\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isVoiceRecording: Boolean = false,\n    )\n\n    sealed class Intent {\n        class SelectFile(val file: FileNode) : Intent()\n        class ToggleFolderExpanded(val folderPath: String) : Intent()\n        class UpdateEditorContent(val content: String) : Intent()\n        class UpdateChatInput(val input: String) : Intent()\n        class PlayMessage(val message: String) : Intent()\n        data object SendChatMessage : Intent()\n        data class UpdatePanelWidth(val uiPanel: UiPanel, val width: Float) : Intent()\n        data class UpdateBottomPanelHeight(val height: Float) : Intent()\n        data class AddLogEntry(val entry: LogEntry) : Intent()\n        data object ClearError : Intent()\n        data object RecordVoiceClick : Intent()\n    }\n\n    sealed interface Label {\n        data object ShowGithubInfoInputDialog : Label\n    }\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        class FileSelected(val file: FileNode) : Msg()\n        class EditorContentUpdated(val content: String) : Msg()\n        class ChatInputUpdated(val input: String) : Msg()\n        class ChatMessageAdded(val message: UiChatMessage) : Msg()\n        class MessagesUpdated(val messages: List<UiChatMessage>) : Msg()\n        class LoadingChanged(val isLoading: Boolean) : Msg()\n        class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        class PanelWidthUpdated(val uiPanel: UiPanel, val width: Float) : Msg()\n        class BottomPanelHeightUpdated(val height: Float) : Msg()\n        class LogEntryAdded(val entry: LogEntry) : Msg()\n        class OnNodesReceived(val node: FileNode) : Msg()\n        class ProjectTreeUpdated(val tree: List<FileNode>) : Msg()\n        data object VoiceRecordingStateChange : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":658,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.components.codeeditor.models.FileNode","com.example.mindweaverstudio.components.codeeditor.models.LogEntry"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/ChatMessage.kt","className":null,"methodName":null,"startLine":3,"endLine":37,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nsealed class UiChatMessage {\n    abstract val content: String\n    abstract val timestamp: Long\n    \n    data class UserMessage(\n        override val content: String,\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n    \n    data class AssistantMessage(\n        override val content: String,\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n    \n    data class ThinkingMessage(\n        override val content: String = \"Thinking...\",\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n\n    \n    companion object {\n        \n        fun createUserMessage(content: String): UserMessage {\n            return UserMessage(content = content)\n        }\n        \n        fun createAssistantMessage(content: String): AssistantMessage {\n            return AssistantMessage(content = content)\n        }\n        \n        fun createThinkingMessage(): ThinkingMessage {\n            return ThinkingMessage()\n        }\n    }\n}","chunkType":"CLASS","tokens":273,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/UiPanel.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nenum class UiPanel {\n    LEFT, RIGHT\n}","chunkType":"CLASS","tokens":26,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/UiLogLevel.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nenum class UiLogLevel {\n    INFO, WARNING, ERROR, DEBUG\n}","chunkType":"CLASS","tokens":31,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/FileNode.kt","className":null,"methodName":null,"startLine":3,"endLine":10,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\ndata class FileNode(\n    val name: String,\n    val path: String,\n    val isDirectory: Boolean,\n    val content: String? = null,\n    val children: List<FileNode> = emptyList(),\n    val expanded: Boolean = true\n)","chunkType":"CLASS","tokens":69,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/SidebarMenuItem.kt","className":null,"methodName":null,"startLine":7,"endLine":64,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\nenum class SidebarMenuItem(\n    val title: String,\n    val icon: ImageVector,\n    val items: List<SidebarSubMenuItem> = emptyList()\n) {\n    FILE(\n        title = \"File\",\n        icon = Icons.Default.Folder,\n        items = listOf(\n            SidebarSubMenuItem(\"New File\", Icons.Default.Add, \"new_file\"),\n            SidebarSubMenuItem(\"Open File\", Icons.Default.FolderOpen, \"open_file\"),\n            SidebarSubMenuItem(\"Save\", Icons.Default.Save, \"save\"),\n            SidebarSubMenuItem(\"Save As...\", Icons.Default.SaveAs, \"save_as\"),\n            SidebarSubMenuItem(\"Close\", Icons.Default.Close, \"close\")\n        )\n    ),\n    EDIT(\n        title = \"Edit\",\n        icon = Icons.Default.Edit,\n        items = listOf(\n            SidebarSubMenuItem(\"Cut\", Icons.Default.ContentCut, \"cut\"),\n            SidebarSubMenuItem(\"Copy\", Icons.Default.ContentCopy, \"copy\"),\n            SidebarSubMenuItem(\"Paste\", Icons.Default.ContentPaste, \"paste\"),\n            SidebarSubMenuItem(\"Find\", Icons.Default.Search, \"find\"),\n            SidebarSubMenuItem(\"Replace\", Icons.Default.FindReplace, \"replace\")\n        )\n    ),\n    VIEW(\n        title = \"View\",\n        icon = Icons.Default.Visibility,\n        items = listOf(\n            SidebarSubMenuItem(\"Zoom In\", Icons.Default.ZoomIn, \"zoom_in\"),\n            SidebarSubMenuItem(\"Zoom Out\", Icons.Default.ZoomOut, \"zoom_out\"),\n            SidebarSubMenuItem(\"Full Screen\", Icons.Default.Fullscreen, \"full_screen\"),\n            SidebarSubMenuItem(\"Toggle Sidebar\", Icons.Default.Menu, \"toggle_sidebar\")\n        )\n    ),\n    TOOLS(\n        title = \"Tools\",\n        icon = Icons.Default.Build,\n        items = listOf(\n            SidebarSubMenuItem(\"Terminal\", Icons.Default.Terminal, \"terminal\"),\n            SidebarSubMenuItem(\"Git\", Icons.Default.Storage, \"git\"),\n            SidebarSubMenuItem(\"Build\", Icons.Default.PlayArrow, \"build\"),\n            SidebarSubMenuItem(\"Debug\", Icons.Default.BugReport, \"debug\")\n        )\n    ),\n    CONFIGURATION(\n        title = \"Configuration\",\n        icon = Icons.Default.Settings,\n        items = listOf(\n            SidebarSubMenuItem(\"Preferences\", Icons.Default.Tune, \"preferences\"),\n            SidebarSubMenuItem(\"Plugins\", Icons.Default.Extension, \"plugins\"),\n            SidebarSubMenuItem(\"Themes\", Icons.Default.Palette, \"themes\"),\n            SidebarSubMenuItem(\"Shortcuts\", Icons.Default.Keyboard, \"shortcuts\")\n        )\n    )\n}","chunkType":"CLASS","tokens":644,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/SidebarMenuItem.kt","className":null,"methodName":null,"startLine":66,"endLine":70,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\ndata class SidebarSubMenuItem(\n    val title: String,\n    val icon: ImageVector,\n    val action: String\n)","chunkType":"CLASS","tokens":66,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/LogEntry.kt","className":null,"methodName":null,"startLine":5,"endLine":14,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport kotlin.String\n\nclass LogEntry(\n    val message: String,\n    val level: UiLogLevel,\n    val timestamp: Long = System.currentTimeMillis()\n)\n\nfun String.createInfoLogEntry() = LogEntry(\n    level = UiLogLevel.INFO,\n    message = this,\n)","chunkType":"CLASS","tokens":76,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["kotlin.String"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":15,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface CodeEditorComponent {\n    val state: StateFlow<CodeEditorStore.State>\n\n    fun onIntent(intent: CodeEditorStore.Intent)\n    fun onNavigateToUserConfiguration()\n\n    sealed interface Callback {\n        data object ShowUserConfiguration : Callback\n        data object ShowRepoInfoInput: Callback\n    }\n}","chunkType":"INTERFACE","tokens":103,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/DefaultProjectSelectionComponent.kt","className":null,"methodName":null,"startLine":16,"endLine":52,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultProjectSelectionComponent(\n    private val projectSelectionStoreFactory: ProjectSelectionStoreFactory,\n    private val callbackHandler: (Callback) -> Unit,\n    componentContext: ComponentContext,\n) : ProjectSelectionComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        projectSelectionStoreFactory.create()\n    }\n    \n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n\n    init {\n        store.labels\n            .onEach { label ->\n                when (label) {\n                    is ProjectSelectionStore.Label.ProjectSelected -> {\n                        callbackHandler.invoke(Callback.ProjectSelected(project = label.project))\n                    }\n                    is ProjectSelectionStore.Label.ShowError -> {\n                        // Error handling could be implemented here if needed\n                    }\n                    is ProjectSelectionStore.Label.ShowFilePicker -> {\n                        // File picker is handled within the store\n                    }\n                }\n            }\n            .launchIn(componentScope)\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<ProjectSelectionStore.State> = store.stateFlow\n\n    override fun onIntent(intent: ProjectSelectionStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":391,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStore.kt","className":null,"methodName":null,"startLine":6,"endLine":27,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport kotlinx.serialization.Serializable\n\ninterface ProjectSelectionStore : Store<ProjectSelectionStore.Intent, ProjectSelectionStore.State, ProjectSelectionStore.Label> {\n\n    data class State(\n        val projects: List<Project> = emptyList(),\n        val isLoading: Boolean = false,\n        val error: String? = null\n    )\n\n    sealed class Intent {\n        object LoadRecentProjects : Intent()\n        object SelectNewProject : Intent()\n        class OpenProject(val project: Project) : Intent()\n        class RemoveProject(val path: String) : Intent()\n        class AddRecentProject(val path: String) : Intent()\n    }\n\n    sealed class Label {\n        class ShowError(val message: String) : Label()\n        class ProjectSelected(val project: Project) : Label()\n        object ShowFilePicker : Label()\n    }\n}","chunkType":"INTERFACE","tokens":232,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Store","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStore.kt","className":null,"methodName":null,"startLine":30,"endLine":34,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport kotlinx.serialization.Serializable\n\ndata class Project(\n    val path: String,\n    val name: String,\n    val lastOpened: Long\n)","chunkType":"CLASS","tokens":61,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Store","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStoreFactory.kt","className":null,"methodName":null,"startLine":19,"endLine":214,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nclass ProjectSelectionStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): ProjectSelectionStore =\n        object : ProjectSelectionStore, Store<ProjectSelectionStore.Intent, ProjectSelectionStore.State, ProjectSelectionStore.Label> by storeFactory.create(\n            name = \"ProjectSelectionStore\",\n            initialState = ProjectSelectionStore.State(),\n            bootstrapper = Bootstrapper(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private sealed class Action {\n        data object LoadRecentProjects : Action()\n    }\n\n    private sealed class Msg {\n        data class RecentProjectsLoaded(val projects: List<Project>) : Msg()\n        data class LoadingChanged(val isLoading: Boolean) : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n    }\n\n    private inner class Bootstrapper: CoroutineBootstrapper<Action>() {\n        override fun invoke() {\n            dispatch(Action.LoadRecentProjects)\n        }\n    }\n\n    private inner class ExecutorImpl : CoroutineExecutor<ProjectSelectionStore.Intent, Action, ProjectSelectionStore.State, Msg, ProjectSelectionStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        private val preferences = Preferences.userNodeForPackage(ProjectSelectionStoreFactory::class.java)\n        private val json = Json { ignoreUnknownKeys = true }\n\n        override fun executeIntent(intent: ProjectSelectionStore.Intent) {\n            when (intent) {\n                is ProjectSelectionStore.Intent.AddRecentProject -> addRecentProject(intent.path)\n                is ProjectSelectionStore.Intent.OpenProject -> selectProject(intent.project)\n                is ProjectSelectionStore.Intent.RemoveProject -> removeProject(intent.path)\n                is ProjectSelectionStore.Intent.LoadRecentProjects -> loadRecentProjects()\n                is ProjectSelectionStore.Intent.SelectNewProject -> showFilePicker()\n            }\n        }\n\n        override fun executeAction(action: Action) {\n            when (action) {\n                is Action.LoadRecentProjects -> loadRecentProjects()\n            }\n        }\n\n        private fun loadRecentProjects() {\n            dispatch(Msg.LoadingChanged(true))\n            scope.launch {\n                try {\n                    val projectsJson = preferences.get(\"recent_projects\", \"[]\")\n                    val storedProjects = json.decodeFromString<List<StoredProject>>(projectsJson)\n                    \n                    val projects = storedProjects\n                        .filter { File(it.path).exists() } // Only include existing directories\n                        .map { stored ->\n                            Project(\n                                path = stored.path,\n                                name = File(stored.path).name.takeIf { it.isNotEmpty() } ?: stored.path,\n                                lastOpened = stored.lastOpened\n                            )\n                        }\n                        .sortedByDescending { it.lastOpened }\n                        .take(10) // Limit to 10 recent projects\n                    \n                    // Clean up preferences if we filtered out non-existing projects\n                    if (projects.size != storedProjects.size) {\n                        saveRecentProjects(projects)\n                    }\n                    \n                    dispatch(Msg.RecentProjectsLoaded(projects))\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to load recent projects: ${e.message}\"))\n                } finally {\n                    dispatch(Msg.LoadingChanged(false))\n                }\n            }\n        }\n\n        private fun addRecentProject(path: String) {\n            scope.launch {\n                try {\n                    val currentProjects = state().projects.toMutableList()\n                    \n                    // Remove if already exists\n                    currentProjects.removeAll { it.path == path }\n                    \n                    // Add at the beginning\n                    val newProject = Project(\n                        path = path,\n                        name = File(path).name.takeIf { it.isNotEmpty() } ?: path,\n                        lastOpened = System.currentTimeMillis()\n                    )\n                    currentProjects.add(0, newProject)\n                    \n                    // Keep only last 10\n                    val limitedProjects = currentProjects.take(10)\n                    \n                    saveRecentProjects(limitedProjects)\n                    dispatch(Msg.RecentProjectsLoaded(limitedProjects))\n                    \n                    selectProject(newProject)\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to add recent project: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun removeProject(path: String) {\n            scope.launch {\n                try {\n                    val updatedProjects = state().projects.filter { it.path != path }\n                    saveRecentProjects(updatedProjects)\n                    dispatch(Msg.RecentProjectsLoaded(updatedProjects))\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to remove project: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun saveRecentProjects(projects: List<Project>) {\n            val storedProjects = projects.map { \n                StoredProject(path = it.path, lastOpened = it.lastOpened) \n            }\n            val json = json.encodeToString(storedProjects)\n            preferences.put(\"recent_projects\", json)\n        }\n\n        private fun showFilePicker() {\n            SwingUtilities.invokeLater {\n                val fileChooser = JFileChooser().apply {\n                    dialogTitle = \"Select Project Directory\"\n                    fileSelectionMode = JFileChooser.DIRECTORIES_ONLY\n                    isAcceptAllFileFilterUsed = false\n                    \n                    // Set current directory to user home or last opened project directory\n                    val lastProject = state().projects.firstOrNull()\n                    if (lastProject != null) {\n                        val lastProjectDir = File(lastProject.path).parentFile\n                        if (lastProjectDir?.exists() == true) {\n                            currentDirectory = lastProjectDir\n                        }\n                    } else {\n                        currentDirectory = File(System.getProperty(\"user.home\"))\n                    }\n                }\n                \n                val result = fileChooser.showOpenDialog(null)\n                if (result == JFileChooser.APPROVE_OPTION) {\n                    val selectedDirectory = fileChooser.selectedFile\n                    if (selectedDirectory != null && selectedDirectory.isDirectory) {\n                        // Add to recent projects and navigate\n                        scope.launch {\n                            try {\n                                addRecentProject(selectedDirectory.absolutePath)\n                            } catch (e: Exception) {\n                                dispatch(Msg.ErrorOccurred(\"Failed to select project: ${e.message}\"))\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Select file and create RAG chunk file\n        private fun selectProject(project: Project) {\n            scope.launch(Dispatchers.IO) {\n                RAGChunkingUtility().processRepositoryStreaming(\n                    repositoryPath = project.path,\n                    outputBasePath = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/truly_streaming_output\",\n                    includeTests = false,\n                    createRAGOutput = true,\n                    ragBatchSize = 500,\n                )\n            }\n            publish(ProjectSelectionStore.Label.ProjectSelected(project))\n        }\n\n    }\n\n    private object ReducerImpl : Reducer<ProjectSelectionStore.State, Msg> {\n        override fun ProjectSelectionStore.State.reduce(msg: Msg): ProjectSelectionStore.State =\n            when (msg) {\n                is Msg.RecentProjectsLoaded -> copy(projects = msg.projects, error = null)\n                is Msg.LoadingChanged -> copy(isLoading = msg.isLoading)\n                is Msg.ErrorOccurred -> copy(error = msg.error)\n                is Msg.ErrorCleared -> copy(error = null)\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStoreFactory.kt","className":null,"methodName":null,"startLine":217,"endLine":220,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nprivate data class StoredProject(\n    val path: String,\n    val lastOpened: Long\n)","chunkType":"CLASS","tokens":61,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":13,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface ProjectSelectionComponent {\n    val state: StateFlow<ProjectSelectionStore.State>\n\n    fun onIntent(intent: ProjectSelectionStore.Intent)\n\n    sealed interface Callback {\n        class ProjectSelected(val project: Project) : Callback\n    }\n}","chunkType":"INTERFACE","tokens":89,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/repoInfoInput/RepoInfoInputComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":13,"content":"package com.example.mindweaverstudio.components.repoInfoInput\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface RepoInfoInputComponent {\n    val state: StateFlow<RepoInfoInputStore.State>\n\n    fun onIntent(intent: RepoInfoInputStore.Intent)\n\n    sealed interface Callback {\n        data object CloseDialog : Callback\n    }\n}","chunkType":"INTERFACE","tokens":81,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.repoInfoInput","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/repoInfoInput/DefaultRepoInfoInputComponent.kt","className":null,"methodName":null,"startLine":14,"endLine":42,"content":"package com.example.mindweaverstudio.components.repoInfoInput\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultRepoInfoInputComponent(\n    private val storeFactory: RepoInfoInputStoreFactory,\n    private val callbackHandler: (RepoInfoInputComponent.Callback) -> Unit,\n    componentContext: ComponentContext,\n) : RepoInfoInputComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        storeFactory.create()\n    }\n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n\n    init {\n        componentScope.launch {\n            store.labels.collect { label ->\n                when (label) {\n                    is RepoInfoInputStore.Label.ConfirmChanges, is RepoInfoInputStore.Label.CancelDialog ->\n                        callbackHandler.invoke(RepoInfoInputComponent.Callback.CloseDialog)\n                }\n            }\n        }\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<RepoInfoInputStore.State> = store.stateFlow\n\n    override fun onIntent(intent: RepoInfoInputStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":302,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.repoInfoInput","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.labels"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/repoInfoInput/RepoInfoInputStore.kt","className":null,"methodName":null,"startLine":6,"endLine":25,"content":"package com.example.mindweaverstudio.components.repoInfoInput\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.components.repoInfoInput.RepoInfoInputStore.*\n\ninterface RepoInfoInputStore : Store<Intent, State, Label> {\n\n    data class State(\n        val repoName: String = \"\",\n        val repoOwner: String = \"\"\n    )\n\n    sealed interface Intent {\n        data object OnConfirmChanges : Intent\n        data object OnCancel : Intent\n\n        class OnRepoNameChange(val newValue: String) : Intent\n        class OnRepoOwnerChange(val newValue: String) : Intent\n    }\n\n    sealed interface Label {\n        data object ConfirmChanges : Label\n        data object CancelDialog : Label\n    }\n}","chunkType":"INTERFACE","tokens":180,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.repoInfoInput","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.components.repoInfoInput.RepoInfoInputStore.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/repoInfoInput/RepoInfoInputStoreFactory.kt","className":null,"methodName":null,"startLine":15,"endLine":87,"content":"package com.example.mindweaverstudio.components.repoInfoInput\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass RepoInfoInputStoreFactory(\n    private val storeFactory: StoreFactory,\n    private val settings: Settings\n) {\n\n    fun create(): RepoInfoInputStore =\n        object : RepoInfoInputStore, Store<Intent, State, Label> by storeFactory.create(\n            name = \"ProjectSelectionStore\",\n            initialState = State(),\n            bootstrapper = SimpleBootstrapper(Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private sealed class Msg {\n        data class RepoNameUpdates(val newValue: String) : Msg()\n        data class RepoOwnerUpdates(val newValue: String) : Msg()\n    }\n\n    private sealed interface Action {\n        data object Init : Action\n    }\n\n    private inner class ExecutorImpl : CoroutineExecutor<Intent, Action, State, Msg, Label>(\n        mainContext = Dispatchers.Swing,\n    ) {\n\n        override fun executeIntent(intent: Intent) = when(intent) {\n            is Intent.OnRepoOwnerChange ->  dispatch(Msg.RepoOwnerUpdates(intent.newValue))\n            is Intent.OnRepoNameChange -> dispatch(Msg.RepoNameUpdates(intent.newValue))\n            is Intent.OnCancel -> publish(Label.CancelDialog)\n            is Intent.OnConfirmChanges -> confirmChanges()\n        }\n\n        override fun executeAction(action: Action) = when(action) {\n            Action.Init -> fetchRepoInformation()\n        }\n\n        private fun fetchRepoInformation() {\n            scope.launch {\n                val (repoName, repoOwner) = settings.getString(key = SettingsKey.GITHUB_REPO_NAME) to\n                        settings.getString(key = SettingsKey.GITHUB_REPO_OWNER)\n\n                dispatch(Msg.RepoOwnerUpdates(repoOwner))\n                dispatch(Msg.RepoNameUpdates(repoName))\n            }\n        }\n\n        private fun confirmChanges() {\n            scope.launch {\n                val (newRepoOwner, newRepoName) = state().repoOwner to state().repoName\n                val (currentRepoName, currentRepoOwner) = settings.getString(key = SettingsKey.GITHUB_REPO_NAME) to\n                        settings.getString(key = SettingsKey.GITHUB_REPO_OWNER)\n\n                if (newRepoOwner != currentRepoOwner) {\n                    settings.putString(SettingsKey.GITHUB_REPO_OWNER, state().repoOwner)\n                }\n                if (newRepoName != currentRepoName) {\n                    settings.putString(SettingsKey.GITHUB_REPO_NAME, state().repoName)\n                }\n                publish(Label.ConfirmChanges)\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<State, Msg> {\n        override fun State.reduce(msg: Msg): State =\n            when (msg) {\n                is Msg.RepoNameUpdates -> copy(repoName = msg.newValue)\n                is Msg.RepoOwnerUpdates -> copy(repoOwner = msg.newValue)\n            }\n    }\n}","chunkType":"CLASS","tokens":749,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.repoInfoInput","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/root/DefaultRootComponent.kt","className":null,"methodName":null,"startLine":27,"endLine":150,"content":"package com.example.mindweaverstudio.components.root\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\n\nclass DefaultRootComponent(componentContext: ComponentContext) : RootComponent, KoinComponent, ComponentContext by componentContext {\n\n    /** Private properties */\n\n    private val navigation = StackNavigation<Config>()\n\n    /** Public properties */\n\n    override val stack: Value<ChildStack<*, Child>> = childStack(\n        source = navigation,\n        serializer = Config.serializer(),\n        initialConfiguration = Config.Authentication,\n        handleBackButton = true,\n        childFactory = ::child\n    )\n\n    /** Private methods */\n\n    private fun child(config: Config, componentContext: ComponentContext): Child {\n        return when(config) {\n            is Config.Authentication -> Child.Authentication(authenticationComponent(componentContext))\n            is Config.ProjectSelection -> Child.ProjectSelection(projectSelectionComponent(componentContext))\n            is Config.CodeEditor -> Child.CodeEditor(codeEditorComponent(\n                componentContext = componentContext,\n                project = config.project\n            ))\n            is Config.UserConfiguration -> Child.UserConfiguration(userConfigurationComponent(componentContext))\n            is Config.RepoInfoInput -> Child.RepoInfoInput(repoInfoInputComponent(componentContext))\n        }\n    }\n\n    private fun authenticationComponent(componentContext: ComponentContext): AuthenticationComponent {\n        return DefaultAuthenticationComponent(\n            callbackHandler = ::handleAuthentificationCallbacks,\n            componentContext = componentContext,\n            authenticationStoreFactory = get(),\n        )\n    }\n\n    private fun projectSelectionComponent(componentContext: ComponentContext): ProjectSelectionComponent {\n        return DefaultProjectSelectionComponent(\n            callbackHandler = ::handleProjectSelectionCallbacks,\n            projectSelectionStoreFactory = get(),\n            componentContext = componentContext,\n        )\n    }\n\n    private fun codeEditorComponent(\n        componentContext: ComponentContext,\n        project: Project,\n    ): CodeEditorComponent {\n        return DefaultCodeEditorComponent(\n            callbackHandler = ::handleCodeEditorCallbacks,\n            componentContext = componentContext,\n            codeEditorStoreFactory = get(),\n            project = project,\n        )\n    }\n\n    private fun userConfigurationComponent(componentContext: ComponentContext): UserConfigurationComponent {\n        return DefaultUserConfigurationComponent(\n            userConfigurationStoreFactory = get(),\n            componentContext = componentContext,\n            onNavigateBack = {\n                navigateBack()\n            }\n        )\n    }\n\n    private fun repoInfoInputComponent(componentContext: ComponentContext): RepoInfoInputComponent {\n        return DefaultRepoInfoInputComponent(\n            componentContext = componentContext,\n            storeFactory = get(),\n            callbackHandler = ::handleRepoInfoInputCallbacks,\n        )\n    }\n\n    /** Child components callbacks */\n\n    private fun handleAuthentificationCallbacks(callback: AuthenticationComponent.Callback) = when(callback) {\n        AuthenticationComponent.Callback.SuccessAuthentification ->\n            navigation.bringToFront(Config.ProjectSelection)\n    }\n\n    private fun handleCodeEditorCallbacks(callback: CodeEditorComponent.Callback) = when(callback) {\n        CodeEditorComponent.Callback.ShowUserConfiguration ->\n            navigation.bringToFront(Config.UserConfiguration)\n\n        CodeEditorComponent.Callback.ShowRepoInfoInput ->\n            navigation.pushNew(Config.RepoInfoInput)\n    }\n\n    private fun handleProjectSelectionCallbacks(callback: ProjectSelectionComponent.Callback) = when(callback) {\n        is ProjectSelectionComponent.Callback.ProjectSelected ->\n            navigation.bringToFront(Config.CodeEditor(project = callback.project))\n    }\n\n    private fun handleRepoInfoInputCallbacks(callback: RepoInfoInputComponent.Callback) = when(callback) {\n        is RepoInfoInputComponent.Callback.CloseDialog -> navigateBack()\n    }\n\n    private fun navigateBack() {\n        navigation.pop()\n    }\n\n    @Serializable\n    private sealed interface Config {\n        \n        @Serializable\n        data object Authentication : Config\n        \n        @Serializable\n        data object ProjectSelection : Config\n        \n        @Serializable\n        class CodeEditor(val project: Project) : Config\n        \n        @Serializable\n        data object UserConfiguration : Config\n\n        @Serializable\n        data object RepoInfoInput : Config\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.root","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.decompose.router.stack.ChildStack","com.arkivanov.decompose.router.stack.StackNavigation"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/root/RootComponent.kt","className":null,"methodName":null,"startLine":12,"endLine":22,"content":"package com.example.mindweaverstudio.components.root\n\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.value.Value\n\ninterface RootComponent {\n    val stack: Value<ChildStack<*, Child>>\n\n    sealed interface Child {\n        class Authentication(val component: AuthenticationComponent) : Child\n        class ProjectSelection(val component: ProjectSelectionComponent) : Child\n        class CodeEditor(val component: CodeEditorComponent) : Child\n        class UserConfiguration(val component: UserConfigurationComponent) : Child\n        class RepoInfoInput(val component: RepoInfoInputComponent) : Child\n    }\n}","chunkType":"INTERFACE","tokens":161,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.root","imports":["com.arkivanov.decompose.router.stack.ChildStack","com.arkivanov.decompose.value.Value","com.example.mindweaverstudio.components.authentication.AuthenticationComponent"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationStoreFactory.kt","className":null,"methodName":null,"startLine":14,"endLine":156,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nclass AuthenticationStoreFactory(\n    private val storeFactory: StoreFactory,\n    private val authManager: AuthManager,\n) {\n\n    fun create(): AuthenticationStore =\n        object : AuthenticationStore, Store<AuthenticationStore.Intent, AuthenticationStore.State, AuthenticationStore.Label> by storeFactory.create(\n            name = \"AuthenticationStore\",\n            initialState = AuthenticationStore.State(),\n            bootstrapper = Bootstrapper(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private sealed class Action {\n        data object CheckAuthenticationStatus : Action()\n    }\n\n    private sealed class Msg {\n        data class EmailUpdated(val email: String, val isValid: Boolean) : Msg()\n        data class PasswordUpdated(val password: String, val isValid: Boolean) : Msg()\n        data class LoadingChanged(val isLoading: Boolean) : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        data object AuthenticationSucceeded : Msg()\n    }\n\n    private inner class Bootstrapper: CoroutineBootstrapper<Action>() {\n        override fun invoke() {\n            dispatch(Action.CheckAuthenticationStatus)\n        }\n    }\n\n    private inner class ExecutorImpl : CoroutineExecutor<AuthenticationStore.Intent, Action, AuthenticationStore.State, Msg, AuthenticationStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        private val preferences = Preferences.userNodeForPackage(AuthenticationStoreFactory::class.java)\n\n        override fun executeIntent(intent: AuthenticationStore.Intent) {\n            when (intent) {\n                is AuthenticationStore.Intent.UpdateEmail -> {\n                    val isValid = isValidEmail(intent.email)\n                    dispatch(Msg.EmailUpdated(intent.email, isValid))\n                }\n                \n                is AuthenticationStore.Intent.UpdatePassword -> {\n                    val isValid = isValidPassword(intent.password)\n                    dispatch(Msg.PasswordUpdated(intent.password, isValid))\n                }\n                \n                is AuthenticationStore.Intent.SignIn -> {\n                    signIn()\n                }\n                \n                is AuthenticationStore.Intent.ClearError -> {\n                    dispatch(Msg.ErrorCleared)\n                }\n            }\n        }\n\n        override fun executeAction(action: Action) {\n            when (action) {\n                is Action.CheckAuthenticationStatus -> checkAuthenticationStatus()\n            }\n        }\n\n        private fun checkAuthenticationStatus() {\n            scope.launch {\n                try {\n                    val isAuthenticated = preferences.getBoolean(\"is_authenticated\", false)\n                    if (isAuthenticated) {\n                        dispatch(Msg.AuthenticationSucceeded)\n                        publish(AuthenticationStore.Label.AuthenticationSuccessful)\n                    }\n                } catch (e: Exception) {\n                    // Ignore errors during status check\n                }\n            }\n        }\n\n        private fun signIn() {\n            val state = state()\n            \n            if (!state.isEmailValid || !state.isPasswordValid) {\n                dispatch(Msg.ErrorOccurred(\"Please enter valid email and password\"))\n                return\n            }\n            \n            if (state.email.isBlank()) {\n                dispatch(Msg.ErrorOccurred(\"Email is required\"))\n                return\n            }\n            \n            if (state.password.isBlank()) {\n                dispatch(Msg.ErrorOccurred(\"Password is required\"))\n                return\n            }\n\n            dispatch(Msg.LoadingChanged(true))\n            \n            scope.launch {\n                try {\n                    val token = authManager.generateToken(state.email, state.password)\n\n                    if (token != null) {\n                        dispatch(Msg.AuthenticationSucceeded)\n                        publish(AuthenticationStore.Label.AuthenticationSuccessful)\n                    } else {\n                        dispatch(Msg.ErrorOccurred(\"Invalid credentials\"))\n                    }\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Authentication failed: ${e.message}\"))\n                } finally {\n                    dispatch(Msg.LoadingChanged(false))\n                }\n            }\n        }\n\n        private fun isValidEmail(email: String): Boolean {\n            return email.isNotBlank()\n        }\n\n        private fun isValidPassword(password: String): Boolean {\n            return password.length >= 2\n        }\n    }\n\n    private object ReducerImpl : Reducer<AuthenticationStore.State, Msg> {\n        override fun AuthenticationStore.State.reduce(msg: Msg): AuthenticationStore.State =\n            when (msg) {\n                is Msg.EmailUpdated -> copy(email = msg.email, isEmailValid = msg.isValid, error = null)\n                is Msg.PasswordUpdated -> copy(password = msg.password, isPasswordValid = msg.isValid, error = null)\n                is Msg.LoadingChanged -> copy(isLoading = msg.isLoading)\n                is Msg.ErrorOccurred -> copy(error = msg.error)\n                is Msg.ErrorCleared -> copy(error = null)\n                is Msg.AuthenticationSucceeded -> copy(\n                    isAuthenticated = true,\n                    isLoading = false,\n                    error = null\n                )\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":13,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface AuthenticationComponent {\n    val state: StateFlow<AuthenticationStore.State>\n\n    fun onIntent(intent: AuthenticationStore.Intent)\n\n    sealed interface Callback {\n        data object SuccessAuthentification : Callback\n    }\n}","chunkType":"INTERFACE","tokens":85,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/DefaultAuthenticationComponent.kt","className":null,"methodName":null,"startLine":16,"endLine":50,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultAuthenticationComponent(\n    private val authenticationStoreFactory: AuthenticationStoreFactory,\n    componentContext: ComponentContext,\n    private val callbackHandler: (Callback) -> Unit,\n) : AuthenticationComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        authenticationStoreFactory.create()\n    }\n    \n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n\n    init {\n        store.labels\n            .onEach { label ->\n                when (label) {\n                    is AuthenticationStore.Label.AuthenticationSuccessful ->\n                        callbackHandler.invoke(Callback.SuccessAuthentification)\n\n                    is AuthenticationStore.Label.ShowError -> {\n                        // Error handling could be implemented here if needed\n                        // For now, errors are handled through state\n                    }\n                }\n            }\n            .launchIn(componentScope)\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<AuthenticationStore.State> = store.stateFlow\n\n    override fun onIntent(intent: AuthenticationStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":355,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationStore.kt","className":null,"methodName":null,"startLine":5,"endLine":28,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.mvikotlin.core.store.Store\n\ninterface AuthenticationStore : Store<AuthenticationStore.Intent, AuthenticationStore.State, AuthenticationStore.Label> {\n\n    data class State(\n        val email: String = \"\",\n        val password: String = \"\",\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isEmailValid: Boolean = true,\n        val isPasswordValid: Boolean = true,\n        val isAuthenticated: Boolean = false\n    )\n\n    sealed class Intent {\n        data class UpdateEmail(val email: String) : Intent()\n        data class UpdatePassword(val password: String) : Intent()\n        object SignIn : Intent()\n        object ClearError : Intent()\n    }\n\n    sealed class Label {\n        object AuthenticationSuccessful : Label()\n        data class ShowError(val message: String) : Label()\n    }\n}","chunkType":"INTERFACE","tokens":228,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/tools/codeCheck/CodeCheckTools.kt","className":null,"methodName":null,"startLine":10,"endLine":31,"content":"package com.example.mindweaverstudio.ai.tools.codeCheck\n\nimport ai.koog.agents.core.tools.annotations.LLMDescription\nimport ai.koog.agents.core.tools.annotations.Tool\n\nclass CodeCheckTools(\n    private val dockerClient: DockerClient,\n) : ToolSet {\n\n    @Tool\n    @LLMDescription(\"Run and check the code snippet in a Docker container\")\n    suspend fun checkCodeSnippet(\n        @LLMDescription(\"The code snippet\")\n        code: String,\n        @LLMDescription(\"Code language\")\n        language: String,\n    ): String {\n        val result = withContext(Dispatchers.IO) {\n            dockerClient.checkCode(\n                code = code,\n                language = language,\n            )\n        }\n        return result\n    }\n\n}","chunkType":"CLASS","tokens":181,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.tools.codeCheck","imports":["ai.koog.agents.core.tools.annotations.LLMDescription","ai.koog.agents.core.tools.annotations.Tool","ai.koog.agents.core.tools.reflect.ToolSet"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/tools/pipelines/CodePipelineTools.kt","className":null,"methodName":null,"startLine":16,"endLine":87,"content":"package com.example.mindweaverstudio.ai.tools.pipelines\n\nimport ai.koog.agents.core.tools.annotations.LLMDescription\nimport ai.koog.agents.core.tools.annotations.Tool\n\nclass CodePipelineTools(\n    private val githubReleasePipeline: GithubReleasePipeline,\n    private val architecturePipeline: ArchitecturePipeline,\n    private val codeCreatorPipeline: CodeCreatorPipeline,\n    private val codeFixPipeline: CodeFixPipeline,\n    private val chatPipeline: ChatPipeline,\n\n    private val settings: Settings,\n) : ToolSet {\n\n    @Tool\n    @LLMDescription(\"Starts the pipeline for creating the application architecture\")\n    suspend fun runArchitecturePipeline(\n        @LLMDescription(\"Initial description of the task from the user\")\n        userRequest: String\n    ): String {\n        return withContext(Dispatchers.Default) {\n            architecturePipeline.run(userRequest)\n        }\n    }\n\n    @Tool\n    @LLMDescription(\"Starts the pipeline for creating code\")\n    suspend fun runCodeCreationPipeline(\n        @LLMDescription(\"Initial description of the task from the user\")\n        userRequest: String\n    ): String {\n        return withContext(Dispatchers.Default) {\n            codeCreatorPipeline.run(userRequest)\n        }\n    }\n\n    @Tool\n    @LLMDescription(\"Starts the pipeline for default chat with user\")\n    suspend fun runChatPipeline(\n        @LLMDescription(\"User message\")\n        userMessage: String\n    ): String {\n        return withContext(Dispatchers.Default) {\n            chatPipeline.run(userMessage)\n        }\n    }\n\n    @Tool\n    @LLMDescription(\"Starts the pipeline for fix code\")\n    suspend fun runCodeFixPipeline(\n        @LLMDescription(\"Initial description of the task from the user\")\n        userRequest: String\n    ): String {\n        return withContext(Dispatchers.Default) {\n            codeFixPipeline.run(userRequest)\n        }\n    }\n\n    @Tool\n    @LLMDescription(\"Starts the pipeline for create github release\")\n    suspend fun runGithubRelease(\n        @LLMDescription(\"Initial description of the task from the user\")\n        userRequest: String\n    ): String {\n        return withContext(Dispatchers.Default) {\n            val repoName = settings.getString(SettingsKey.GITHUB_REPO_NAME)\n            val repoOwner = settings.getString(SettingsKey.GITHUB_REPO_OWNER)\n\n            githubReleasePipeline.run(\n                input = userRequest,\n                repoName = repoName,\n                repoOwner = repoOwner,\n            )\n        }\n    }\n}","chunkType":"CLASS","tokens":622,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.tools.pipelines","imports":["ai.koog.agents.core.tools.annotations.LLMDescription","ai.koog.agents.core.tools.annotations.Tool","ai.koog.agents.core.tools.reflect.ToolSet"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/tools/github/GithubTools.kt","className":null,"methodName":null,"startLine":10,"endLine":49,"content":"package com.example.mindweaverstudio.ai.tools.github\n\nimport ai.koog.agents.core.tools.annotations.LLMDescription\nimport ai.koog.agents.core.tools.annotations.Tool\n\nclass GithubTools(\n    private val githubClient: GithubClient\n) : ToolSet {\n\n    @Tool(customName = \"generateReleaseInfo\")\n    @LLMDescription(\"Generate next release version and changelog based on commits since last release.\")\n    suspend fun generateReleaseInfo(\n        @LLMDescription(\"GitHub repo owner name\")\n        owner: String,\n        @LLMDescription(\"Repository name\")\n        repo: String,\n    ): String {\n        val (version, changelog) = githubClient.generateReleaseInfo(owner, repo)\n\n        return \"version: $version,\\nchangelog:$changelog\"\n    }\n\n    @Tool(customName = \"createNextGithubRelease\")\n    @LLMDescription(\"Create a new GitHub release. Input includes version (tag), and  changelog.\")\n    suspend fun createNextGithubRelease(\n        @LLMDescription(\"Release version or tag (e.g. v1.2.0)\")\n        version: String,\n        @LLMDescription(\"Release description or changelog (Markdown supported)\")\n        changelog: String,\n        @LLMDescription(\"GitHub username or organization\")\n        owner: String,\n        @LLMDescription(\"Repository name\")\n        repo: String,\n    ): String {\n        val result = githubClient.triggerReleaseWorkflow(\n            owner = owner,\n            repo = repo,\n            version = version,\n            changelog = changelog,\n        )\n\n        return \"Release $version created successfully! URL: ${result.url}\"\n    }\n\n}","chunkType":"CLASS","tokens":387,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.tools.github","imports":["ai.koog.agents.core.tools.annotations.LLMDescription","ai.koog.agents.core.tools.annotations.Tool","ai.koog.agents.core.tools.reflect.ToolSet"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/memory/github/GithubMemory.kt","className":null,"methodName":null,"startLine":7,"endLine":7,"content":"package com.example.mindweaverstudio.ai.memory.github\n\nimport ai.koog.agents.memory.model.Concept\nimport ai.koog.agents.memory.model.FactType\n\nval githubOwnerConcept = Concept(\"repo-owner\", \"Repository owner\", FactType.MULTIPLE)","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.memory.github","imports":["ai.koog.agents.memory.model.Concept","ai.koog.agents.memory.model.FactType","ai.koog.agents.memory.model.MemoryScope"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/memory/github/GithubMemory.kt","className":null,"methodName":null,"startLine":8,"endLine":8,"content":"package com.example.mindweaverstudio.ai.memory.github\n\nimport ai.koog.agents.memory.model.Concept\nimport ai.koog.agents.memory.model.FactType\n\nval githubRepoConcept = Concept(\"repo-name\", \"Repository name\", FactType.MULTIPLE)","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.memory.github","imports":["ai.koog.agents.memory.model.Concept","ai.koog.agents.memory.model.FactType","ai.koog.agents.memory.model.MemoryScope"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/memory/github/GithubMemory.kt","className":null,"methodName":null,"startLine":10,"endLine":10,"content":"package com.example.mindweaverstudio.ai.memory.github\n\nimport ai.koog.agents.memory.model.Concept\nimport ai.koog.agents.memory.model.FactType\n\nval githubAgentScope = MemoryScope.Agent(\"github-pipeline-agent\")","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.memory.github","imports":["ai.koog.agents.memory.model.Concept","ai.koog.agents.memory.model.FactType","ai.koog.agents.memory.model.MemoryScope"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/chat/ChatPipeline.kt","className":null,"methodName":null,"startLine":13,"endLine":44,"content":"package com.example.mindweaverstudio.ai.pipelines.chat\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass ChatPipeline(config: ApiConfiguration) {\n\n    private val chatPipelineStrategy = strategy<String, String>(CHAT_STRATEGY) {\n        val nodeRequirements by node<String, String> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        edge(nodeStart forwardTo nodeRequirements)\n        edge(nodeRequirements forwardTo nodeFinish)\n    }\n\n    private val promptExecutor = simpleOpenAIExecutor(config.openAiApiKey)\n    val agent = AIAgent(\n        id = CHAT_STRATEGY,\n        promptExecutor = promptExecutor,\n        strategy = chatPipelineStrategy,\n        llmModel = OpenAIModels.CostOptimized.GPT4oMini\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(input: String): String {\n        return agent.run(input)\n    }\n}","chunkType":"CLASS","tokens":283,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.chat","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/githubRelease/GithubReleasePipeline.kt","className":null,"methodName":null,"startLine":30,"endLine":30,"content":"package com.example.mindweaverstudio.ai.pipelines.githubRelease\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nconst val GITHUB_RELEASE_STRATEGY = \"GITHUB_RELEASE_STRATEGY\"","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.githubRelease","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/githubRelease/GithubReleasePipeline.kt","className":null,"methodName":null,"startLine":32,"endLine":116,"content":"package com.example.mindweaverstudio.ai.pipelines.githubRelease\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass GithubReleasePipeline(\n    private val configuration: ApiConfiguration,\n    private val tools: GithubTools,\n) {\n    private val model = OpenAIModels.CostOptimized.GPT4oMini\n    private val memoryProvider = LocalFileMemoryProvider(\n        config = LocalMemoryConfig(\"mind-weaver-studio\"),\n        storage = SimpleStorage(JVMFileSystemProvider.ReadWrite),\n        fs = JVMFileSystemProvider.ReadWrite,\n        root = JavaPath(\"\")\n    )\n\n    private val githubReleaseStrategy = strategy<String, String>(GITHUB_RELEASE_STRATEGY) {\n        val nodeLoadFacts by nodeLoadAllFactsFromMemory<String>(name = \"nodeLoadFacts\")\n\n        val releaseNotes by subgraphWithTask<String, String>(\n            tools = tools.asTools(),\n            llmParams = LLMParams().copy(\n                temperature = 0.3\n            ),\n        ) { releaseNotesAgentSystemPrompt }\n\n        val nodeRelease by subgraphWithTask<String, String>(\n            tools = tools.asTools(),\n            llmParams = LLMParams().copy(\n                temperature = 0.3\n            ),\n        ) { input -> \"Create github release with: $input\" }\n\n        edge(nodeStart forwardTo nodeLoadFacts)\n        edge(nodeLoadFacts forwardTo releaseNotes)\n        edge(releaseNotes forwardTo nodeRelease)\n        edge(nodeRelease forwardTo nodeFinish)\n    }\n\n    val agent = AIAgent(\n        promptExecutor = simpleOpenAIExecutor(configuration.openAiApiKey),\n        strategy = githubReleaseStrategy,\n        toolRegistry = ToolRegistry {\n            tools(tools)\n        },\n        llmModel = model,\n        temperature = 0.1\n    ) {\n        install(AgentMemory) {\n            memoryProvider = this@GithubReleasePipeline.memoryProvider\n            agentName = \"github-pipeline-agent\"\n            featureName = \"github-pipeline-feature\"\n            organizationName = \"radionov\"\n            productName = \"mind-weaver-studio\"\n        }\n        install(Tracing) {\n\n        }\n    }\n\n    suspend fun run(\n        input: String,\n        repoName: String,\n        repoOwner: String,\n    ): String {\n        saveGithubInfo(repoOwner, repoName)\n        return agent.run(input)\n    }\n\n    private suspend fun saveGithubInfo(repoOwner: String, repoName: String) {\n        val ownerConcept = githubOwnerConcept\n        val repoNameConcept = githubRepoConcept\n\n        val ownerFact = SingleFact(\n            concept = ownerConcept,\n            value = repoOwner,\n            timestamp = DefaultTimeProvider.getCurrentTimestamp()\n        )\n\n        val repoFact = SingleFact(\n            concept = repoNameConcept,\n            value = repoName,\n            timestamp = DefaultTimeProvider.getCurrentTimestamp()\n        )\n\n        memoryProvider.save(ownerFact, ProjectContext, githubAgentScope)\n        memoryProvider.save(repoFact, ProjectContext, githubAgentScope)\n    }\n}","chunkType":"CLASS","tokens":742,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.githubRelease","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeReview/CodeReviewPipeline.kt","className":null,"methodName":null,"startLine":12,"endLine":12,"content":"package com.example.mindweaverstudio.ai.pipelines.codeReview\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nconst val CODE_REVIEW_STRATEGY = \"CODE_REVIEW_STRATEGY\"","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeReview","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeReview/CodeReviewPipeline.kt","className":null,"methodName":null,"startLine":14,"endLine":58,"content":"package com.example.mindweaverstudio.ai.pipelines.codeReview\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass CodeReviewPipeline(\n    config: ApiConfiguration\n) {\n\n    private val codeReviewStrategy = strategy<String, String>(CODE_REVIEW_STRATEGY) {\n        var ragChunksText = \"\"\n        val file = File(\"truly_streaming_output_chunks.json\")\n        if (file.exists()) {\n            ragChunksText = file.readText()\n        } else {\n            println(\"Chunks file not found: ${file.absolutePath}\")\n        }\n        val userMessage = ragChunksText\n\n        val nodeReview by node<String, String> {\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(codeReviewSystemPrompt)\n                    user(userMessage)\n                }\n\n                \"\"\n            }\n        }\n\n        codeReviewSystemPrompt\n\n        edge(nodeStart forwardTo nodeReview)\n        edge(nodeReview forwardTo nodeFinish)\n    }\n\n    private val promptExecutor = simpleOpenAIExecutor(config.openAiApiKey)\n    val agent = AIAgent(\n        promptExecutor = promptExecutor,\n        strategy = codeReviewStrategy,\n        llmModel = OpenAIModels.CostOptimized.O3Mini\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(input: String): String {\n        return agent.run(input)\n    }\n}","chunkType":"CLASS","tokens":352,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeReview","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeCreator/CodeCreatorPipeline.kt","className":null,"methodName":null,"startLine":17,"endLine":17,"content":"package com.example.mindweaverstudio.ai.pipelines.codeCreator\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nconst val CODE_CREATOR_STRATEGY = \"CODE_CREATOR_STRATEGY\"","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeCreator","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeCreator/CodeCreatorPipeline.kt","className":null,"methodName":null,"startLine":19,"endLine":59,"content":"package com.example.mindweaverstudio.ai.pipelines.codeCreator\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass CodeCreatorPipeline(\n    private val codeCheckTools: CodeCheckTools,\n    config: ApiConfiguration,\n) {\n    private val llmModel = OpenAIModels.CostOptimized.O3Mini\n    private val codeCreatorPipelineStrategy = strategy<String, String>(CODE_CREATOR_STRATEGY) {\n        val nodeRequirements by node<String, String> { input: String ->\n            llm.writeSession {\n                model = llmModel\n                updatePrompt {\n                    system(codeCreatorSystemPrompt())\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        val codeCheck by subgraphWithTask<String, String>(\n            tools = ToolRegistry { tools(codeCheckTools) }.tools,\n            llmParams = LLMParams().copy(temperature = 0.3),\n            llmModel = llmModel,\n        ) { releaseNotesAgentSystemPrompt }\n\n        edge(nodeStart forwardTo nodeRequirements)\n        edge(nodeRequirements forwardTo codeCheck)\n        edge(nodeRequirements forwardTo nodeFinish)\n    }\n\n    val agent = AIAgent(\n        promptExecutor = simpleOpenAIExecutor(config.openAiApiKey),\n        strategy = codeCreatorPipelineStrategy,\n        llmModel = OpenAIModels.CostOptimized.O3Mini\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(input: String): String {\n        return agent.run(input)\n    }\n}","chunkType":"CLASS","tokens":387,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeCreator","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeCreator/prompts.kt","className":null,"methodName":"codeCreatorSystemPrompt","startLine":5,"endLine":22,"content":"package com.example.mindweaverstudio.ai.pipelines.codeCreator\n\nimport com.example.mindweaverstudio.data.profile.PersonalizationConfig\n\nfun codeCreatorSystemPrompt(): String {\n    val config = PersonalizationConfig.loadJsonConfig()\n\n    val prompt =  \"\"\"\n        You are a senior developer. \n        You must respond only with complete, working code.\n        Absolutely no explanations, no comments, no Markdown, no formatting symbols, no text before or after the code. \n        Only raw code. Your output must compile and be self-sufficient, including imports if needed. \n        Any deviation is forbidden. Always produce code as short and correct as possible. \n        Example: if asked to create a factorial function, your output must be only the code for that function, nothing else.\n        \n        Study the user configuration and tailor your response to the requirements described there\n        User configuration: $config\n\n    \"\"\".trimIndent()\n\n    return prompt\n}","chunkType":"FUNCTION","tokens":243,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeCreator","imports":["com.example.mindweaverstudio.data.profile.PersonalizationConfig"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/architecture/ArchitecturePipeline.kt","className":null,"methodName":null,"startLine":11,"endLine":11,"content":"package com.example.mindweaverstudio.ai.pipelines.architecture\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nconst val ARCHITECTURE_STRATEGY = \"ARCHITECTURE_STRATEGY\"","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.architecture","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/architecture/ArchitecturePipeline.kt","className":null,"methodName":null,"startLine":13,"endLine":83,"content":"package com.example.mindweaverstudio.ai.pipelines.architecture\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass ArchitecturePipeline(config: ApiConfiguration) {\n\n    private val architectureStrategy = strategy<String, String>(ARCHITECTURE_STRATEGY) {\n        val nodeRequirements by node<String, String> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(nodeRequirementsSystemPrompt)\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        val nodeHighLevel by node<String, String> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(nodeHighLevelSystemPrompt)\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        val nodeDetailed by node<String, String> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(nodeDetailedSystemPrompt)\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        val nodeValidation by node<String, String> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(nodeValidationSystemPrompt)\n                    user(input)\n                }\n                val response = requestLLMWithoutTools()\n                response.content\n            }\n        }\n\n        edge(nodeStart forwardTo nodeRequirements)\n        edge(nodeRequirements forwardTo nodeHighLevel)\n        edge(nodeHighLevel forwardTo nodeDetailed)\n        edge(nodeDetailed forwardTo nodeValidation)\n        edge(nodeValidation forwardTo nodeFinish)\n    }\n\n\n    private val agent = AIAgent(\n        promptExecutor = simpleOpenAIExecutor(config.openAiApiKey),\n        strategy = architectureStrategy,\n        llmModel = OpenAIModels.Chat.GPT4o,\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(input: String): String {\n        return agent.run(input)\n    }\n}","chunkType":"CLASS","tokens":627,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.architecture","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/architecture/prompts.kt","className":null,"methodName":null,"startLine":248,"endLine":250,"content":"package com.example.mindweaverstudio.ai.pipelines.architecture\n\n                    class MainViewModel : ViewModel() {\n                      // Example implementation\n                    }","chunkType":"CLASS","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.architecture","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/architecture/prompts.kt","className":null,"methodName":null,"startLine":255,"endLine":308,"content":"package com.example.mindweaverstudio.ai.pipelines.architecture\n\n                    data class User(val id: String, val name: String)\n            - name: \"Module name (e.g., 'Data Layer')\"\n              description: \"Purpose and responsibilities\"\n              components: []\n          api_endpoints:\n            - path: \"/endpoint/path\"\n              method: \"GET or POST\"\n              request: \"Request structure (e.g., JSON schema)\"\n              response: \"Response structure (e.g., JSON schema)\"\n          interactions:\n            - description: \"Detailed interaction (e.g., 'ViewModel fetches data from Repository')\"\n              source: \"Component name\"\n              target: \"Component name\"\n          tech_stack:\n            - \"Technology 1 (e.g., 'Kotlin Coroutines for async')\"\n            - \"Technology 2 (e.g., 'Room for persistence')\"\n          constraints_addressed:\n            - \"Constraint 1 (e.g., 'Use open-source libraries')\"\n          assumptions:\n            - \"Assumption 1 (e.g., 'Assumes cloud-based backend')\"\n          risks:\n            - \"Risk 1 (e.g., 'Complex queries may impact performance')\"\n        ```\n    \n        - If a section is irrelevant or empty, omit it or use an empty list [].\n        - Keep descriptions concise yet detailed; aim for clarity and brevity.\n        - Ensure YAML is valid and indented properly.\n        - Include pseudo-code as strings under `code_snippet` fields, using idiomatic Kotlin syntax.\n    \n      guidelines:\n        - Objectivity: Base the design strictly on the input YAML. Do not invent requirements or deviate from the high-level architecture.\n        - Completeness: Ensure the detailed design covers all modules, components, and interactions specified in the input.\n        - Kotlin Best Practices: Use idiomatic Kotlin (e.g., suspend functions, Flow for reactive data, avoid nulls with Elvis operator, sealed interfaces for state).\n        - Modularity: Ensure components are loosely coupled and reusable.\n        - Error Handling: If input is invalid or incomplete, output a YAML with an \"error\" section explaining briefly.\n        - No External Tools: Process based on input alone; no web searches or code execution.\n        - No Clarifications: Do not generate clarifying questions. Use assumptions from the input or make reasonable ones, documenting them explicitly.\n        - Iterative Mindset: Your output feeds the Validator & Optimizer Agent, so ensure it is robust, complete, and extensible.\n        - Professional Tone: Ensure output is neutral and technical.\n    \n      notes:\n        - Your response must be purely the YAML output. Do not include any requests for clarification or additional text outside the YAML.\n\"\"\".trimIndent()\n\nval nodeValidationSystemPrompt = \"\"\"\n    Role: Validator & Optimizer Agent\n    Description: You are the Validator & Optimizer Agent, the final agent in a multi-agent pipeline designed to generate application architectures for Kotlin-based applications. Your role is to validate the detailed design provided by the Detailed Designer Agent, ensuring it is consistent, complete, and aligned with the original requirements and high-level architecture. You also optimize the design by identifying improvements, addressing risks, and suggesting alternatives. Your output is a comprehensive, human-readable text report that serves as the final architectural specification, ready to be presented to the user for implementation.\n    Core Responsibilities: Analyze Input: Process the YAML detailed design document, including architecture patterns, modules, components, API endpoints, interactions, tech stack, constraints, assumptions, and risks. Validate Design: Check consistency with the high-level architecture and original requirements. Ensure all functional and non-functional requirements (e.g., performance, security, scalability) are addressed. Verify Kotlin best practices (e.g., use of coroutines, type safety, null safety). Identify logical errors, missing components, or potential bottlenecks. Optimize Design: Suggest improvements (e.g., replace blocking calls with suspend functions, optimize data flows with Kotlin Flow). Propose alternative technologies or approaches if they better meet requirements (e.g., GraphQL instead of REST for complex queries). Mitigate identified risks (e.g., add caching to address performance risks). Simulate Scenarios: Mentally evaluate the design against common scenarios (e.g., high load, failure cases) to ensure robustness. Structure Output: Create a human-readable text report that clearly summarizes validation results, optimized design, and recommendations, formatted for easy understanding by the user.\n    Processing Steps: Parse Input: Read and validate the YAML detailed design document from the Detailed Designer Agent. Cross-Check Requirements: Ensure the design aligns with the original requirements (functional, non-functional, constraints) and high-level architecture. Validate Components: Check each module, component, and interaction for correctness, completeness, and adherence to Kotlin idioms. Identify Issues: Flag inconsistencies, potential bottlenecks, or unaddressed risks. Optimize Design: Propose specific changes (e.g., adjust coroutine scopes, simplify data models) and document alternatives. Simulate Scenarios: Evaluate the design against high-load, failure, or edge-case scenarios, noting potential issues and mitigations. Format Output: Output a human-readable text report with clear sections, including validation results, optimized design, and recommendations.\n    Input Format: The input is a YAML document from the Detailed Designer Agent with the following structure: detailed_design: architecture_pattern: Selected pattern (e.g., Clean Architecture) modules: name: Module name description: Purpose and responsibilities components: name: Component name type: Class or Interface description: Purpose and responsibilities code_snippet: Kotlin pseudo-code api_endpoints: path: /endpoint/path method: GET or POST request: Request structure response: Response structure interactions: [] tech_stack: [] constraints_addressed: [] assumptions: [] risks: []\n    Output Format: Respond only with a human-readable text report. Do not include any YAML, additional explanations, or chit-chat outside the report. Use the following structure for the text report:\n    Final Architecture Report\n    Validation Results Status: Valid or Invalid Issues: Issue 1 description, e.g., Missing error handling in Repository. Severity: Low/Medium/High. Recommendation: Proposed fix. Additional issues as needed. Compliance: Requirement 1, e.g., Functional: User authentication. Status: Met or Not Met. Details: Explanation. Requirement 2, e.g., Non-functional: Scalability for 10k users. Status: Met or Not Met. Details: Explanation.\n    Optimized Architecture Architecture Pattern: e.g., Clean Architecture Modules: Module Name, e.g., UI Layer. Description: Purpose and responsibilities. Components: Component Name, e.g., MainViewModel: Type, e.g., Class. Description: Purpose. Pseudo-Code: class MainViewModel : ViewModel() { // Example implementation }. Additional components as needed. Additional modules as needed: Description: Purpose. Components: List components. API Endpoints: Path, e.g., /endpoint/path (Method, e.g., GET). Request: Request structure. Response: Response structure. Interactions: Description, e.g., ViewModel fetches data from Repository. Source: Component name. Target: Component name. Tech Stack: Technology 1, e.g., Kotlin Coroutines for async. Additional technologies. Diagram: @startuml [Module 1] --> [Module 2] @enduml","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.architecture","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeFix/CodeFixPipeline.kt","className":null,"methodName":null,"startLine":14,"endLine":70,"content":"package com.example.mindweaverstudio.ai.pipelines.codeFix\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.dsl.builder.forwardTo\n\nclass CodeFixerResult(\n    sourceCode: String,\n    filepath: String,\n    newCode: String,\n)\n\nclass CodeFixPipeline(\n    config: ApiConfiguration\n) {\n\n    private val codeFixPipelineStrategy = strategy<String, String>(CODE_FIX_STRATEGY) {\n\n        val nodeFix by node<String, CodeFixerResult> { input: String ->\n            llm.writeSession {\n                model = OpenAIModels.CostOptimized.O3Mini\n                updatePrompt {\n                    system(codeFixSystemPrompt)\n                    user(input)\n                }\n\n                val message = requestLLMWithoutTools()\n\n                CodeFixerResult(\n                    sourceCode = \"searchResult.sourceCode\",\n                    filepath = \"searchResult.filePath\",\n                    newCode = message.content\n                )\n            }\n        }\n\n        val nodeHighLevel by node<CodeFixerResult, String> { input: CodeFixerResult ->\n            val result = CodeReplacerUtils.replaceCodeInFile(\n                filePath = \"\",\n                originalCode = \"\",\n                newCode = \"\",\n            )\n            result\n        }\n\n        edge(nodeStart forwardTo nodeFix)\n        edge(nodeFix forwardTo nodeHighLevel)\n        edge(nodeHighLevel forwardTo nodeFinish)\n    }\n\n    private val promptExecutor = simpleOpenAIExecutor(config.openAiApiKey)\n    val agent = AIAgent(\n        promptExecutor = promptExecutor,\n        strategy = codeFixPipelineStrategy,\n        llmModel = OpenAIModels.CostOptimized.O3Mini\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(input: String): String {\n        return agent.run(input)\n    }\n}","chunkType":"CLASS","tokens":442,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeFix","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.dsl.builder.forwardTo","ai.koog.agents.core.dsl.builder.strategy"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeFix/prompts.kt","className":null,"methodName":"sum","startLine":13,"endLine":15,"content":"package com.example.mindweaverstudio.ai.pipelines.codeFix\n\n        fun sum(a: Int, b: Int): Int {\n            return a + b\n        }","chunkType":"FUNCTION","tokens":33,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeFix","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/pipelines/codeFix/prompts.kt","className":null,"methodName":"sum","startLine":19,"endLine":21,"content":"package com.example.mindweaverstudio.ai.pipelines.codeFix\n\n        fun sum(a: Int, b: Int): Int {\n            return a + b\n        }","chunkType":"FUNCTION","tokens":33,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.pipelines.codeFix","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/orchestrator/code/CodeOrchestrator.kt","className":null,"methodName":null,"startLine":12,"endLine":12,"content":"package com.example.mindweaverstudio.ai.orchestrator.code\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.tools.ToolRegistry\n\nconst val codeOrchestratorPrompt = \"You are a pipeline orchestrator.Your task is to analyze the user message and decide which of the available pipelines should handle this request.\"","chunkType":"PROPERTY","tokens":82,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.orchestrator.code","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.tools.ToolRegistry","ai.koog.agents.core.tools.reflect.tools"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/orchestrator/code/CodeOrchestrator.kt","className":null,"methodName":null,"startLine":13,"endLine":13,"content":"package com.example.mindweaverstudio.ai.orchestrator.code\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.tools.ToolRegistry\n\nconst val CODE_ORCHESTRATOR_STRATEGY = \"code_orchestrator_strategy\"","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.orchestrator.code","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.tools.ToolRegistry","ai.koog.agents.core.tools.reflect.tools"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ai/orchestrator/code/CodeOrchestrator.kt","className":null,"methodName":null,"startLine":15,"endLine":32,"content":"package com.example.mindweaverstudio.ai.orchestrator.code\n\nimport ai.koog.agents.core.agent.AIAgent\nimport ai.koog.agents.core.tools.ToolRegistry\n\nclass CodeOrchestrator(\n    private val tools: CodePipelineTools,\n    configuration: ApiConfiguration,\n) {\n    private val orchestratorAgent = AIAgent(\n        id = CODE_ORCHESTRATOR_STRATEGY,\n        promptExecutor = simpleOpenAIExecutor(configuration.openAiApiKey),\n        llmModel = OpenAIModels.CostOptimized.GPT4oMini,\n        toolRegistry = ToolRegistry { tools(tools) },\n        systemPrompt = codeOrchestratorPrompt,\n    ) {\n        install(Tracing)\n    }\n\n    suspend fun run(userInput: String): String {\n        return orchestratorAgent.run(userInput)\n    }\n}","chunkType":"CLASS","tokens":179,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ai.orchestrator.code","imports":["ai.koog.agents.core.agent.AIAgent","ai.koog.agents.core.tools.ToolRegistry","ai.koog.agents.core.tools.reflect.tools"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/clients/DockerClient.kt","className":null,"methodName":null,"startLine":17,"endLine":91,"content":"package com.example.mindweaverstudio.data.clients\n\nimport com.github.dockerjava.api.DockerClient\nimport com.github.dockerjava.api.async.ResultCallback\n\nclass DockerClient {\n    private val dockerClient: DockerClient = DockerClientBuilder.getInstance().build()\n\n    fun checkCode(code: String, language: String): String {\n        val tempDir: Path = createTempDirectory(\"code-check-\")\n        val codeFile: File = when (language.lowercase()) {\n            \"python\" -> tempDir.resolve(\"script.py\").toFile()\n            \"java\" -> tempDir.resolve(\"Main.java\").toFile()\n            \"kotlin\" -> tempDir.resolve(\"Main.kt\").toFile()\n            else -> throw IllegalArgumentException(\"Unsupported language: $language\")\n        }\n        codeFile.writeText(code)\n\n        val (image, cmd) = when (language.lowercase()) {\n            \"python\" -> \"python:3-slim\" to listOf(\"python\", \"/code/script.py\")\n            \"java\" -> \"openjdk:17-slim\" to listOf(\"javac\", \"/code/Main.java\", \"&&\", \"java\", \"-cp\", \"/code\", \"Main\")\n            \"kotlin\" -> \"zenika/kotlin\" to listOf(\n                \"kotlinc\", \"/code/Main.kt\", \"-include-runtime\", \"-d\", \"/code/Main.jar\", \"&&\", \"java\", \"-jar\", \"/code/Main.jar\"\n            )\n            else -> throw IllegalArgumentException(\"Unsupported language\")\n        }\n\n        val imageStream = File(image).inputStream()\n        dockerClient.loadImageCmd(imageStream)?.exec()\n\n        val createCmd: CreateContainerCmd = dockerClient.createContainerCmd(image)\n            .withHostConfig(\n                HostConfig.newHostConfig()\n                    .withBinds(fromPrimitive(arrayOf(\"$tempDir:/code\")))\n                    .withCpuQuota(100000L)\n                    .withMemory(256L * 1024 * 1024)\n            )\n            .withCmd(\"/bin/sh\", \"-c\", cmd.joinToString(\" \"))\n\n        val containerId = createCmd.exec().id\n\n        try {\n            dockerClient.startContainerCmd(containerId).exec()\n\n            val exitCode = AtomicInteger(-1)\n            val callback = object : ResultCallback.Adapter<WaitResponse>() {\n                override fun onNext(response: WaitResponse) {\n                    exitCode.set(response.statusCode)\n                    super.onNext(response)\n                }\n            }\n\n            val waitResult = dockerClient.waitContainerCmd(containerId)\n                .exec(callback)\n                .awaitCompletion(30, TimeUnit.SECONDS)\n\n            if (!waitResult) {\n                dockerClient.killContainerCmd(containerId).exec()\n                return \"Execution timed out after 30 seconds\"\n            }\n\n            val logs = dockerClient.logContainerCmd(containerId)\n                .withStdOut(true)\n                .withStdErr(true)\n                .exec(ResultCallback.Adapter())\n                .awaitCompletion()\n                .toString()\n\n            val status = exitCode.get()\n            return if (status == 0) {\n                logs\n            } else {\n                \"Execution failed with exit code $status\\nLogs: $logs\"\n            }\n        } finally {\n            dockerClient.removeContainerCmd(containerId).withForce(true).exec()\n            Files.walk(tempDir).sorted(Comparator.reverseOrder()).forEach { Files.delete(it) }\n        }\n    }\n}","chunkType":"CLASS","tokens":806,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.clients","imports":["com.github.dockerjava.api.DockerClient","com.github.dockerjava.api.async.ResultCallback","com.github.dockerjava.api.command.CreateContainerCmd"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/clients/GithubClient.kt","className":null,"methodName":null,"startLine":32,"endLine":192,"content":"package com.example.mindweaverstudio.data.clients\n\nimport com.example.mindweaverstudio.data.models.mcp.github.Commit\nimport com.example.mindweaverstudio.data.models.mcp.github.CreateReleaseResult\n\nclass GithubClient(\n    private val config: ApiConfiguration,\n) {\n\n    private val httpClient = createHttpClient()\n\n    private fun createHttpClient() = HttpClient(CIO) {\n        install(ContentNegotiation) {\n            json(\n                Json {\n                    ignoreUnknownKeys = true\n                    prettyPrint = true\n                }\n            )\n        }\n\n        install(Logging) {\n            level = LogLevel.INFO\n        }\n\n        defaultRequest {\n            url {\n                protocol = URLProtocol.Companion.HTTPS\n                host = \"api.github.com\"\n            }\n\n            val token = config.githubApiKey\n            if (token.isNotEmpty()) {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            header(\"Accept\", \"application/vnd.github+json\")\n        }\n    }\n\n\n\n    suspend fun getCommits(owner: String, repo: String): List<String> {\n        val uri = \"/repos/$owner/$repo/commits\"\n        val commits = httpClient.get(uri).body<List<Commit>>()\n        return commits.map { commit ->\n            \"\"\"\n            SHA: ${commit.sha}\n            Message: ${commit.commit.message}\n            Author: ${commit.commit.author.name} (${commit.commit.author.email})\n            Date: ${commit.commit.author.date}\n        \"\"\".trimIndent()\n        }\n    }\n\n    suspend fun generateReleaseInfo(\n        owner: String,\n        repo: String,\n    ): Pair<String, String> {\n        // 1. Узнаем последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer ${config.githubApiKey}\")\n        }\n\n        val lastTag = if (lastReleaseResp.status.isSuccess()) {\n            val json = Json.Default.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n        } else {\n            \"v0.0.0\"\n        }\n\n        // 2. Сравнение изменений с main\n        val commitMessages = getCommitsSinceLastRelease(\n            owner = owner,\n            repo = repo,\n            token = config.githubApiKey,\n        )\n\n        // 3. Генерация версии (patch bump)\n        val versionParts = lastTag.removePrefix(\"v\").split(\".\").map { it.toInt() }.toMutableList()\n        versionParts[2] += 1 // patch bump\n        val newVersion = \"v${versionParts.joinToString(\".\")}\"\n\n        // 4. Генерация changelog\n        val changelog = commitMessages.joinToString(\"\\n\") { \"- $it\" }\n\n        return newVersion to changelog\n    }\n\n    suspend fun getCommitsSinceLastRelease(\n        owner: String,\n        repo: String,\n        token: String\n    ): List<String> {\n        // 1. Пытаемся найти последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer $token\")\n        }\n\n        return if (lastReleaseResp.status.isSuccess()) {\n            // Есть релиз → берём diff по тегу\n            val json = Json.Default.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            val lastTag = json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n\n            val compareResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/compare/$lastTag...main\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.Default.parseToJsonElement(compareResp.bodyAsText()).jsonObject\n            val commits = commitsJson[\"commits\"]?.jsonArray ?: JsonArray(emptyList())\n\n            commits.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        } else {\n            // Релизов нет → берём ВСЕ коммиты в main\n            val commitsResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/commits\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.Default.parseToJsonElement(commitsResp.bodyAsText()).jsonArray\n            commitsJson.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        }\n    }\n\n    suspend fun triggerReleaseWorkflow(\n        owner: String,\n        repo: String,\n        version: String,\n        changelog: String,\n    ): CreateReleaseResult {\n        return try {\n            val response = httpClient.post(\"https://api.github.com/repos/$owner/$repo/actions/workflows/release.yml/dispatches\") {\n                header(\"Authorization\", \"Bearer ${config.githubApiKey}\")\n                header(\"Accept\", \"application/vnd.github+json\")\n                contentType(ContentType.Application.Json)\n                setBody(\n                    buildJsonObject {\n                        put(\"ref\", \"main\")\n                        putJsonObject(\"inputs\") {\n                            put(\"version\", version)\n                            put(\"changelog\", changelog)\n                        }\n                    }\n                )\n            }\n\n            if (response.status.value == 204) {\n                CreateReleaseResult(\n                    success = true,\n                    url = \"Release version $version successfully registered, .dmg file is currently being created.\"\n                )\n            } else {\n                CreateReleaseResult(\n                    success = false,\n                    errorMessage = \"GitHub API returned status ${response.status.value}: ${response.bodyAsText()}\"\n                )\n            }\n        } catch (e: Exception) {\n            CreateReleaseResult(success = false, errorMessage = e.message)\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.clients","imports":["com.example.mindweaverstudio.data.models.mcp.github.Commit","com.example.mindweaverstudio.data.models.mcp.github.CreateReleaseResult","com.example.mindweaverstudio.data.utils.config.ApiConfiguration"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/settings/Settings.kt","className":null,"methodName":null,"startLine":46,"endLine":51,"content":"package com.example.mindweaverstudio.data.settings\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\n\nprivate data class StoredEntry(val type: String, val value: String)\n\nprivate val mapSerializer: KSerializer<Map<String, StoredEntry>> =\n    MapSerializer(String.serializer(), StoredEntry.serializer())\n\nprivate val json = Json { prettyPrint = false; encodeDefaults = true }","chunkType":"CLASS","tokens":101,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.settings","imports":["kotlinx.coroutines.CoroutineScope","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.flow.Flow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/settings/Settings.kt","className":null,"methodName":null,"startLine":56,"endLine":186,"content":"package com.example.mindweaverstudio.data.settings\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\n\nclass Settings(\n    private val file: File,\n    private val ioScope: CoroutineScope = CoroutineScope(Dispatchers.IO)\n) {\n    private val mutex = Mutex()\n\n    // in-memory cache\n    private val backing: MutableMap<String, StoredEntry> = mutableMapOf()\n\n    // change emitter: emits keys that changed\n    private val _changes = MutableSharedFlow<String>(extraBufferCapacity = 64)\n    val changes: Flow<String> get() = _changes\n\n    init {\n        if (!file.exists()) {\n            file.parentFile?.mkdirs()\n        } else {\n            try {\n                val text = file.readText()\n                if (text.isNotEmpty()) {\n                    val map = json.decodeFromString(mapSerializer, text)\n                    backing.putAll(map)\n                }\n            } catch (e: Exception) {\n                // If file corrupted, ignore - start empty. You may want to log.\n            }\n        }\n    }\n\n    // ----------------------------\n    // Basic operations\n    // ----------------------------\n    suspend fun clear() {\n        mutex.withLock {\n            backing.clear()\n            persistSync()\n            _changes.tryEmit(ALL_KEYS)\n        }\n    }\n\n    suspend fun remove(key: SettingsKey) {\n        mutex.withLock {\n            val removed = backing.remove(key.value)\n            if (removed != null) {\n                persistSync()\n                _changes.tryEmit(key.value)\n            }\n        }\n    }\n\n    suspend fun hasKey(key: String): Boolean = mutex.withLock { backing.containsKey(key) }\n\n    // String\n    suspend fun putString(key: SettingsKey, value: String) = putTyped(key.value, \"string\", value)\n    suspend fun getString(key: SettingsKey, default: String = \"\"): String = getTyped(key.value, \"string\")?.value ?: default\n    suspend fun getStringOrNull(key: String): String? = getTyped(key, \"string\")?.value\n\n    // Int\n    suspend fun putInt(key: String, value: Int) = putTyped(key, \"int\", value.toString())\n    suspend fun getInt(key: String, default: Int): Int = getTyped(key, \"int\")?.value?.toIntOrNull() ?: default\n\n    // Long\n    suspend fun putLong(key: String, value: Long) = putTyped(key, \"long\", value.toString())\n    suspend fun getLong(key: String, default: Long): Long = getTyped(key, \"long\")?.value?.toLongOrNull() ?: default\n\n    // Float\n    suspend fun putFloat(key: String, value: Float) = putTyped(key, \"float\", value.toString())\n    suspend fun getFloat(key: String, default: Float): Float = getTyped(key, \"float\")?.value?.toFloatOrNull() ?: default\n\n    // Boolean\n    suspend fun putBoolean(key: String, value: Boolean) = putTyped(key, \"boolean\", value.toString())\n    suspend fun getBoolean(key: String, default: Boolean): Boolean = getTyped(key, \"boolean\")?.value?.toBoolean() ?: default\n\n    // Observe as Flow<String> emitting the value serialized as string. You can map/convert in callers.\n    fun observe(key: String): Flow<String?> =\n        changes.filter { it == key || it == ALL_KEYS }.map {\n            // read current value on collector side - but we need to avoid suspending here, so do IO in coroutine\n            // To keep API simple, the user can call getX from a coroutine; however we also allow reading current value synchronously from cache\n            synchronized(backing) {\n                backing[key]?.value\n            }\n        }\n\n    // Helper for convenience: observe typed values\n    fun observeString(key: String, default: String): Flow<String> =\n        observe(key).map { it ?: default }\n\n    // ----------------------------\n    // Internal helpers\n    // ----------------------------\n    private suspend fun putTyped(key: String, type: String, value: String) {\n        mutex.withLock {\n            backing[key] = StoredEntry(type, value)\n            persistSync()\n            _changes.tryEmit(key)\n        }\n    }\n\n    private suspend fun getTyped(key: String, expectedType: String): StoredEntry? = mutex.withLock {\n        val entry = backing[key]\n        if (entry == null) return null\n        // If types mismatch, we still return value as string for backward compatibility, but you can enforce type here.\n        entry\n    }\n\n    private fun persistSync() {\n        try {\n            val tmp = File(file.parentFile, \"${file.name}.tmp\")\n            val serialized = json.encodeToString(mapSerializer, backing)\n            tmp.writeText(serialized)\n            Files.move(tmp.toPath(), file.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)\n        } catch (e: Exception) {\n            // best-effort: ignore or log\n        }\n    }\n\n    companion object Companion {\n        private const val ALL_KEYS = \"__ALL_KEYS__\"\n\n        /**\n         * Convenience factory that creates DesktopSettings in the platform's application data directory.\n         * Example path: ~/.config/<appId>/settings.json\n         */\n        fun createDefault(appId: String, fileName: String = \"settings.json\"): Settings {\n            val home = System.getProperty(\"user.home\") ?: \".\"\n            val configDir = File(home, \".config/$appId\")\n            val file = File(configDir, fileName)\n            return Settings(file)\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.settings","imports":["kotlinx.coroutines.CoroutineScope","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.flow.Flow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/settings/SettingsKey.kt","className":null,"methodName":null,"startLine":3,"endLine":7,"content":"package com.example.mindweaverstudio.data.settings\n\nenum class SettingsKey(val value: String) {\n    TOKEN_KEY(\"auth_token\"),\n    GITHUB_REPO_NAME(\"github_repo_name\"),\n    GITHUB_REPO_OWNER(\"github_repo_owner\")\n}","chunkType":"CLASS","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.settings","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/memory/MemoryProvider.kt","className":null,"methodName":null,"startLine":13,"endLine":36,"content":"package com.example.mindweaverstudio.data.memory\n\nimport ai.koog.agents.memory.providers.AgentMemoryProvider\nimport ai.koog.agents.memory.providers.LocalFileMemoryProvider\n\nclass MemoryProvider(\n    private val configuration: ApiConfiguration\n) {\n\n    private val secureStorage = EncryptedStorage(\n        fs = JVMFileSystemProvider.ReadWrite,\n        encryption = Aes256GCMEncryptor(\"my-secret-key\")\n    )\n    private val appDataDir: Path = Paths.get(System.getProperty(\"user.home\"))\n        .resolve(\".mindweaver\")\n        .resolve(\"memory\")\n        .also { it.toFile().mkdirs() }\n\n    private val provider = LocalFileMemoryProvider(\n        config = LocalMemoryConfig(\"mind-weaver-studio\"),\n        storage = secureStorage,\n        fs = JVMFileSystemProvider.ReadWrite,\n        root = appDataDir\n    )\n\n    fun getProvider(): AgentMemoryProvider {\n        return provider\n    }\n}","chunkType":"CLASS","tokens":220,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.memory","imports":["ai.koog.agents.memory.providers.AgentMemoryProvider","ai.koog.agents.memory.providers.LocalFileMemoryProvider","ai.koog.agents.memory.providers.LocalMemoryConfig"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/auth/AuthManager.kt","className":null,"methodName":null,"startLine":11,"endLine":57,"content":"package com.example.mindweaverstudio.data.auth\n\nimport com.auth0.jwt.JWT\nimport com.auth0.jwt.JWTVerifier\n\nclass AuthManager(\n    private val settings: Settings\n) {\n    private val secret = \"your-secure-secret-key\"\n    private val algorithm = Algorithm.HMAC256(secret)\n    private val verifier: JWTVerifier = JWT.require(algorithm).build()\n\n    private val users = mutableMapOf(\n        \"admin\" to (\"adminpass\" to \"ADMIN\"),\n        \"user\" to (\"userpass\" to \"USER\")\n    )\n\n    suspend fun generateToken(username: String, password: String): String? {\n        val userData = users[username]\n        if (userData != null && password == userData.first) {\n            val role = userData.second\n            return JWT.create()\n                .withSubject(username)\n                .withClaim(\"role\", role)\n                .withExpiresAt(Date(System.currentTimeMillis() + 86_400_000))\n                .sign(algorithm)\n                .also { saveToken(it) }\n        }\n        return null\n    }\n\n    fun validateToken(token: String): Map<String, Any>? {\n        return try {\n            val decoded = verifier.verify(token)\n            mapOf(\n                \"username\" to decoded.subject,\n                \"role\" to decoded.getClaim(\"role\").asString()\n            )\n        } catch (e: JWTVerificationException) {\n            null\n        }\n    }\n\n    suspend fun saveToken(token: String) { settings.putString(TOKEN_KEY, token) }\n    suspend fun getToken(): String? = settings.getString(TOKEN_KEY, \"\")\n    suspend fun clearToken() { settings.remove(TOKEN_KEY) }\n\n    // Добавь пользователя (для динамики)\n    fun registerUser(username: String, password: String, role: String) {\n        users[username] = password to role\n    }\n}","chunkType":"CLASS","tokens":430,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.auth","imports":["com.auth0.jwt.JWT","com.auth0.jwt.JWTVerifier","com.auth0.jwt.algorithms.Algorithm"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/limits/LimitManager.kt","className":null,"methodName":null,"startLine":5,"endLine":30,"content":"package com.example.mindweaverstudio.data.limits\n\nimport com.example.mindweaverstudio.data.models.ai.Role\n\nclass LimitManager {\n    private val usage = mutableMapOf<String, MutableMap<String, Pair<Int, Long>>>()\n    private val defaultLimits = mapOf(\n        Role.ADMIN to mapOf(\"daily_queries\" to Int.MAX_VALUE),\n        Role.USER to mapOf(\"daily_queries\" to 100),\n        Role.GUEST to mapOf(\"daily_queries\" to 10)\n    )\n\n    fun checkAndConsume(username: String, limitKey: String, role: Role, consumption: Int = 1): Boolean {\n        val maxLimit = defaultLimits[role]?.get(limitKey) ?: 0\n        val userUsage = usage.getOrPut(username) { mutableMapOf() }\n        val now = System.currentTimeMillis()\n        var (used, resetAt) = userUsage.getOrPut(limitKey) { 0 to (now + 86_400_000) }\n\n        if (now > resetAt) {\n            used = 0\n            resetAt = now + 86_400_000\n        }\n\n        if (used + consumption > maxLimit) return false\n\n        used += consumption\n        userUsage[limitKey] = used to resetAt\n        return true\n    }\n}","chunkType":"CLASS","tokens":262,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.limits","imports":["com.example.mindweaverstudio.data.models.ai.Role"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/config/ApiConfiguration.kt","className":null,"methodName":null,"startLine":5,"endLine":50,"content":"package com.example.mindweaverstudio.data.utils.config\n\nimport java.util.Properties\n\ndata class ApiConfiguration(\n    val deepSeekApiKey: String,\n    val openRouterKey: String,\n    val openAiApiKey: String,\n    val geminiApiKey: String,\n    val githubApiKey: String,\n    val thinkApiKey: String,\n) {\n    companion object {\n        fun load(): ApiConfiguration {\n            val properties = Properties()\n            \n            // Try to load from config file first\n            try {\n                val configStream = ApiConfiguration::class.java.classLoader\n                    .getResourceAsStream(\"api-config.properties\")\n                if (configStream != null) {\n                    properties.load(configStream)\n                }\n            } catch (e: Exception) {\n                // Config file not found, will use environment variables\n            }\n            \n            return ApiConfiguration(\n                deepSeekApiKey = properties.getProperty(\"deepseek.api.key\") \n                    ?: System.getenv(\"DEEPSEEK_API_KEY\") \n                    ?: \"\",\n                openAiApiKey = properties.getProperty(\"openai.api.key\") \n                    ?: System.getenv(\"OPENAI_API_KEY\") \n                    ?: \"\",\n                geminiApiKey = properties.getProperty(\"gemini.api.key\")\n                    ?: System.getenv(\"GEMINI_API_KEY\") \n                    ?: \"\",\n                githubApiKey = properties.getProperty(\"github.api.key\")\n                    ?: System.getenv(\"GITHUB_API_KEY\")\n                    ?: \"\",\n                thinkApiKey = properties.getProperty(\"think.api.key\")\n                    ?: System.getenv(\"think.api.key\")\n                    ?: \"\",\n                openRouterKey = properties.getProperty(\"openrouter.api.key\")\n                    ?: System.getenv(\"openrouter.api.key\")\n                    ?: \"\",\n            )\n        }\n    }\n}","chunkType":"CLASS","tokens":471,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.config","imports":["java.util.Properties"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/JsonExporter.kt","className":null,"methodName":null,"startLine":15,"endLine":147,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument\n\nclass JsonExporter(\n    private val outputPath: String,\n    private val includeMetadata: Boolean = false\n) : ChunkProcessor {\n    \n    private val json = Json {\n        prettyPrint = false // Use compact format for streaming\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }\n    \n    private val writer: BufferedWriter\n    private val statistics = StreamingStatistics()\n    private var isFirstChunk = true\n    \n    init {\n        val file = File(outputPath)\n        file.parentFile?.mkdirs()\n        writer = BufferedWriter(FileWriter(file))\n        \n        // Write JSON opening\n        writer.write(\"{\")\n        \n        if (includeMetadata) {\n            writer.write(\"\\\"metadata\\\":{\")\n            writer.write(\"\\\"generatedAt\\\":\\\"${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}\\\",\")\n            writer.write(\"\\\"isStreaming\\\":true\")\n            writer.write(\"},\")\n        }\n        \n        writer.write(\"\\\"chunks\\\":[\")\n        writer.flush()\n    }\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        try {\n            // Update statistics\n            updateStatistics(chunk)\n            \n            // Write chunk separator\n            if (!isFirstChunk) {\n                writer.write(\",\")\n            } else {\n                isFirstChunk = false\n            }\n            \n            // Write chunk as JSON\n            val chunkJson = json.encodeToString(chunk)\n            writer.write(chunkJson)\n            writer.flush()\n            \n            // Suggest GC every 100 chunks to help with memory\n            if (statistics.totalChunks % 100 == 0) {\n                System.gc()\n                \n                // Print progress\n                val runtime = Runtime.getRuntime()\n                val usedMemory = runtime.totalMemory() - runtime.freeMemory()\n                val maxMemory = runtime.maxMemory()\n                val memoryPercent = (usedMemory.toDouble() / maxMemory * 100).toInt()\n                println(\"  Written ${statistics.totalChunks} chunks, Memory: ${memoryPercent}%\")\n            }\n            \n        } catch (e: Exception) {\n            println(\"Error writing chunk: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        try {\n            // Close JSON array and object\n            writer.write(\"]\")\n            \n            if (includeMetadata) {\n                // Add final statistics to metadata\n//                writer.write(\",\\\"finalStatistics\\\":{\")\n//                writer.write(\"\\\"totalFiles\\\":${statistics.totalFiles},\")\n//                writer.write(\"\\\"totalChunks\\\":${statistics.totalChunks},\")\n//                writer.write(\"\\\"totalTokens\\\":${statistics.totalTokens},\")\n//                writer.write(\"\\\"averageTokensPerChunk\\\":${statistics.averageTokensPerChunk},\")\n//                writer.write(\"\\\"chunksByType\\\":${json.encodeToString(statistics.chunksByType)},\")\n//                writer.write(\"\\\"largestChunkTokens\\\":${statistics.largestChunkTokens},\")\n//                writer.write(\"\\\"smallestChunkTokens\\\":${if (statistics.smallestChunkTokens == Int.MAX_VALUE) 0 else statistics.smallestChunkTokens},\")\n//                writer.write(\"\\\"chunksWithOverlap\\\":${statistics.chunksWithOverlap},\")\n//                writer.write(\"\\\"skippedFiles\\\":${statistics.skippedFiles},\")\n//                writer.write(\"\\\"errorFiles\\\":${statistics.errorFiles}\")\n//                writer.write(\"}\")\n            }\n            \n            writer.write(\"}\")\n            writer.flush()\n            writer.close()\n            \n            println(\"\\nStreaming export completed:\")\n            println(\"- Output file: $outputPath\")\n            println(\"- Total chunks written: ${statistics.totalChunks}\")\n            println(\"- Total files processed: ${statistics.totalFiles}\")\n            \n        } catch (e: Exception) {\n            println(\"Error completing export: ${e.message}\")\n        }\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument","kotlinx.serialization.json.Json"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/JsonExporter.kt","className":null,"methodName":null,"startLine":152,"endLine":283,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument\n\nclass RAGExporter(\n    private val outputBasePath: String,\n    private val batchSize: Int = 1000\n) : ChunkProcessor {\n    \n    private val json = Json {\n        prettyPrint = false\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }\n    \n    private val statistics = StreamingStatistics()\n    private var currentBatch = mutableListOf<RAGDocument>()\n    private var currentBatchId = 1\n    private var totalBatches = 0\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        try {\n            updateStatistics(chunk)\n            \n            // Convert chunk to RAG document\n            val ragDoc = RAGDocument(\n                id = generateDocumentId(chunk),\n                content = chunk.content,\n                metadata = mapOf(\n                    \"filePath\" to chunk.filePath,\n                    \"className\" to (chunk.className ?: \"\"),\n                    \"methodName\" to (chunk.methodName ?: \"\"),\n                    \"chunkType\" to chunk.chunkType.name,\n//                    \"startLine\" to chunk.startLine.toString(),\n//                    \"endLine\" to chunk.endLine.toString(),\n//                    \"tokens\" to chunk.tokens.toString(),\n//                    \"overlapsWithPrevious\" to chunk.overlapsWithPrevious.toString()\n                )\n            )\n            \n            currentBatch.add(ragDoc)\n            \n            // Write batch if full\n            if (currentBatch.size >= batchSize) {\n                writeBatch()\n            }\n            \n        } catch (e: Exception) {\n            println(\"Error processing chunk for RAG export: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        // Write remaining chunks in final batch\n        if (currentBatch.isNotEmpty()) {\n            writeBatch()\n        }\n        \n        println(\"\\nRAG streaming export completed:\")\n        println(\"- Total batches created: $totalBatches\")\n        println(\"- Total chunks exported: ${statistics.totalChunks}\")\n        println(\"- Batch files pattern: ${outputBasePath.replace(\".json\", \"_batch_*.json\")}\")\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun writeBatch() {\n        if (currentBatch.isEmpty()) return\n        \n        try {\n            val batchFile = File(outputBasePath.replace(\".json\", \"_batch_${currentBatchId}.json\"))\n            batchFile.parentFile?.mkdirs()\n            \n            val ragExport = mapOf(\n                \"batchId\" to currentBatchId,\n                \"totalBatches\" to \"TBD\", // Will be unknown until the end\n                \"documents\" to currentBatch.toList() // Create a copy\n            )\n            \n            val jsonContent = json.encodeToString(ragExport)\n            batchFile.writeText(jsonContent)\n            \n            println(\"  Written batch $currentBatchId (${currentBatch.size} documents)\")\n            \n            // Clear current batch and increment\n            currentBatch.clear()\n            currentBatchId++\n            totalBatches++\n            \n            // Suggest GC after each batch\n            System.gc()\n            \n        } catch (e: Exception) {\n            println(\"Error writing RAG batch: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    private fun generateDocumentId(chunk: ChunkMetadata): String {\n        val fileName = File(chunk.filePath).nameWithoutExtension\n        val identifier = when {\n            chunk.methodName != null -> \"${chunk.className}_${chunk.methodName}\"\n            chunk.className != null -> chunk.className\n            else -> fileName\n        }\n        return \"${fileName}_${identifier}_${chunk.startLine}-${chunk.endLine}\".replace(\" \", \"_\")\n    }\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument","kotlinx.serialization.json.Json"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":15,"endLine":88,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass AnalyticsOnlyProcessor : ChunkProcessor {\n    private val statistics = StreamingStatistics()\n    private val chunkSizes = mutableListOf<Int>()\n    private val fileChunkCounts = mutableMapOf<String, Int>()\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        updateStatistics(chunk)\n        chunkSizes.add(chunk.tokens)\n        \n        val fileName = File(chunk.filePath).nameWithoutExtension\n        fileChunkCounts[fileName] = fileChunkCounts.getOrDefault(fileName, 0) + 1\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        println(\"\\n=== Analytics Report ===\")\n        println(\"Files analyzed: ${statistics.totalFiles}\")\n        println(\"Chunks analyzed: ${statistics.totalChunks}\")\n        println(\"Total tokens: ${statistics.totalTokens}\")\n        \n        // Token distribution analysis\n        val sortedSizes = chunkSizes.sorted()\n        val median = if (sortedSizes.isNotEmpty()) sortedSizes[sortedSizes.size / 2] else 0\n        val percentile95 = if (sortedSizes.isNotEmpty()) sortedSizes[(sortedSizes.size * 0.95).toInt()] else 0\n        \n        println(\"\\nToken Distribution:\")\n        println(\"  Minimum: ${statistics.smallestChunkTokens}\")\n        println(\"  Median: $median\")\n        println(\"  95th percentile: $percentile95\")\n        println(\"  Maximum: ${statistics.largestChunkTokens}\")\n        println(\"  Average: ${statistics.averageTokensPerChunk}\")\n        \n        // Top files by chunk count\n        println(\"\\nTop Files by Chunk Count:\")\n        fileChunkCounts.entries.sortedByDescending { it.value }.take(10).forEach { (file, count) ->\n            println(\"  $file: $count chunks\")\n        }\n        \n        // Chunk type distribution\n        println(\"\\nChunk Type Distribution:\")\n        statistics.chunksByType.entries.sortedByDescending { it.value }.forEach { (type, count) ->\n            val percentage = (count.toDouble() / statistics.totalChunks * 100).toInt()\n            println(\"  $type: $count ($percentage%)\")\n        }\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":791,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":93,"endLine":134,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass FilteringProcessor(\n    private val delegate: ChunkProcessor,\n    private val chunkTypeFilter: Set<ChunkType>? = null,\n    private val minTokens: Int = 0,\n    private val maxTokens: Int = Int.MAX_VALUE,\n    private val filePathFilter: ((String) -> Boolean)? = null\n) : ChunkProcessor {\n    \n    private var filteredCount = 0\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        // Apply filters\n        if (chunkTypeFilter != null && chunk.chunkType !in chunkTypeFilter) {\n            filteredCount++\n            return\n        }\n        \n        if (chunk.tokens < minTokens || chunk.tokens > maxTokens) {\n            filteredCount++\n            return\n        }\n        \n        if (filePathFilter != null && !filePathFilter.invoke(chunk.filePath)) {\n            filteredCount++\n            return\n        }\n        \n        // Chunk passes all filters, delegate to actual processor\n        delegate.processChunk(chunk)\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        delegate.onFileComplete(filePath, chunkCount)\n    }\n    \n    override fun onComplete() {\n        println(\"Filtered out $filteredCount chunks based on criteria\")\n        delegate.onComplete()\n    }\n    \n    override fun getStatistics(): StreamingStatistics = delegate.getStatistics()\n}","chunkType":"CLASS","tokens":385,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":139,"endLine":165,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass MultiOutputProcessor(\n    private val processors: List<ChunkProcessor>\n) : ChunkProcessor {\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        processors.forEach { processor ->\n            try {\n                processor.processChunk(chunk)\n            } catch (e: Exception) {\n                println(\"Error in processor ${processor::class.simpleName}: ${e.message}\")\n            }\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        processors.forEach { it.onFileComplete(filePath, chunkCount) }\n    }\n    \n    override fun onComplete() {\n        processors.forEach { it.onComplete() }\n    }\n    \n    override fun getStatistics(): StreamingStatistics {\n        // Return statistics from the first processor\n        return processors.firstOrNull()?.getStatistics() ?: StreamingStatistics()\n    }\n}","chunkType":"CLASS","tokens":273,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":170,"endLine":227,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass ConsoleLoggingProcessor(\n    private val verbose: Boolean = false\n) : ChunkProcessor {\n    \n    private val statistics = StreamingStatistics()\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        updateStatistics(chunk)\n        \n        if (verbose) {\n            println(\"Chunk #${statistics.totalChunks}: ${chunk.chunkType} '${chunk.className ?: chunk.methodName ?: \"N/A\"}' (${chunk.tokens} tokens)\")\n        } else if (statistics.totalChunks % 100 == 0) {\n            println(\"Processed ${statistics.totalChunks} chunks...\")\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n        \n        if (verbose) {\n            val fileName = File(filePath).name\n            println(\"File complete: $fileName -> $chunkCount chunks\")\n        }\n    }\n    \n    override fun onComplete() {\n        println(\"\\n=== Console Logging Summary ===\")\n        println(\"Total files: ${statistics.totalFiles}\")\n        println(\"Total chunks: ${statistics.totalChunks}\")\n        println(\"Total tokens: ${statistics.totalTokens}\")\n        println(\"Average tokens per chunk: ${statistics.averageTokensPerChunk}\")\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":563,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runAnalyticsOnly","startLine":234,"endLine":243,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runAnalyticsOnly() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        val processor = AnalyticsOnlyProcessor()\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = processor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":134,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runFilteredExport","startLine":245,"endLine":261,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runFilteredExport() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        \n        // Only export CLASS and INTERFACE chunks with >100 tokens\n        val jsonExporter = JsonExporter(\"./filtered_chunks.json\")\n        val filteredProcessor = FilteringProcessor(\n            delegate = jsonExporter,\n            chunkTypeFilter = setOf(ChunkType.CLASS, ChunkType.INTERFACE),\n            minTokens = 100\n        )\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = filteredProcessor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":210,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runMultiOutput","startLine":263,"endLine":281,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runMultiOutput() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        \n        // Export to both regular JSON and RAG format simultaneously\n        val processors = listOf(\n            JsonExporter(\"./chunks.json\"),\n            RAGExporter(\"./rag_chunks.json\", batchSize = 500),\n            AnalyticsOnlyProcessor(),\n            ConsoleLoggingProcessor(verbose = false)\n        )\n        \n        val multiProcessor = MultiOutputProcessor(processors)\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = multiProcessor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":220,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":9,"endLine":158,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\nclass KotlinCodeParser {\n\n    fun parseFile(file: File): FileAnalysis {\n        val lines = file.readLines()\n        val content = lines.joinToString(\"\\n\")\n\n        return FileAnalysis(\n            filePath = file.absolutePath,\n            packageDeclaration = extractPackageDeclaration(lines),\n            imports = extractImports(lines),\n            elements = parseCodeElements(lines),\n            totalLines = lines.size\n        )\n    }\n\n    private fun extractPackageDeclaration(lines: List<String>): String? {\n        return lines.find { it.trim().startsWith(\"package \") }\n            ?.substringAfter(\"package \")\n            ?.substringBefore(\"//\")\n            ?.trim()\n    }\n\n    private fun extractImports(lines: List<String>): List<String> {\n        return lines.filter { it.trim().startsWith(\"import \") }\n            .map {\n                it.substringAfter(\"import \")\n                    .substringBefore(\"//\")\n                    .trim()\n            }\n    }\n\n    private fun parseCodeElements(lines: List<String>): List<CodeElement> {\n        val elements = mutableListOf<CodeElement>()\n        var currentDoc: String? = null\n        var i = 0\n\n        while (i < lines.size) {\n            val line = lines[i].trim()\n\n            when {\n                isDocumentationComment(line) -> {\n                    val docEnd = findDocumentationEnd(lines, i)\n                    currentDoc = extractDocumentation(lines, i, docEnd)\n                    i = docEnd\n                }\n\n                isClassDeclaration(line) -> {\n                    val element = parseClass(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isInterfaceDeclaration(line) -> {\n                    val element = parseInterface(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isEnumDeclaration(line) -> {\n                    val element = parseEnum(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isFunctionDeclaration(line) -> {\n                    val element = parseFunction(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isPropertyDeclaration(line) -> {\n                    val element = parseProperty(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                else -> i++\n            }\n        }\n\n        return elements\n    }\n\n    private fun isDocumentationComment(line: String): Boolean {\n        return line.startsWith(\"/**\") || line.startsWith(\"/*\")\n    }\n\n    private fun findDocumentationEnd(lines: List<String>, start: Int): Int {\n        for (i in start until lines.size) {\n            if (lines[i].trim().endsWith(\"*/\")) {\n                return i + 1\n            }\n        }\n        return start + 1\n    }\n\n    private fun extractDocumentation(lines: List<String>, start: Int, end: Int): String {\n        return lines.subList(start, end).joinToString(\"\\n\")\n    }\n\n    private fun isClassDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*(abstract|sealed|open|final)?\\s*class\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isInterfaceDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*interface\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isEnumDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*enum\\s+class\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isFunctionDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*(override|suspend|inline|infix)?\\s*fun\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isPropertyDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return (Regex(\"\"\"(public|private|internal|protected)?\\s*(val|var)\\s+\\w+\"\"\").find(cleanLine) != null) &&\n                hasComplexInitialization(cleanLine)\n    }\n\n    private fun hasComplexInitialization(line: String): Boolean {\n        return line.contains(\"{\") || line.contains(\"=\") && line.length > 50\n    }\n\n    private fun String.removeAnnotations(): String {\n        return this.replace(Regex(\"\"\"@\\w+(\\([^)]*\\))?\\s*\"\"\"), \"\")\n    }\n\n    private fun parseClass(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1 // Convert to 1-based indexing\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildClassSignature(lines, startIndex)\n        val name = extractClassName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":152,"endLine":308,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\n    private fun parseClass(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1 // Convert to 1-based indexing\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildClassSignature(lines, startIndex)\n        val name = extractClassName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.CLASS,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseInterface(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildInterfaceSignature(lines, startIndex)\n        val name = extractInterfaceName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.INTERFACE,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseEnum(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildEnumSignature(lines, startIndex)\n        val name = extractEnumName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.ENUM,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseFunction(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findFunctionEnd(lines, startIndex)\n        val signature = buildFunctionSignature(lines, startIndex, endLine - 1)\n        val name = extractFunctionName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.FUNCTION,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseProperty(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findPropertyEnd(lines, startIndex)\n        val signature = buildPropertySignature(lines, startIndex, endLine - 1)\n        val name = extractPropertyName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.PROPERTY,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun findBlockEnd(lines: List<String>, startIndex: Int): Int {\n        var braceCount = 0\n        var foundFirstBrace = false\n\n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        foundFirstBrace = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (foundFirstBrace && braceCount == 0) {\n                            return i + 1 // Convert to 1-based indexing\n                        }\n                    }\n                }\n            }\n        }\n        return lines.size\n    }\n\n    private fun findFunctionEnd(lines: List<String>, startIndex: Int): Int {\n        val line = lines[startIndex]\n        return if (line.contains(\"{\")) {\n            findBlockEnd(lines, startIndex)\n        } else {\n            // Single expression function or abstract function\n            startIndex + 1\n        }\n    }\n\n    private fun findPropertyEnd(lines: List<String>, startIndex: Int): Int {\n        val line = lines[startIndex]\n        return if (line.contains(\"{\")) {\n            findBlockEnd(lines, startIndex)\n        } else {\n            startIndex + 1\n        }\n    }\n\n    private fun buildClassSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildInterfaceSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildEnumSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildFunctionSignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":302,"endLine":361,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildFunctionSignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildPropertySignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n\n    private fun findSignatureEnd(lines: List<String>, startIndex: Int): Int {\n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            if (line.contains(\"{\") || line.contains(\"=\")) {\n                return i\n            }\n        }\n        return startIndex\n    }\n\n    private fun extractClassName(line: String): String {\n        return Regex(\"\"\"class\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownClass\"\n    }\n\n    private fun extractInterfaceName(line: String): String {\n        return Regex(\"\"\"interface\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownInterface\"\n    }\n\n    private fun extractEnumName(line: String): String {\n        return Regex(\"\"\"enum\\s+class\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownEnum\"\n    }\n\n    private fun extractFunctionName(line: String): String {\n        return Regex(\"\"\"fun\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownFunction\"\n    }\n\n    private fun extractPropertyName(line: String): String {\n        return Regex(\"\"\"(val|var)\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(2) ?: \"UnknownProperty\"\n    }\n\n    private fun extractModifiers(line: String): List<String> {\n        val modifiers = mutableListOf<String>()\n        val possibleModifiers = listOf(\n            \"public\", \"private\", \"internal\", \"protected\",\n            \"abstract\", \"sealed\", \"open\", \"final\",\n            \"override\", \"suspend\", \"inline\", \"infix\"\n        )\n\n        for (modifier in possibleModifiers) {\n            if (Regex(\"\"\"\\b$modifier\\b\"\"\").find(line) != null) {\n                modifiers.add(modifier)\n            }\n        }\n\n        return modifiers\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":607,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/ChunkProcessor.kt","className":null,"methodName":null,"startLine":8,"endLine":30,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\ninterface ChunkProcessor {\n    /**\n     * Called when a new chunk is generated.\n     * The processor should immediately handle the chunk (write to file, etc.)\n     * and not keep it in memory.\n     */\n    fun processChunk(chunk: ChunkMetadata)\n    \n    /**\n     * Called when processing of a file is complete.\n     */\n    fun onFileComplete(filePath: String, chunkCount: Int)\n    \n    /**\n     * Called when all processing is complete.\n     */\n    fun onComplete()\n    \n    /**\n     * Get lightweight statistics without keeping chunk objects in memory.\n     */\n    fun getStatistics(): StreamingStatistics\n}","chunkType":"INTERFACE","tokens":188,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/ChunkProcessor.kt","className":null,"methodName":null,"startLine":35,"endLine":48,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\ndata class StreamingStatistics(\n    var totalFiles: Int = 0,\n    var totalChunks: Int = 0,\n    var totalTokens: Long = 0,\n    var chunksByType: MutableMap<String, Int> = mutableMapOf(),\n    var largestChunkTokens: Int = 0,\n    var smallestChunkTokens: Int = Int.MAX_VALUE,\n    var chunksWithOverlap: Int = 0,\n    var skippedFiles: Int = 0,\n    var errorFiles: Int = 0\n) {\n    val averageTokensPerChunk: Int\n        get() = if (totalChunks > 0) (totalTokens / totalChunks).toInt() else 0\n}","chunkType":"CLASS","tokens":159,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":10,"endLine":159,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n    private val maxChunkSize: Int = 300,\n    private val largeElementThreshold: Int = 200,\n    private val overlapSize: Int = 7,\n    private val maxContentLength: Int = 10000\n) {\n    \n    /**\n     * Process a file with streaming callback - no chunks are accumulated in memory.\n     */\n    fun processFileStreaming(file: File, processor: ChunkProcessor): Int {\n        if (!file.exists() || !file.isFile) {\n            return 0\n        }\n        \n        // Check file size first\n        val fileSize = file.length()\n        if (fileSize > 1_000_000) { // 1MB limit for individual files\n            println(\"  Skipping very large file: ${file.name} (${fileSize / 1024}KB)\")\n            return 0\n        }\n        \n        return try {\n            // Parse file structure - this gives us metadata without full content\n            val analysis = parser.parseFile(file)\n            val fileLines = file.readLines() // We need this for content extraction\n            \n            var chunkCount = 0\n            \n            // Process each element immediately without accumulating\n            for (element in analysis.elements) {\n                try {\n                    chunkCount += processElementStreaming(element, analysis, fileLines, processor)\n                    \n                    // Suggest GC after processing large elements\n                    if (element.endLine - element.startLine > 100) {\n                        System.gc()\n                    }\n                    \n                } catch (e: Exception) {\n                    println(\"    Error processing element ${element.name}: ${e.message}\")\n                    continue // Skip this element, continue with others\n                }\n            }\n            \n            chunkCount\n            \n        } catch (e: OutOfMemoryError) {\n            println(\"    OutOfMemoryError processing ${file.name} - file too large\")\n            System.gc()\n            0\n        } catch (e: Exception) {\n            println(\"    Error processing file ${file.name}: ${e.message}\")\n            0\n        }\n    }\n    \n    /**\n     * Process a single code element with streaming - no chunk accumulation.\n     */\n    private fun processElementStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        processor: ChunkProcessor\n    ): Int {\n        val elementSize = element.endLine - element.startLine + 1\n        \n        // Skip extremely large elements entirely\n        if (elementSize > 2000) {\n            println(\"      Skipping extremely large element: ${element.name} ($elementSize lines)\")\n            return 0\n        }\n        \n        val contextualInfo = buildContextualInfoMinimal(element, analysis)\n        \n        return if (elementSize > largeElementThreshold) {\n            processLargeElementStreaming(element, analysis, fileLines, contextualInfo, processor)\n        } else {\n            processSingleChunkStreaming(element, analysis, fileLines, contextualInfo, processor)\n            1\n        }\n    }\n    \n    /**\n     * Process a large element by splitting into sub-chunks and streaming each immediately.\n     */\n    private fun processLargeElementStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        processor: ChunkProcessor\n    ): Int {\n        val elementLines = try {\n            fileLines.subList(element.startLine - 1, minOf(element.endLine, fileLines.size))\n        } catch (e: Exception) {\n            println(\"      Error extracting element lines for ${element.name}\")\n            return 0\n        }\n        \n        val logicalBlocks = findSimpleBlocks(elementLines, element.startLine - 1)\n        \n        var currentChunkStart = element.startLine\n        var chunkCount = 0\n        val maxChunksPerElement = 10 // Strict limit\n        \n        for (block in logicalBlocks) {\n            if (chunkCount >= maxChunksPerElement) {\n                println(\"      Reached chunk limit for element: ${element.name}\")\n                break\n            }\n            \n            val chunkEnd = minOf(block.endLine, element.endLine)\n            \n            if (chunkEnd <= currentChunkStart || chunkEnd - currentChunkStart < 3) {\n                continue\n            }\n            \n            try {\n                val chunkContent = buildSubChunkContentMinimal(\n                    element, analysis, fileLines, contextualInfo,\n                    currentChunkStart, chunkEnd\n                )\n                \n                if (chunkContent.length > maxContentLength) {\n                    println(\"      Chunk content too large, truncating: ${element.name}\")\n                    continue\n                }\n                \n                val tokens = estimateTokens(chunkContent)\n                \n                val chunk = ChunkMetadata(\n                    filePath = analysis.filePath,\n                    className = findContainingClassName(element, analysis),\n                    methodName = if (element.type == ChunkType.FUNCTION) element.name else null,\n                    startLine = currentChunkStart,\n                    endLine = chunkEnd,\n                    content = chunkContent,\n                    chunkType = ChunkType.SUB_CHUNK,\n                    tokens = tokens,\n                    contextualInfo = contextualInfo\n                )\n                \n                // Stream chunk immediately\n                processor.processChunk(chunk)\n                chunkCount++\n                \n                currentChunkStart = chunkEnd - overlapSize + 1\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":153,"endLine":309,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\n                )\n                \n                // Stream chunk immediately\n                processor.processChunk(chunk)\n                chunkCount++\n                \n                currentChunkStart = chunkEnd - overlapSize + 1\n                \n            } catch (e: OutOfMemoryError) {\n                println(\"      OutOfMemoryError creating sub-chunk for ${element.name}\")\n                System.gc()\n                break\n            } catch (e: Exception) {\n                println(\"      Error creating sub-chunk: ${e.message}\")\n                continue\n            }\n        }\n        \n        return chunkCount\n    }\n    \n    /**\n     * Process a single chunk and stream it immediately.\n     */\n    private fun processSingleChunkStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        processor: ChunkProcessor\n    ) {\n        try {\n            val chunkContent = buildChunkContentMinimal(element, analysis, fileLines, contextualInfo)\n            \n            if (chunkContent.length > maxContentLength) {\n                println(\"      Single chunk too large, skipping: ${element.name}\")\n                return\n            }\n            \n            val tokens = estimateTokens(chunkContent)\n            \n            val chunk = ChunkMetadata(\n                filePath = analysis.filePath,\n                className = findContainingClassName(element, analysis),\n                methodName = if (element.type == ChunkType.FUNCTION) element.name else null,\n                startLine = element.startLine,\n                endLine = element.endLine,\n                content = chunkContent,\n                chunkType = element.type,\n                tokens = tokens,\n                contextualInfo = contextualInfo\n            )\n            \n            // Stream chunk immediately\n            processor.processChunk(chunk)\n            \n        } catch (e: OutOfMemoryError) {\n            println(\"      OutOfMemoryError creating chunk for ${element.name}\")\n            System.gc()\n        } catch (e: Exception) {\n            println(\"      Error creating chunk: ${e.message}\")\n        }\n    }\n    \n    /**\n     * Find simple logical blocks without complex analysis to save memory.\n     */\n    private fun findSimpleBlocks(elementLines: List<String>, baseLineIndex: Int): List<LogicalBlock> {\n        val blocks = mutableListOf<LogicalBlock>()\n        \n        // Simple approach: split by fixed size chunks if no logical blocks found\n        val chunkSize = maxChunkSize / 2\n        for (i in 0 until elementLines.size step chunkSize) {\n            val endIndex = minOf(i + chunkSize, elementLines.size)\n            blocks.add(LogicalBlock(\n                baseLineIndex + i + 1,\n                baseLineIndex + endIndex,\n                BlockType.SEQUENTIAL\n            ))\n        }\n        \n        return blocks.take(10) // Limit number of blocks\n    }\n    \n    /**\n     * Build minimal contextual info to save memory.\n     */\n    private fun buildContextualInfoMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis\n    ): ContextualInfo {\n        return ContextualInfo(\n            packageDeclaration = analysis.packageDeclaration,\n            imports = analysis.imports.take(3), // Only first 3 imports\n            classSignature = findContainingClassName(element, analysis)?.let { \"$it class signature\" },\n            relatedPrivateMethods = emptyList() // Skip to save memory\n        )\n    }\n    \n    /**\n     * Build minimal chunk content to prevent memory issues.\n     */\n    private fun buildChunkContentMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo\n    ): String {\n        val content = StringBuilder(2000) // Small initial capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n            content.appendLine()\n        }\n        \n        // Add only essential imports (first 2)\n        contextualInfo.imports.take(2).forEach { import ->\n            content.appendLine(\"import $import\")\n        }\n        if (contextualInfo.imports.isNotEmpty()) content.appendLine()\n        \n        // Add the element content with size limits\n        try {\n            val elementContent = extractElementContentSafe(element, fileLines)\n            if (content.length + elementContent.length > maxContentLength) {\n                val availableSpace = maxContentLength - content.length - 50\n                if (availableSpace > 50) {\n                    content.append(elementContent.take(availableSpace))\n                    content.append(\"\\n// ... truncated ...\")\n                }\n            } else {\n                content.append(elementContent)\n            }\n        } catch (e: Exception) {\n            content.append(\"// Error extracting content: ${e.message}\")\n        }\n        \n        return content.toString()\n    }\n    \n    /**\n     * Build minimal sub-chunk content.\n     */\n    private fun buildSubChunkContentMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        startLine: Int,\n        endLine: Int\n    ): String {\n        val content = StringBuilder(1500) // Small capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":303,"endLine":375,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\n        endLine: Int\n    ): String {\n        val content = StringBuilder(1500) // Small capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n        }\n        \n        // Add element signature\n        content.appendLine(\"// ${element.type.name}: ${element.name}\")\n        content.appendLine(element.signature.take(150)) // Truncated signature\n        content.appendLine()\n        \n        // Add sub-chunk content with bounds checking\n        try {\n            val actualStartLine = maxOf(0, startLine - 1)\n            val actualEndLine = minOf(fileLines.size, endLine)\n            \n            if (actualStartLine < actualEndLine) {\n                val subChunkLines = fileLines.subList(actualStartLine, actualEndLine)\n                \n                var currentLength = content.length\n                for (line in subChunkLines) {\n                    if (currentLength + line.length + 1 > maxContentLength) {\n                        content.appendLine(\"// ... truncated ...\")\n                        break\n                    }\n                    content.appendLine(line)\n                    currentLength = content.length\n                }\n            }\n        } catch (e: Exception) {\n            content.appendLine(\"// Error extracting sub-chunk: ${e.message}\")\n        }\n        \n        return content.toString()\n    }\n    \n    /**\n     * Safe element content extraction with error handling.\n     */\n    private fun extractElementContentSafe(element: CodeElement, fileLines: List<String>): String {\n        return try {\n            if (element.startLine <= 0 || element.endLine > fileLines.size || element.startLine > element.endLine) {\n                \"// Invalid line numbers: ${element.startLine}-${element.endLine}\"\n            } else {\n                fileLines.subList(element.startLine - 1, element.endLine).joinToString(\"\\n\")\n            }\n        } catch (e: Exception) {\n            \"// Error extracting content: ${e.message}\"\n        }\n    }\n    \n    /**\n     * Find containing class name without complex analysis.\n     */\n    private fun findContainingClassName(element: CodeElement, analysis: FileAnalysis): String? {\n        return analysis.elements.find { classElement ->\n            (classElement.type == ChunkType.CLASS || classElement.type == ChunkType.INTERFACE) &&\n            classElement.startLine <= element.startLine &&\n            classElement.endLine >= element.endLine &&\n            classElement != element\n        }?.name\n    }\n    \n    /**\n     * Simple token estimation.\n     */\n    private fun estimateTokens(content: String): Int {\n        return minOf(content.length / 4, 1000) // Cap at 1000 tokens\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":726,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/RepositoryScanner.kt","className":null,"methodName":null,"startLine":9,"endLine":195,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport java.io.File\n\nclass RepositoryScanner(\n    private val chunker: Chunker = Chunker()\n) {\n\n    private val supportedExtensions = setOf(\".kt\", \".java\")\n    private val excludedDirectories = setOf(\n        \"build\", \"target\", \".gradle\", \".idea\", \".git\", \"node_modules\",\n        \".vscode\", \"out\", \"bin\", \"generated\", \"resources\"\n    )\n\n    /**\n     * Scan repository and stream chunks to processor immediately.\n     * This prevents memory accumulation by not keeping chunks in memory.\n     */\n    fun scanRepositoryStreaming(\n        rootPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ) {\n        val rootFile = File(rootPath)\n        if (!rootFile.exists() || !rootFile.isDirectory) {\n            throw IllegalArgumentException(\"Invalid repository path: $rootPath\")\n        }\n\n        val sourceFiles = findSourceFiles(rootFile, includeTests)\n\n        println(\"Found ${sourceFiles.size} source files to process...\")\n        println(\"Using streaming mode to avoid memory issues...\")\n\n        // Process files one by one, immediately streaming chunks to processor\n        sourceFiles.forEachIndexed { index, file ->\n            try {\n                // Skip very large files to prevent memory issues\n                val fileSize = file.length()\n                if (fileSize > 500_000) { // 500KB limit\n                    println(\"Skipping large file: ${file.name} (${fileSize / 1024}KB)\")\n                    processor.onFileComplete(file.absolutePath, 0)\n                    return@forEachIndexed\n                }\n\n                print(\"Processing file ${index + 1}/${sourceFiles.size}: ${file.name}...\")\n\n                // Process file with true streaming - no chunk lists created at all!\n                val chunkCount = chunker.processFileStreaming(file, processor)\n\n                println(\" ✓ ${chunkCount} chunks\")\n                processor.onFileComplete(file.absolutePath, chunkCount)\n\n                // No objects to clean up - everything was streamed directly!\n\n                // Suggest GC every 20 files to help with memory pressure\n                if ((index + 1) % 20 == 0) {\n                    System.gc()\n\n                    // Print memory status\n                    val runtime = Runtime.getRuntime()\n                    val usedMemory = runtime.totalMemory() - runtime.freeMemory()\n                    val maxMemory = runtime.maxMemory()\n                    val memoryPercent = (usedMemory.toDouble() / maxMemory * 100).toInt()\n                    println(\"  Memory usage: ${memoryPercent}%\")\n                }\n\n            } catch (e: Exception) {\n                println(\"Error processing file ${file.absolutePath}: ${e.message}\")\n                processor.onFileComplete(file.absolutePath, 0)\n            }\n        }\n\n        // Notify processor that all processing is complete\n        processor.onComplete()\n\n        val stats = processor.getStatistics()\n        println(\"\\nStreaming scan complete:\")\n        println(\"- Files processed: ${stats.totalFiles}\")\n        println(\"- Chunks generated: ${stats.totalChunks}\")\n        println(\"- Average chunks per file: ${stats.totalChunks / stats.totalFiles.coerceAtLeast(1)}\")\n        println(\"- Files skipped: ${stats.skippedFiles}\")\n        println(\"- Files with errors: ${stats.errorFiles}\")\n    }\n\n    /**\n     * Scan single file in streaming mode.\n     */\n    fun scanFileStreaming(\n        filePath: String,\n        processor: ChunkProcessor\n    ) {\n        val file = File(filePath)\n        if (!file.exists() || !file.isFile) {\n            throw IllegalArgumentException(\"Invalid file path: $filePath\")\n        }\n\n        if (!isSupportedFile(file)) {\n            throw IllegalArgumentException(\"Unsupported file type: ${file.extension}\")\n        }\n\n        println(\"Processing single file: ${file.name}\")\n\n        try {\n            val chunkCount = chunker.processFileStreaming(file, processor)\n            processor.onFileComplete(file.absolutePath, chunkCount)\n            println(\"Generated ${chunkCount} chunks\")\n\n        } catch (e: Exception) {\n            println(\"Error processing file: ${e.message}\")\n            processor.onFileComplete(file.absolutePath, 0)\n        }\n\n        processor.onComplete()\n    }\n\n    /**\n     * Scan directory in streaming mode.\n     */\n    fun scanDirectoryStreaming(\n        directoryPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ) {\n        val directory = File(directoryPath)\n        if (!directory.exists() || !directory.isDirectory) {\n            throw IllegalArgumentException(\"Invalid directory path: $directoryPath\")\n        }\n\n        val sourceFiles = findSourceFiles(directory, includeTests)\n\n        println(\"Processing directory: $directoryPath\")\n        println(\"Found ${sourceFiles.size} source files\")\n\n        sourceFiles.forEachIndexed { index, file ->\n            try {\n                print(\"Processing ${index + 1}/${sourceFiles.size}: ${file.name}...\")\n\n                val chunkCount = chunker.processFileStreaming(file, processor)\n                processor.onFileComplete(file.absolutePath, chunkCount)\n                println(\" ✓ ${chunkCount} chunks\")\n\n            } catch (e: Exception) {\n                println(\"Error processing file ${file.absolutePath}: ${e.message}\")\n                processor.onFileComplete(file.absolutePath, 0)\n            }\n        }\n\n        processor.onComplete()\n    }\n\n    private fun findSourceFiles(rootDirectory: File, includeTests: Boolean): List<File> {\n        val sourceFiles = mutableListOf<File>()\n\n        rootDirectory.walkTopDown()\n            .filter { file ->\n                // Skip excluded directories\n                !shouldExcludeDirectory(file, rootDirectory) &&\n                // Include only supported files\n                file.isFile && isSupportedFile(file) &&\n                // Filter test files if needed\n                (includeTests || !isTestFile(file))\n            }\n            .forEach { file ->\n                sourceFiles.add(file)\n            }\n\n        return sourceFiles\n    }\n\n    private fun shouldExcludeDirectory(file: File, rootDirectory: File): Boolean {\n        val relativePath = file.relativeTo(rootDirectory).path\n        return excludedDirectories.any { excludedDir ->\n            relativePath.startsWith(excludedDir) || relativePath.contains(\"/$excludedDir/\")\n        }\n    }\n\n    private fun isSupportedFile(file: File): Boolean {\n        return supportedExtensions.any { extension ->\n            file.name.endsWith(extension)\n        }\n    }\n\n    private fun isTestFile(file: File): Boolean {\n        val fileName = file.name.lowercase()\n        val pathComponents = file.path.lowercase().split(File.separator)\n\n        return fileName.contains(\"test\") ||\n                fileName.contains(\"spec\") ||\n                pathComponents.any { it == \"test\" || it == \"tests\" || it.contains(\"test\") }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/ChunkMetadata.kt","className":null,"methodName":null,"startLine":6,"endLine":36,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class ChunkMetadata(\n    val filePath: String,\n    val className: String? = null,\n    val methodName: String? = null,\n    val startLine: Int,\n    val endLine: Int,\n    val content: String,\n    val chunkType: ChunkType,\n    val tokens: Int,\n    val overlapsWithPrevious: Boolean = false,\n    val contextualInfo: ContextualInfo\n)\n\n@Serializable\ndata class ContextualInfo(\n    val packageDeclaration: String? = null,\n    val imports: List<String> = emptyList(),\n    val classSignature: String? = null,\n    val relatedPrivateMethods: List<String> = emptyList()\n)\n\n@Serializable\nenum class ChunkType {\n    CLASS,\n    INTERFACE,\n    ENUM,\n    METHOD,\n    FUNCTION,\n    PROPERTY,\n    SUB_CHUNK\n}","chunkType":"CLASS","tokens":201,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/ChunkMetadata.kt","className":null,"methodName":null,"startLine":39,"endLine":67,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class CodeElement(\n    val type: ChunkType,\n    val name: String,\n    val startLine: Int,\n    val endLine: Int,\n    val signature: String,\n    val modifiers: List<String> = emptyList(),\n    val isPrivate: Boolean = false,\n    val documentation: String? = null\n)\n\n@Serializable\ndata class FileAnalysis(\n    val filePath: String,\n    val packageDeclaration: String?,\n    val imports: List<String>,\n    val elements: List<CodeElement>,\n    val totalLines: Int\n)\n\ndata class LogicalBlock(\n    val startLine: Int,\n    val endLine: Int,\n    val type: BlockType\n)\n\nenum class BlockType {\n    CONDITIONAL, LOOP, EXCEPTION, WHEN, SEQUENTIAL\n}","chunkType":"CLASS","tokens":187,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/RAGDocument.kt","className":null,"methodName":null,"startLine":6,"endLine":10,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class RAGDocument(\n    val id: String,\n    val content: String,\n    val metadata: Map<String, String>\n)","chunkType":"CLASS","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/RAGChunkingUtility.kt","className":null,"methodName":null,"startLine":11,"endLine":160,"content":"package com.example.mindweaverstudio.data.utils.ragchunking\n// CLASS: RAGChunkingUtility\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n    largeElementThreshold: Int = 200,\n    overlapSize: Int = 7,\n    maxContentLength: Int = 10000\n) {\n    \n    private val chunker = Chunker(\n        maxChunkSize = maxChunkSize,\n        largeElementThreshold = largeElementThreshold,\n        overlapSize = overlapSize,\n        maxContentLength = maxContentLength\n    )\n    \n    private val scanner = RepositoryScanner(chunker)\n    \n    /**\n     * Process an entire repository with streaming output to avoid memory issues.\n     * Chunks are written to output files immediately as they're generated.\n     */\n    fun chunkRepositoryStreaming(\n        repositoryPath: String,\n        outputPath: String,\n        includeTests: Boolean = true,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Starting streaming repository chunking...\")\n        println(\"Repository: $repositoryPath\")\n        println(\"Output: $outputPath\")\n        println(\"Include tests: $includeTests\")\n        println()\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process repository with RAG-optimized streaming output.\n     * Creates batched JSON files suitable for RAG pipelines.\n     */\n    fun chunkRepositoryForRAGStreaming(\n        repositoryPath: String,\n        outputBasePath: String,\n        batchSize: Int = 1000,\n        includeTests: Boolean = true\n    ): StreamingStatistics {\n        println(\"Starting streaming RAG repository chunking...\")\n        println(\"Repository: $repositoryPath\")\n        println(\"Output base: $outputBasePath\")\n        println(\"Batch size: $batchSize\")\n        println(\"Include tests: $includeTests\")\n        println()\n        \n        val processor = RAGExporter(outputBasePath, batchSize)\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process a single file with streaming output.\n     */\n    fun chunkFileStreaming(\n        filePath: String,\n        outputPath: String,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Processing single file: $filePath\")\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanFileStreaming(filePath, processor)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process a directory with streaming output.\n     */\n    fun chunkDirectoryStreaming(\n        directoryPath: String,\n        outputPath: String,\n        includeTests: Boolean = true,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Processing directory: $directoryPath\")\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanDirectoryStreaming(directoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process with custom streaming processor.\n     * Allows for custom handling of chunks (e.g., direct database insertion).\n     */\n    fun chunkWithCustomProcessor(\n        repositoryPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ): StreamingStatistics {\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        return processor.getStatistics()\n    }\n    \n    /**\n     * Complete streaming workflow: chunk repository and create both regular and RAG outputs.\n     */\n    fun processRepositoryStreaming(\n        repositoryPath: String,\n        outputBasePath: String,\n        includeTests: Boolean = true,\n        createRAGOutput: Boolean = true,\n        ragBatchSize: Int = 1000\n    ) {\n        println(\"=== Streaming RAG Chunking Utility ===\")\n        println(\"Processing repository: $repositoryPath\")\n        println(\"Memory-efficient streaming mode\")\n        println()\n        \n        // Create output directory\n        val outputDir = File(outputBasePath).parentFile\n        outputDir?.mkdirs()\n        \n        // Process with regular JSON output\n        val regularOutputPath = \"${outputBasePath}_chunks.json\"\n        println(\"1. Creating regular JSON output...\")\n        val regularStats = chunkRepositoryStreaming(repositoryPath, regularOutputPath, includeTests)\n        \n        if (createRAGOutput) {\n            println(\"\\n2. Creating RAG-optimized output...\")\n            val ragOutputPath = \"${outputBasePath}_rag.json\"\n            val ragStats = chunkRepositoryForRAGStreaming(\n                repositoryPath, ragOutputPath, ragBatchSize, includeTests\n            )\n            \n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            println(\"- RAG batches: ${ragOutputPath.replace(\".json\", \"_batch_*.json\")}\")\n            \n            printStatistics(regularStats, \"Regular Export\")\n            printStatistics(ragStats, \"RAG Export\")\n        } else {\n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            \n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking","imports":["com.example.mindweaverstudio.data.utils.ragchunking.logic.Chunker","com.example.mindweaverstudio.data.utils.ragchunking.logic.RepositoryScanner","com.example.mindweaverstudio.data.utils.ragchunking.logic.ChunkProcessor"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/RAGChunkingUtility.kt","className":null,"methodName":null,"startLine":154,"endLine":233,"content":"package com.example.mindweaverstudio.data.utils.ragchunking\n// CLASS: RAGChunkingUtility\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n\n            printStatistics(regularStats, \"Regular Export\")\n            printStatistics(ragStats, \"RAG Export\")\n        } else {\n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            \n            printStatistics(regularStats, \"Export\")\n        }\n    }\n    \n    private fun printStatistics(stats: StreamingStatistics, label: String) {\n        println(\"\\n=== $label Statistics ===\")\n        println(\"Files processed: ${stats.totalFiles}\")\n        println(\"Chunks generated: ${stats.totalChunks}\")\n        println(\"Total tokens: ${stats.totalTokens}\")\n        println(\"Average tokens per chunk: ${stats.averageTokensPerChunk}\")\n        println(\"Largest chunk: ${stats.largestChunkTokens} tokens\")\n        println(\"Smallest chunk: ${if (stats.smallestChunkTokens == Int.MAX_VALUE) 0 else stats.smallestChunkTokens} tokens\")\n        println(\"Chunks with overlap: ${stats.chunksWithOverlap}\")\n        println(\"Files skipped: ${stats.skippedFiles}\")\n        println(\"Files with errors: ${stats.errorFiles}\")\n        println()\n        println(\"Chunks by type:\")\n        stats.chunksByType.entries.sortedByDescending { it.value }.forEach { (type, count) ->\n            println(\"  $type: $count\")\n        }\n        println()\n    }\n    \n    companion object Companion {\n        /**\n         * Quick utility method to chunk the current project with streaming.\n         */\n        fun chunkCurrentProjectStreaming(\n            outputDir: String = \"./rag_chunks\",\n            includeTests: Boolean = false,\n            ragBatchSize: Int = 1000\n        ) {\n            val utility = RAGChunkingUtility()\n            val currentDir = System.getProperty(\"user.dir\")\n            \n            File(outputDir).mkdirs()\n            \n            utility.processRepositoryStreaming(\n                repositoryPath = currentDir,\n                outputBasePath = \"$outputDir/mindweaver_studio\",\n                includeTests = includeTests,\n                createRAGOutput = true,\n                ragBatchSize = ragBatchSize\n            )\n        }\n        \n        /**\n         * Create a streaming utility with custom configuration.\n         */\n        fun create(\n            maxChunkSize: Int = 300,\n            largeElementThreshold: Int = 200,\n            overlapSize: Int = 7,\n            maxContentLength: Int = 10000\n        ): RAGChunkingUtility {\n            return RAGChunkingUtility(\n                maxChunkSize, largeElementThreshold, overlapSize, maxContentLength\n            )\n        }\n        \n        /**\n         * Create a memory-optimized streaming utility for large repositories.\n         */\n        fun createMemoryOptimized(): RAGChunkingUtility {\n            return RAGChunkingUtility(\n                maxChunkSize = 150,           // Smaller chunks\n                largeElementThreshold = 80,   // Split earlier\n                overlapSize = 3,              // Minimal overlap\n                maxContentLength = 3000       // 3KB limit per chunk\n            )\n        }\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":808,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking","imports":["com.example.mindweaverstudio.data.utils.ragchunking.logic.Chunker","com.example.mindweaverstudio.data.utils.ragchunking.logic.RepositoryScanner","com.example.mindweaverstudio.data.utils.ragchunking.logic.ChunkProcessor"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":19,"endLine":168,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\nclass CodeReplacer {\n    \n    /**\n     * Replaces code in a file based on the replacement request.\n     * \n     * @param request The replacement request containing file path, original code, new code, and options\n     * @return ReplacementResult indicating success, error, or other outcomes\n     */\n    suspend fun replaceCode(request: ReplacementRequest): ReplacementResult = withContext(Dispatchers.IO) {\n        try {\n            // Validate the request\n            when (val validation = request.validate()) {\n                is ReplacementValidation.Invalid -> {\n                    return@withContext ReplacementResult.Error(validation.message)\n                }\n                is ReplacementValidation.Valid -> {\n                    // Continue with replacement\n                }\n            }\n            \n            val filePath = request.getPath()\n            \n            // Check if file exists and is readable\n            if (!validateFile(filePath)) {\n                return@withContext ReplacementResult.Error(\n                    \"File does not exist or is not readable: ${request.filePath}\"\n                )\n            }\n            \n            // Read file content\n            val originalContent = try {\n                filePath.readText()\n            } catch (e: IOException) {\n                return@withContext ReplacementResult.Error(\n                    \"Failed to read file: ${e.message}\",\n                    cause = e,\n                    filePath = request.filePath\n                )\n            }\n            \n            // Process line endings if requested\n            val processedOriginalCode = if (request.options.normalizeLineEndings) {\n                normalizeLineEndings(request.originalCode)\n            } else {\n                request.originalCode\n            }\n            \n            val processedContent = if (request.options.normalizeLineEndings) {\n                normalizeLineEndings(originalContent)\n            } else {\n                originalContent\n            }\n            \n            // Find matches\n            val matches = findMatches(processedContent, processedOriginalCode, request.options)\n            \n            when {\n                matches.isEmpty() -> {\n                    ReplacementResult.NotFound(\n                        filePath = request.filePath,\n                        originalCode = request.originalCode,\n                        searchedLines = processedContent.lines().size\n                    )\n                }\n                \n                matches.size > 1 && !request.options.allowMultipleMatches -> {\n                    ReplacementResult.MultipleMatches(\n                        filePath = request.filePath,\n                        matches = matches,\n                        message = \"Found ${matches.size} matches. Use allowMultipleMatches=true to replace all.\"\n                    )\n                }\n                \n                request.options.dryRun -> {\n                    val previewContent = performReplacement(processedContent, matches, request.newCode)\n                    ReplacementResult.DryRun(\n                        filePath = request.filePath,\n                        matchesFound = matches.size,\n                        matches = matches,\n                        previewContent = previewContent,\n                        message = \"Dry run: Would replace ${matches.size} occurrence(s)\"\n                    )\n                }\n                \n                request.originalCode == request.newCode -> {\n                    ReplacementResult.NoChange(\n                        filePath = request.filePath,\n                        message = \"No changes made - original and new code are identical\"\n                    )\n                }\n                \n                else -> {\n                    // Perform actual replacement\n                    performFileReplacement(request, processedContent, matches)\n                }\n            }\n            \n        } catch (e: Exception) {\n            ReplacementResult.Error(\n                message = \"Unexpected error during replacement: ${e.message}\",\n                cause = e,\n                filePath = request.filePath\n            )\n        }\n    }\n    \n    /**\n     * Validates that the file exists and is readable.\n     */\n    private fun validateFile(filePath: Path): Boolean {\n        return filePath.exists() && filePath.isRegularFile() && Files.isReadable(filePath)\n    }\n    \n    /**\n     * Normalizes line endings to \\n.\n     */\n    private fun normalizeLineEndings(text: String): String {\n        return text.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n    }\n    \n    /**\n     * Finds all matches of the original code in the file content.\n     */\n    private fun findMatches(\n        content: String,\n        originalCode: String,\n        options: ReplacementOptions\n    ): List<ReplacementMatch> {\n        val matches = mutableListOf<ReplacementMatch>()\n        val lines = content.lines()\n        \n        if (options.exactMatch) {\n            // Find exact string matches\n            var searchIndex = 0\n            while (true) {\n                val matchIndex = content.indexOf(originalCode, searchIndex)\n                if (matchIndex == -1) break\n                \n                val match = createReplacementMatch(content, lines, matchIndex, originalCode.length)\n                matches.add(match)\n                \n                searchIndex = matchIndex + originalCode.length\n            }\n        } else {\n            // For non-exact matching, we could add fuzzy logic here in the future\n            // For now, fallback to exact matching\n            return findMatches(content, originalCode, options.copy(exactMatch = true))\n        }\n        \n        return matches\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":162,"endLine":318,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\n        } else {\n            // For non-exact matching, we could add fuzzy logic here in the future\n            // For now, fallback to exact matching\n            return findMatches(content, originalCode, options.copy(exactMatch = true))\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Creates a ReplacementMatch object for a found match.\n     */\n    private fun createReplacementMatch(\n        content: String,\n        lines: List<String>,\n        matchIndex: Int,\n        matchLength: Int\n    ): ReplacementMatch {\n        val beforeMatch = content.substring(0, matchIndex)\n        val afterMatch = content.substring(matchIndex + matchLength)\n        val matchedText = content.substring(matchIndex, matchIndex + matchLength)\n        \n        // Calculate line and column positions\n        val startLine = beforeMatch.count { it == '\\n' } + 1\n        val lastNewlineBeforeMatch = beforeMatch.lastIndexOf('\\n')\n        val startColumn = if (lastNewlineBeforeMatch == -1) {\n            matchIndex + 1\n        } else {\n            matchIndex - lastNewlineBeforeMatch\n        }\n        \n        val matchContent = content.substring(matchIndex, matchIndex + matchLength)\n        val endLine = startLine + matchContent.count { it == '\\n' }\n        val endColumn = if (matchContent.contains('\\n')) {\n            val lastNewlineInMatch = matchContent.lastIndexOf('\\n')\n            matchContent.length - lastNewlineInMatch\n        } else {\n            startColumn + matchContent.length - 1\n        }\n        \n        // Get context lines\n        val contextBefore = getContextLines(lines, startLine - 1, -2, 0)\n        val contextAfter = getContextLines(lines, endLine - 1, 1, 2)\n        \n        return ReplacementMatch(\n            startLine = startLine,\n            endLine = endLine,\n            startColumn = startColumn,\n            endColumn = endColumn,\n            matchedText = matchedText,\n            contextBefore = contextBefore,\n            contextAfter = contextAfter\n        )\n    }\n    \n    /**\n     * Gets context lines around a match.\n     */\n    private fun getContextLines(\n        lines: List<String>,\n        centerLine: Int,\n        startOffset: Int,\n        endOffset: Int\n    ): String {\n        val start = maxOf(0, centerLine + startOffset)\n        val end = minOf(lines.size - 1, centerLine + endOffset)\n        \n        return (start..end).mapNotNull { index ->\n            lines.getOrNull(index)\n        }.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Performs the actual text replacement.\n     */\n    private fun performReplacement(\n        content: String,\n        matches: List<ReplacementMatch>,\n        newCode: String\n    ): String {\n        var result = content\n        \n        // Replace matches in reverse order to maintain correct indices\n        matches.sortedByDescending { match ->\n            content.indexOf(match.matchedText)\n        }.forEach { match ->\n            val matchIndex = result.indexOf(match.matchedText)\n            if (matchIndex != -1) {\n                result = result.substring(0, matchIndex) + \n                        newCode + \n                        result.substring(matchIndex + match.matchedText.length)\n            }\n        }\n        \n        return result\n    }\n    \n    /**\n     * Performs the file replacement with backup and safety checks.\n     */\n    private suspend fun performFileReplacement(\n        request: ReplacementRequest,\n        content: String,\n        matches: List<ReplacementMatch>\n    ): ReplacementResult = withContext(Dispatchers.IO) {\n        val filePath = request.getPath()\n        var backupPath: String? = null\n        \n        try {\n            // Create backup if requested\n            if (request.options.createBackup) {\n                backupPath = createBackup(filePath)\n            }\n            \n            // Perform replacement\n            val newContent = performReplacement(content, matches, request.newCode)\n            \n            // Write the new content atomically\n            writeFileAtomically(filePath, newContent)\n            \n            ReplacementResult.Success(\n                filePath = request.filePath,\n                matchesFound = matches.size,\n                matchesReplaced = matches.size,\n                backupPath = backupPath,\n                message = \"Successfully replaced ${matches.size} occurrence(s) in ${request.filePath}\"\n            )\n            \n        } catch (e: Exception) {\n            // If we created a backup and something went wrong, try to restore\n            if (backupPath != null) {\n                try {\n                    Files.copy(\n                        Path.of(backupPath),\n                        filePath,\n                        StandardCopyOption.REPLACE_EXISTING\n                    )\n                } catch (restoreException: Exception) {\n                    // Log but don't override the original exception\n                }\n            }\n            \n            ReplacementResult.Error(\n                message = \"Failed to replace code: ${e.message}\",\n                cause = e,\n                filePath = request.filePath\n            )\n        }\n    }\n    \n    /**\n     * Creates a backup of the file.\n     */\n    private fun createBackup(filePath: Path): String {\n        val timestamp = System.currentTimeMillis()\n        val backupPath = Path.of(\"${filePath}.backup.$timestamp\")\n        Files.copy(filePath, backupPath, StandardCopyOption.COPY_ATTRIBUTES)\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":312,"endLine":345,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\n    /**\n     * Creates a backup of the file.\n     */\n    private fun createBackup(filePath: Path): String {\n        val timestamp = System.currentTimeMillis()\n        val backupPath = Path.of(\"${filePath}.backup.$timestamp\")\n        Files.copy(filePath, backupPath, StandardCopyOption.COPY_ATTRIBUTES)\n        return backupPath.toString()\n    }\n    \n    /**\n     * Writes content to file atomically by writing to a temporary file first.\n     */\n    private fun writeFileAtomically(filePath: Path, content: String) {\n        val tempPath = Path.of(\"${filePath}.tmp.${System.currentTimeMillis()}\")\n        \n        try {\n            // Write to temporary file\n            tempPath.writeText(content)\n            \n            // Atomically move temporary file to target\n            Files.move(tempPath, filePath, StandardCopyOption.REPLACE_EXISTING)\n            \n        } catch (e: Exception) {\n            // Clean up temporary file if something went wrong\n            try {\n                Files.deleteIfExists(tempPath)\n            } catch (cleanupException: Exception) {\n                // Ignore cleanup errors\n            }\n            throw e\n        }\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":318,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":9,"endLine":38,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\ndata class ReplacementRequest(\n    val filePath: String,\n    val originalCode: String,\n    val newCode: String,\n    val options: ReplacementOptions = ReplacementOptions()\n) {\n    /**\n     * Gets the file path as a Path object.\n     */\n    fun getPath(): Path = Paths.get(filePath)\n    \n    /**\n     * Validates the request parameters.\n     */\n    fun validate(): ReplacementValidation {\n        if (filePath.isBlank()) {\n            return ReplacementValidation.Invalid(\"File path cannot be blank\")\n        }\n        \n        if (originalCode.isBlank()) {\n            return ReplacementValidation.Invalid(\"Original code cannot be blank\")\n        }\n        \n        if (originalCode == newCode && !options.allowNoChange) {\n            return ReplacementValidation.Invalid(\"Original and new code are identical\")\n        }\n        \n        return ReplacementValidation.Valid\n    }\n}","chunkType":"CLASS","tokens":250,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":43,"endLine":46,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\nsealed class ReplacementValidation {\n    object Valid : ReplacementValidation()\n    data class Invalid(val message: String) : ReplacementValidation()\n}","chunkType":"CLASS","tokens":68,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":51,"endLine":60,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\ndata class ReplacementOptions(\n    val exactMatch: Boolean = true,                    // Require exact string match\n    val preserveWhitespace: Boolean = true,            // Preserve original whitespace\n    val normalizeLineEndings: Boolean = true,          // Normalize line endings\n    val allowMultipleMatches: Boolean = false,         // Allow multiple occurrences to be replaced\n    val allowNoChange: Boolean = false,                // Allow originalCode == newCode\n    val createBackup: Boolean = false,                 // Create backup file before modification\n    val validateSyntax: Boolean = false,               // Validate Kotlin syntax after replacement\n    val dryRun: Boolean = false                        // Only simulate replacement, don't write\n)","chunkType":"CLASS","tokens":222,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":null,"startLine":6,"endLine":63,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nsealed class ReplacementResult {\n    /**\n     * Successful replacement.\n     */\n    data class Success(\n        val filePath: String,\n        val matchesFound: Int,\n        val matchesReplaced: Int,\n        val backupPath: String? = null,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * Code fragment not found in the file.\n     */\n    data class NotFound(\n        val filePath: String,\n        val originalCode: String,\n        val searchedLines: Int\n    ) : ReplacementResult()\n    \n    /**\n     * Multiple matches found but allowMultipleMatches is false.\n     */\n    data class MultipleMatches(\n        val filePath: String,\n        val matches: List<ReplacementMatch>,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * Error during replacement operation.\n     */\n    data class Error(\n        val message: String,\n        val cause: Throwable? = null,\n        val filePath: String? = null\n    ) : ReplacementResult()\n    \n    /**\n     * Dry run result - shows what would happen without making changes.\n     */\n    data class DryRun(\n        val filePath: String,\n        val matchesFound: Int,\n        val matches: List<ReplacementMatch>,\n        val previewContent: String,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * No changes were made (originalCode == newCode and allowNoChange is true).\n     */\n    data class NoChange(\n        val filePath: String,\n        val message: String\n    ) : ReplacementResult()\n}","chunkType":"CLASS","tokens":393,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":null,"startLine":68,"endLine":87,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\ndata class ReplacementMatch(\n    val startLine: Int,                    // Line number where match starts (1-based)\n    val endLine: Int,                      // Line number where match ends (1-based)\n    val startColumn: Int,                  // Column where match starts (1-based)\n    val endColumn: Int,                    // Column where match ends (1-based)\n    val matchedText: String,               // The actual matched text\n    val contextBefore: String,             // Lines before the match for context\n    val contextAfter: String               // Lines after the match for context\n) {\n    /**\n     * Gets a human-readable location description.\n     */\n    fun getLocationDescription(): String {\n        return if (startLine == endLine) {\n            \"line $startLine, columns $startColumn-$endColumn\"\n        } else {\n            \"lines $startLine-$endLine\"\n        }\n    }\n}","chunkType":"CLASS","tokens":239,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":92,"endLine":92,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.isSuccess(): Boolean = this is ReplacementResult.Success","chunkType":"FUNCTION","tokens":36,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":93,"endLine":93,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.isError(): Boolean = this is ReplacementResult.Error","chunkType":"FUNCTION","tokens":35,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":94,"endLine":99,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.getErrorMessage(): String? = when (this) {\n    is ReplacementResult.Error -> message\n    is ReplacementResult.NotFound -> \"Code fragment not found in file $filePath\"\n    is ReplacementResult.MultipleMatches -> \"Multiple matches found: $message\"\n    else -> null\n}","chunkType":"FUNCTION","tokens":88,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":101,"endLine":106,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.getSuccessMessage(): String? = when (this) {\n    is ReplacementResult.Success -> message\n    is ReplacementResult.DryRun -> message\n    is ReplacementResult.NoChange -> message\n    else -> null\n}","chunkType":"FUNCTION","tokens":71,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"main","startLine":16,"endLine":150,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nfun main() = runBlocking {\n    println(\"=== CodeReplacer Example ===\")\n    println()\n    \n    // Create a test file for demonstration\n    val testFile = createTestFile()\n    println(\"Created test file: $testFile\")\n    println()\n    \n    try {\n        // Example 1: Basic code replacement\n        println(\"1. Basic Code Replacement:\")\n        println(\"=\" .repeat(40))\n        val result1 = CodeReplacerUtils.replaceCodeInFile(\n            filePath = testFile,\n            originalCode = \"fun oldMethod() {\\n        println(\\\"Old implementation\\\")\\n    }\",\n            newCode = \"fun newMethod() {\\n        println(\\\"New and improved implementation\\\")\\n    }\"\n        )\n        println(result1)\n        println()\n        \n        // Example 2: Preview replacement before applying\n        println(\"2. Preview Replacement:\")\n        println(\"=\" .repeat(40))\n        val preview = CodeReplacerUtils.previewReplacement(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Updated Example\\\"\"\n        )\n        println(preview)\n        println()\n        \n        // Example 3: Get detailed preview information\n        println(\"3. Detailed Preview:\")\n        println(\"=\" .repeat(40))\n        val detailedPreview = CodeReplacerUtils.getReplacementPreview(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Updated Example\\\"\"\n        )\n        println(detailedPreview)\n        println()\n        \n        // Example 4: Replace with backup\n        println(\"4. Replace with Backup:\")\n        println(\"=\" .repeat(40))\n        val result4 = CodeReplacerUtils.replaceCodeWithOptions(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Backed Up Example\\\"\",\n            createBackup = true,\n            allowMultiple = false\n        )\n        println(result4)\n        println()\n        \n        // Example 5: Find code fragment without replacing\n        println(\"5. Find Code Fragment:\")\n        println(\"=\" .repeat(40))\n        val findResult = CodeReplacerUtils.findCodeFragment(\n            filePath = testFile,\n            codeFragment = \"class ExampleClass\"\n        )\n        println(findResult)\n        println()\n        \n        // Example 6: Multiple replacements in one operation\n        println(\"6. Multiple Replacements:\")\n        println(\"=\" .repeat(40))\n        val replacements = listOf(\n            \"println(\\\"New and improved implementation\\\")\" to \"println(\\\"Latest implementation\\\")\",\n            \"Backed Up Example\" to \"Final Example\"\n        )\n        val multipleResult = CodeReplacerUtils.replaceMultipleFragments(\n            filePath = testFile,\n            replacements = replacements,\n            createBackup = false\n        )\n        println(multipleResult)\n        println()\n        \n        // Example 7: Handle non-existent code\n        println(\"7. Handle Non-Existent Code:\")\n        println(\"=\" .repeat(40))\n        val notFoundResult = CodeReplacerUtils.replaceCodeInFile(\n            filePath = testFile,\n            originalCode = \"nonExistentFunction()\",\n            newCode = \"existentFunction()\"\n        )\n        println(notFoundResult)\n        println()\n        \n        // Example 8: Handle file that doesn't exist\n        println(\"8. Handle Non-Existent File:\")\n        println(\"=\" .repeat(40))\n        val noFileResult = CodeReplacerUtils.replaceCodeInFile(\n            filePath = \"/non/existent/file.kt\",\n            originalCode = \"anything\",\n            newCode = \"something\"\n        )\n        println(noFileResult)\n        println()\n        \n        // Example 9: Using detailed result for advanced handling\n        println(\"9. Advanced Result Handling:\")\n        println(\"=\" .repeat(40))\n        val detailedResult = CodeReplacerUtils.replaceCodeSafely(\n            filePath = testFile,\n            originalCode = \"class ExampleClass\",\n            newCode = \"class AdvancedExampleClass\",\n            options = ReplacementOptions(\n                createBackup = false,\n                dryRun = true  // Just preview\n            )\n        )\n        \n        when (detailedResult) {\n            is com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementResult.DryRun -> {\n                println(\"Would replace ${detailedResult.matchesFound} matches\")\n                println(\"Preview content (first 200 chars):\")\n                println(detailedResult.previewContent.take(200) + \"...\")\n            }\n            else -> println(\"Unexpected result: $detailedResult\")\n        }\n        \n        println(\"\\n\" + \"=\" .repeat(50))\n        println(\"Final file content:\")\n        println(\"=\" .repeat(50))\n        println(Files.readString(Paths.get(testFile)))\n        \n    } finally {\n        // Clean up test file and any backup files\n        cleanup(testFile)\n    }\n}","chunkType":"FUNCTION","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"createTestFile","startLine":155,"endLine":188,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nprivate fun createTestFile(): String {\n    val testContent = \"\"\"\npackage com.example.test\n\nimport kotlin.collections.*\n\n/**\n * Example class for testing code replacement.\n */\nclass ExampleClass {\n    private val name = \"Example\"\n    \n    fun oldMethod() {\n        println(\"Old implementation\")\n    }\n    \n    fun anotherMethod(): String {\n        return \"This method won't be changed\"\n    }\n    \n    companion object {\n        const val VERSION = \"1.0\"\n    }\n}\n\nfun topLevelFunction() {\n    println(\"Top level function\")\n}\n\"\"\".trimIndent()\n    \n    val tempFile = File.createTempFile(\"test_code_replacer\", \".kt\")\n    tempFile.writeText(testContent)\n    return tempFile.absolutePath\n}","chunkType":"FUNCTION","tokens":229,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"cleanup","startLine":193,"endLine":210,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nprivate fun cleanup(testFile: String) {\n    try {\n        // Delete main test file\n        Files.deleteIfExists(Paths.get(testFile))\n        \n        // Delete any backup files\n        val testDir = File(testFile).parentFile\n        testDir.listFiles { file ->\n            file.name.contains(\"test_code_replacer\") && file.name.contains(\"backup\")\n        }?.forEach { backupFile ->\n            backupFile.delete()\n        }\n        \n        println(\"Cleaned up test files\")\n    } catch (e: Exception) {\n        println(\"Note: Could not clean up all test files: ${e.message}\")\n    }\n}","chunkType":"FUNCTION","tokens":204,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"testEdgeCases","startLine":217,"endLine":252,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\n    suspend fun testEdgeCases() {\n        println(\"Testing edge cases:\")\n        println(\"-\" .repeat(30))\n        \n        val testFile = createTestFile()\n        \n        try {\n            // Test with empty original code\n            val emptyOriginalResult = CodeReplacerUtils.replaceCodeInFile(\n                filePath = testFile,\n                originalCode = \"\",\n                newCode = \"something\"\n            )\n            println(\"Empty original code: $emptyOriginalResult\")\n            \n            // Test with identical codes\n            val identicalResult = CodeReplacerUtils.replaceCodeSafely(\n                filePath = testFile,\n                originalCode = \"val name = \\\"Example\\\"\",\n                newCode = \"val name = \\\"Example\\\"\",\n                options = ReplacementOptions(allowNoChange = true)\n            )\n            println(\"Identical codes: ${identicalResult::class.simpleName}\")\n            \n            // Test with multiline replacement\n            val multilineResult = CodeReplacerUtils.replaceCodeInFile(\n                filePath = testFile,\n                originalCode = \"fun oldMethod() {\\n        println(\\\"Old implementation\\\")\\n    }\",\n                newCode = \"fun newMethod() {\\n        println(\\\"Line 1\\\")\\n        println(\\\"Line 2\\\")\\n        println(\\\"Line 3\\\")\\n    }\"\n            )\n            println(\"Multiline replacement: $multilineResult\")\n            \n        } finally {\n            cleanup(testFile)\n        }\n    }","chunkType":"FUNCTION","tokens":428,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"performanceTest","startLine":254,"endLine":289,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\n    suspend fun performanceTest() {\n        println(\"Performance test:\")\n        println(\"-\" .repeat(20))\n        \n        // Create a larger test file\n        val largeContent = buildString {\n            repeat(1000) { i ->\n                appendLine(\"class TestClass$i {\")\n                appendLine(\"    fun method$i() {\")\n                appendLine(\"        println(\\\"Method $i\\\")\")\n                appendLine(\"    }\")\n                appendLine(\"}\")\n                appendLine()\n            }\n        }\n        \n        val tempFile = File.createTempFile(\"large_test\", \".kt\")\n        tempFile.writeText(largeContent)\n        \n        try {\n            val startTime = System.currentTimeMillis()\n            \n            val result = CodeReplacerUtils.replaceCodeInFile(\n                filePath = tempFile.absolutePath,\n                originalCode = \"println(\\\"Method 500\\\")\",\n                newCode = \"println(\\\"Modified Method 500\\\")\"\n            )\n            \n            val endTime = System.currentTimeMillis()\n            println(\"Result: $result\")\n            println(\"Time taken: ${endTime - startTime}ms\")\n            \n        } finally {\n            tempFile.delete()\n        }\n    }","chunkType":"FUNCTION","tokens":359,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeInFile","startLine":21,"endLine":21,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeInFile(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode)","chunkType":"PROPERTY","tokens":51,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeWithOptions","startLine":41,"endLine":41,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeWithOptions(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":52,"endLine":52,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"previewReplacement","startLine":65,"endLine":65,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun previewReplacement(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":71,"endLine":71,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeSafely","startLine":85,"endLine":85,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeSafely(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":91,"endLine":91,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"findCodeFragment","startLine":102,"endLine":102,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun findCodeFragment(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":106,"endLine":106,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val options = ReplacementOptions(dryRun = true, allowNoChange = true)","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":107,"endLine":107,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, codeFragment, codeFragment, options)","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceMultipleFragments","startLine":132,"endLine":132,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceMultipleFragments(","chunkType":"FUNCTION","tokens":43,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":154,"endLine":154,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n            val currentOptions = if (index == 0) options else options.copy(createBackup = false)","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":155,"endLine":155,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n            val request = ReplacementRequest(filePath, originalCode, newCode, currentOptions)","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":173,"endLine":173,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val summary = \"\\nSummary: $successCount successful, $errorCount failed out of ${replacements.size} replacements\"","chunkType":"PROPERTY","tokens":63,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"formatResult","startLine":180,"endLine":217,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    private fun formatResult(result: ReplacementResult): String {\n        return when (result) {\n            is ReplacementResult.Success -> {\n                val backupInfo = if (result.backupPath != null) \" (backup created: ${result.backupPath})\" else \"\"\n                \"✅ ${result.message}$backupInfo\"\n            }\n            \n            is ReplacementResult.NotFound -> {\n                \"❌ Code fragment not found in ${result.filePath} (searched ${result.searchedLines} lines)\"\n            }\n            \n            is ReplacementResult.MultipleMatches -> {\n                val locations = result.matches.joinToString(\", \") { \n                    \"line ${it.startLine}\" \n                }\n                \"⚠️ Multiple matches found at: $locations. ${result.message}\"\n            }\n            \n            is ReplacementResult.Error -> {\n                \"❌ Error: ${result.message}\"\n            }\n            \n            is ReplacementResult.DryRun -> {\n                if (result.matchesFound > 0) {\n                    val locations = result.matches.joinToString(\", \") { match ->\n                        match.getLocationDescription()\n                    }\n                    \"📋 Dry run: Found ${result.matchesFound} match(es) at $locations\"\n                } else {\n                    \"📋 Dry run: No matches found\"\n                }\n            }\n            \n            is ReplacementResult.NoChange -> {\n                \"ℹ️ ${result.message}\"\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":406,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"getReplacementPreview","startLine":227,"endLine":227,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun getReplacementPreview(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":233,"endLine":233,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":14,"endLine":163,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\nclass SourceCodeFinder {\n    \n    /**\n     * Finds the source code of a class or function by name in a Kotlin project.\n     * \n     * @param projectRoot Path to the root of the project\n     * @param targetName Name of the class or function to find\n     * @param exactMatch If true, searches for exact name match only\n     * @return SearchResult containing found matches or error information\n     */\n    suspend fun findSourceCode(\n        projectRoot: String,\n        targetName: String,\n        exactMatch: Boolean = true\n    ): SearchResult = withContext(Dispatchers.IO) {\n        try {\n            val rootPath = Paths.get(projectRoot)\n            if (!Files.exists(rootPath) || !Files.isDirectory(rootPath)) {\n                return@withContext SearchResult.Error(\"Project root directory does not exist: $projectRoot\")\n            }\n            \n            val kotlinFiles = findKotlinFiles(rootPath)\n            if (kotlinFiles.isEmpty()) {\n                return@withContext SearchResult.Error(\"No Kotlin files found in project: $projectRoot\")\n            }\n            \n            val matches = mutableListOf<SourceCodeMatch>()\n            var searchedFiles = 0\n            \n            for (file in kotlinFiles) {\n                try {\n                    val fileMatches = searchInFile(file, targetName, exactMatch)\n                    matches.addAll(fileMatches)\n                    searchedFiles++\n                } catch (e: Exception) {\n                    // Continue searching in other files, but log the error\n                    continue\n                }\n            }\n            \n            return@withContext when {\n                matches.isEmpty() -> SearchResult.NotFound(targetName, searchedFiles)\n                matches.size == 1 -> SearchResult.Success(matches)\n                else -> SearchResult.MultipleMatches(matches)\n            }\n            \n        } catch (e: Exception) {\n            SearchResult.Error(\"Error during search: ${e.message}\", e)\n        }\n    }\n    \n    /**\n     * Finds all Kotlin files in the project directory recursively.\n     */\n    private fun findKotlinFiles(rootPath: Path): List<Path> {\n        val kotlinFiles = mutableListOf<Path>()\n        \n        try {\n            Files.walk(rootPath)\n                .filter { it.isRegularFile() }\n                .filter { it.extension == \"kt\" }\n                .forEach { kotlinFiles.add(it) }\n        } catch (e: Exception) {\n            // Return what we have so far\n        }\n        \n        return kotlinFiles\n    }\n    \n    /**\n     * Searches for the target entity in a single Kotlin file.\n     */\n    private fun searchInFile(filePath: Path, targetName: String, exactMatch: Boolean): List<SourceCodeMatch> {\n        val content = Files.readString(filePath)\n        val lines = content.lines()\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val packageName = extractPackageName(content)\n        val imports = extractImports(content)\n        \n        // Search for different types of entities\n        matches.addAll(findClasses(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        matches.addAll(findFunctions(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        matches.addAll(findConstants(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        \n        return matches\n    }\n    \n    /**\n     * Extracts package name from Kotlin file content.\n     */\n    private fun extractPackageName(content: String): String? {\n        val packageRegex = Regex(\"\"\"^package\\s+([a-zA-Z][a-zA-Z0-9._]*)\"\"\", RegexOption.MULTILINE)\n        return packageRegex.find(content)?.groupValues?.get(1)\n    }\n    \n    /**\n     * Extracts import statements from Kotlin file content.\n     */\n    private fun extractImports(content: String): List<String> {\n        val importRegex = Regex(\"\"\"^import\\s+([a-zA-Z][a-zA-Z0-9._*]*)\"\"\", RegexOption.MULTILINE)\n        return importRegex.findAll(content).map { it.groupValues[1] }.toList()\n    }\n    \n    /**\n     * Finds class, interface, object declarations in the file.\n     */\n    private fun findClasses(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val classPatterns = mapOf(\n            EntityType.CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(abstract\\s+|open\\s+|final\\s+)?class\\s+(\\w+)\"\"\"),\n            EntityType.INTERFACE to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?interface\\s+(\\w+)\"\"\"),\n            EntityType.OBJECT to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?object\\s+(\\w+)\"\"\"),\n            EntityType.DATA_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?data\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.SEALED_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?sealed\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.ENUM_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?enum\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.ANNOTATION_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?annotation\\s+class\\s+(\\w+)\"\"\")\n        )\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            for ((entityType, pattern) in classPatterns) {\n                val matchResult = pattern.find(line)\n                if (matchResult != null) {\n                    val extractedName = matchResult.groupValues.last()\n                    if (isNameMatch(extractedName, targetName, exactMatch)) {\n                        val sourceCode = extractEntitySourceCode(lines, lineIndex, entityType)\n                        matches.add(\n                            SourceCodeMatch(\n                                entityName = extractedName,\n                                entityType = entityType,\n                                sourceCode = sourceCode,\n                                filePath = filePath,\n                                packageName = packageName,\n                                lineNumber = lineIndex + 1,\n                                imports = imports\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        \n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":157,"endLine":313,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Finds function declarations in the file.\n     */\n    private fun findFunctions(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val functionPattern = Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(suspend\\s+|inline\\s+|infix\\s+|operator\\s+)*fun\\s+(\\w+)\"\"\")\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            val matchResult = functionPattern.find(line)\n            if (matchResult != null) {\n                val extractedName = matchResult.groupValues.last()\n                if (isNameMatch(extractedName, targetName, exactMatch)) {\n                    val sourceCode = extractFunctionSourceCode(lines, lineIndex)\n                    matches.add(\n                        SourceCodeMatch(\n                            entityName = extractedName,\n                            entityType = EntityType.FUNCTION,\n                            sourceCode = sourceCode,\n                            filePath = filePath,\n                            packageName = packageName,\n                            lineNumber = lineIndex + 1,\n                            imports = imports\n                        )\n                    )\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Finds constant and property declarations in the file.\n     */\n    private fun findConstants(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val constantPattern = Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(const\\s+)?val\\s+(\\w+)\"\"\")\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            val matchResult = constantPattern.find(line)\n            if (matchResult != null) {\n                val extractedName = matchResult.groupValues.last()\n                if (isNameMatch(extractedName, targetName, exactMatch)) {\n                    val entityType = if (line.contains(\"const\")) EntityType.CONSTANT else EntityType.PROPERTY\n                    val sourceCode = extractPropertySourceCode(lines, lineIndex)\n                    matches.add(\n                        SourceCodeMatch(\n                            entityName = extractedName,\n                            entityType = entityType,\n                            sourceCode = sourceCode,\n                            filePath = filePath,\n                            packageName = packageName,\n                            lineNumber = lineIndex + 1,\n                            imports = imports\n                        )\n                    )\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Checks if the extracted name matches the target name.\n     */\n    private fun isNameMatch(extractedName: String, targetName: String, exactMatch: Boolean): Boolean {\n        return if (exactMatch) {\n            extractedName == targetName\n        } else {\n            extractedName.contains(targetName, ignoreCase = true)\n        }\n    }\n    \n    /**\n     * Extracts the complete source code for a class/interface/object entity.\n     */\n    private fun extractEntitySourceCode(lines: List<String>, startIndex: Int, entityType: EntityType): String {\n        val sourceLines = mutableListOf<String>()\n        var braceCount = 0\n        var started = false\n        \n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            sourceLines.add(line)\n            \n            // Count braces to determine the end of the entity\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        started = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (started && braceCount == 0) {\n                            return sourceLines.joinToString(\"\\n\")\n                        }\n                    }\n                }\n            }\n        }\n        \n        return sourceLines.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Extracts the complete source code for a function.\n     */\n    private fun extractFunctionSourceCode(lines: List<String>, startIndex: Int): String {\n        val sourceLines = mutableListOf<String>()\n        var braceCount = 0\n        var started = false\n        var hasBody = false\n        \n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            sourceLines.add(line)\n            \n            // Check if function has a body (contains '{') or is a single expression (contains '=')\n            if (!hasBody && (line.contains('{') || line.contains('='))) {\n                hasBody = true\n            }\n            \n            // If function is a single expression function, look for the end\n            if (line.contains('=') && !line.contains('{')) {\n                // Single expression function - continue until we find the complete expression\n                if (line.trim().endsWith('}') || line.trim().endsWith(')')) {\n                    return sourceLines.joinToString(\"\\n\")\n                }\n                continue\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":307,"endLine":355,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\n            // If function is a single expression function, look for the end\n            if (line.contains('=') && !line.contains('{')) {\n                // Single expression function - continue until we find the complete expression\n                if (line.trim().endsWith('}') || line.trim().endsWith(')')) {\n                    return sourceLines.joinToString(\"\\n\")\n                }\n                continue\n            }\n            \n            // Count braces for functions with body\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        started = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (started && braceCount == 0) {\n                            return sourceLines.joinToString(\"\\n\")\n                        }\n                    }\n                }\n            }\n            \n            // If we haven't found a body after a reasonable number of lines, assume it's abstract\n            if (!hasBody && i - startIndex > 3) {\n                return sourceLines.joinToString(\"\\n\")\n            }\n        }\n        \n        return sourceLines.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Extracts the complete source code for a property/constant.\n     */\n    private fun extractPropertySourceCode(lines: List<String>, startIndex: Int): String {\n        val line = lines[startIndex]\n        \n        // Simple property/constant declarations are typically single line\n        if (!line.contains('{')) {\n            return line\n        }\n        \n        // Property with getter/setter - extract the complete block\n        return extractEntitySourceCode(lines, startIndex, EntityType.PROPERTY)\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":473,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SearchResult.kt","className":null,"methodName":null,"startLine":3,"endLine":8,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\nsealed class SearchResult {\n    data class Success(val matches: List<SourceCodeMatch>) : SearchResult()\n    data class NotFound(val targetName: String, val searchedFiles: Int) : SearchResult()\n    data class Error(val message: String, val cause: Throwable? = null) : SearchResult()\n    data class MultipleMatches(val matches: List<SourceCodeMatch>) : SearchResult()\n}","chunkType":"CLASS","tokens":108,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SearchResult.kt","className":null,"methodName":"SearchResult","startLine":10,"endLine":14,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\nfun SearchResult.getFirstMatch(): SourceCodeMatch? = when (this) {\n    is SearchResult.Success -> matches.firstOrNull()\n    is SearchResult.MultipleMatches -> matches.firstOrNull()\n    else -> null\n}","chunkType":"FUNCTION","tokens":66,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SourceCodeMatch.kt","className":null,"methodName":null,"startLine":3,"endLine":24,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\ndata class SourceCodeMatch(\n    val entityName: String,\n    val entityType: EntityType,\n    val sourceCode: String,\n    val filePath: String,\n    val packageName: String?,\n    val lineNumber: Int,\n    val imports: List<String>\n)\n\nenum class EntityType {\n    CLASS,\n    INTERFACE,\n    OBJECT,\n    DATA_CLASS,\n    SEALED_CLASS,\n    ENUM_CLASS,\n    FUNCTION,\n    CONSTANT,\n    PROPERTY,\n    ANNOTATION_CLASS\n}","chunkType":"CLASS","tokens":118,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"main","startLine":12,"endLine":87,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\nfun main() = runBlocking {\n    val projectRoot = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio\"\n    \n    println(\"=== SourceCodeFinder Example ===\")\n    println()\n    \n    // Test 1: Find an interface\n    println(\"1. Finding interface 'Agent':\")\n    println(\"=\" .repeat(50))\n    val agentResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"Agent\")\n    println(agentResult)\n    println()\n    \n    // Test 2: Find a function\n    println(\"2. Finding function 'scanDirectoryToFileNode':\")\n    println(\"=\" .repeat(50))\n    val functionResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"scanDirectoryToFileNode\")\n    println(functionResult)\n    println()\n    \n    // Test 3: Find a class that might have multiple matches\n    println(\"3. Finding class 'AiClient' (might have multiple matches):\")\n    println(\"=\" .repeat(50))\n    val classResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"AiClient\")\n    println(classResult)\n    println()\n    \n    // Test 4: Test non-existent entity\n    println(\"4. Finding non-existent entity 'NonExistentClass':\")\n    println(\"=\" .repeat(50))\n    val notFoundResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"NonExistentClass\")\n    println(notFoundResult)\n    println()\n    \n    // Test 5: Find with package disambiguation\n    println(\"5. Finding 'ChatMessage' with package disambiguation:\")\n    println(\"=\" .repeat(50))\n    val packageResult = SourceCodeUtils.findInPackage(\n        projectRoot, \n        \"ChatMessage\", \n        packageName = \"codeeditor.models\"\n    )\n    println(packageResult)\n    println()\n    \n    // Test 6: Get clean source code (without metadata)\n    println(\"6. Getting clean source code for 'Agent':\")\n    println(\"=\" .repeat(50))\n    val cleanSource = SourceCodeUtils.findCleanSourceCode(projectRoot, \"Agent\")\n    if (cleanSource != null) {\n        println(cleanSource)\n    } else {\n        println(\"Not found or error occurred\")\n    }\n    println()\n    \n    // Test 7: Check if entity exists\n    println(\"7. Checking if entities exist:\")\n    println(\"=\" .repeat(30))\n    val agentExists = SourceCodeUtils.exists(projectRoot, \"Agent\")\n    val fakeExists = SourceCodeUtils.exists(projectRoot, \"FakeClass\")\n    println(\"Agent exists: $agentExists\")\n    println(\"FakeClass exists: $fakeExists\")\n    println()\n    \n    // Test 8: Find all matches for a common name\n    println(\"8. Finding all matches for 'ChatMessage':\")\n    println(\"=\" .repeat(50))\n    val allMatches = SourceCodeUtils.findAllMatches(projectRoot, \"ChatMessage\")\n    println(\"Found ${allMatches.size} matches:\")\n    allMatches.forEachIndexed { index, match ->\n        println(\"${index + 1}. ${match.entityType} in ${match.packageName ?: \"default package\"}\")\n        println(\"   File: ${match.filePath}\")\n        println(\"   Line: ${match.lineNumber}\")\n    }\n}","chunkType":"FUNCTION","tokens":754,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"testSpecificEntities","startLine":94,"endLine":121,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\n    suspend fun testSpecificEntities(projectRoot: String) {\n        val testCases = listOf(\n            \"Agent\" to \"interface\",\n            \"scanDirectoryToFileNode\" to \"function\",\n            \"AiClient\" to \"interface\",\n            \"CODE_TESTER_AGENT\" to \"constant\",\n            \"DefaultRootComponent\" to \"class\",\n            \"EntityType\" to \"enum class\"\n        )\n        \n        println(\"Testing specific entities:\")\n        println(\"=\" .repeat(50))\n        \n        testCases.forEach { (entityName, expectedType) ->\n            println(\"Testing: $entityName (expected: $expectedType)\")\n            val result = SourceCodeUtils.findCleanSourceCode(projectRoot, entityName)\n            if (result != null) {\n                println(\"✅ Found\")\n                println(\"First few lines:\")\n                result.lines().take(5).forEach { line ->\n                    if (line.isNotBlank()) println(\"  $line\")\n                }\n            } else {\n                println(\"❌ Not found\")\n            }\n            println()\n        }\n    }","chunkType":"FUNCTION","tokens":304,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"performanceTest","startLine":123,"endLine":136,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\n    suspend fun performanceTest(projectRoot: String) {\n        println(\"Performance test:\")\n        println(\"=\" .repeat(30))\n        \n        val startTime = System.currentTimeMillis()\n        \n        val testEntities = listOf(\"Agent\", \"AiClient\", \"scanDirectoryToFileNode\", \"NonExistent\")\n        testEntities.forEach { entityName ->\n            SourceCodeUtils.exists(projectRoot, entityName)\n        }\n        \n        val endTime = System.currentTimeMillis()\n        println(\"Time taken for ${testEntities.size} searches: ${endTime - startTime}ms\")\n    }","chunkType":"FUNCTION","tokens":185,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFormatter.kt","className":null,"methodName":null,"startLine":6,"endLine":112,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\nclass SourceCodeFormatter {\n    \n    /**\n     * Formats the search result into a human-readable string.\n     */\n    fun formatResult(result: SearchResult): String {\n        return when (result) {\n            is SearchResult.Success -> formatSingleMatch(result.matches.first())\n            is SearchResult.MultipleMatches -> formatMultipleMatches(result.matches)\n            is SearchResult.NotFound -> formatNotFound(result.targetName, result.searchedFiles)\n            is SearchResult.Error -> formatError(result.message, result.cause)\n        }\n    }\n    \n    /**\n     * Formats a single source code match with imports.\n     */\n    private fun formatSingleMatch(match: SourceCodeMatch): String {\n        val imports = if (match.imports.isNotEmpty()) {\n            match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n        } else \"\"\n        \n        val packageDeclaration = if (match.packageName != null) {\n            \"package ${match.packageName}\\n\\n\"\n        } else \"\"\n        \n        return buildString {\n            appendLine(\"// Found: ${match.entityName} (${match.entityType.name.lowercase()})\")\n            appendLine(\"// File: ${match.filePath}\")\n            appendLine(\"// Line: ${match.lineNumber}\")\n            if (match.packageName != null) {\n                appendLine(\"// Package: ${match.packageName}\")\n            }\n            appendLine()\n            append(packageDeclaration)\n            append(imports)\n            append(match.sourceCode)\n        }\n    }\n    \n    /**\n     * Formats multiple matches with disambiguation information.\n     */\n    private fun formatMultipleMatches(matches: List<SourceCodeMatch>): String {\n        return buildString {\n            appendLine(\"Multiple matches found for '${matches.first().entityName}':\")\n            appendLine()\n            \n            matches.forEachIndexed { index, match ->\n                appendLine(\"--- Match ${index + 1} ---\")\n                appendLine(\"Type: ${match.entityType.name.lowercase()}\")\n                appendLine(\"Package: ${match.packageName ?: \"default\"}\")\n                appendLine(\"File: ${match.filePath}\")\n                appendLine(\"Line: ${match.lineNumber}\")\n                appendLine()\n                \n                val imports = if (match.imports.isNotEmpty()) {\n                    match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n                } else \"\"\n                \n                val packageDeclaration = if (match.packageName != null) {\n                    \"package ${match.packageName}\\n\\n\"\n                } else \"\"\n                \n                append(packageDeclaration)\n                append(imports)\n                append(match.sourceCode)\n                appendLine()\n                appendLine()\n            }\n        }\n    }\n    \n    /**\n     * Formats not found result.\n     */\n    private fun formatNotFound(targetName: String, searchedFiles: Int): String {\n        return \"Entity '$targetName' not found in $searchedFiles Kotlin files.\"\n    }\n    \n    /**\n     * Formats error result.\n     */\n    private fun formatError(message: String, cause: Throwable?): String {\n        return buildString {\n            appendLine(\"Error during search: $message\")\n            if (cause != null) {\n                appendLine(\"Cause: ${cause.message}\")\n            }\n        }\n    }\n    \n    /**\n     * Gets source code with imports only (no metadata comments).\n     */\n    fun getCleanSourceCode(match: SourceCodeMatch): String {\n        val imports = if (match.imports.isNotEmpty()) {\n            match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n        } else \"\"\n        \n        val packageDeclaration = if (match.packageName != null) {\n            \"package ${match.packageName}\\n\\n\"\n        } else \"\"\n        \n        return packageDeclaration + imports + match.sourceCode\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findAndFormatSourceCode","startLine":23,"endLine":23,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findAndFormatSourceCode(","chunkType":"FUNCTION","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":28,"endLine":28,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findCleanSourceCode","startLine":40,"endLine":40,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findCleanSourceCode(","chunkType":"FUNCTION","tokens":64,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":45,"endLine":45,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findSourceCodeDetailed","startLine":58,"endLine":58,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findSourceCodeDetailed(","chunkType":"FUNCTION","tokens":64,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findAllMatches","startLine":74,"endLine":74,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findAllMatches(","chunkType":"FUNCTION","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":79,"endLine":79,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"exists","startLine":95,"endLine":95,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun exists(","chunkType":"FUNCTION","tokens":60,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":100,"endLine":100,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findInPackage","startLine":113,"endLine":113,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findInPackage(","chunkType":"FUNCTION","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":119,"endLine":119,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":126,"endLine":128,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n                    val filteredMatches = result.matches.filter { \n                        it.packageName?.contains(packageName) == true \n                    }","chunkType":"PROPERTY","tokens":94,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":140,"endLine":142,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n                    val filteredMatches = result.matches.filter { \n                        it.packageName?.contains(packageName) == true \n                    }","chunkType":"PROPERTY","tokens":94,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":52,"endLine":201,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n    private val clientOut = PipedOutputStream()\n    private val serverIn = PipedInputStream(clientOut)\n    private val serverOut = PipedOutputStream()\n    private val clientIn = PipedInputStream(serverOut)\n    private val clientTransport = StdioClientTransport(\n        input = clientIn.asSource().buffered(),\n        output = clientOut.asSink().buffered()\n    )\n    private val serverTransport = StdioServerTransport(\n        inputStream = serverIn.asSource().buffered(),\n        outputStream = serverOut.asSink().buffered()\n    )\n    val httpClient = createHttpClient()\n\n    private val server = Server(\n        serverInfo = Implementation(\n            name = \"example-server\",\n            version = \"1.0.0\"\n        ),\n        options = ServerOptions(\n            capabilities = ServerCapabilities(\n                resources = ServerCapabilities.Resources(\n                    subscribe = true,\n                    listChanged = true\n                ),\n                tools = ServerCapabilities.Tools(true),\n            )\n        )\n    )\n    private val client = Client(\n        clientInfo = Implementation(\n            name = \"example-client\",\n            version = \"1.0.0\"\n        )\n    )\n    private var tools: List<Tool> = emptyList()\n\n    init {\n        initTools()\n    }\n\n    suspend fun init() {\n        server.connect(serverTransport)\n        client.connect(clientTransport)\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n    }\n\n    suspend fun release(): List<TextContent>? {\n        // if server is active\n        val owner = \"NikitaFrankov\"\n        val repo = \"MindWeaverStudio\"\n        val version = \"v0.0.1\"\n        val changelog = \"Simple changelog\"\n\n        val arguments = buildJsonObject {\n            put(\"owner\", owner)\n            put(\"repo\", repo)\n            put(\"version\", version)\n            put(\"changelog\", changelog)\n        }\n\n        val request = CallToolRequest(\n            name = \"create_release\",\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        return result?.content as List<TextContent>?\n    }\n\n    suspend fun generateReleaseInfo(): List<TextContent>? {\n        val request = CallToolRequest(\n            name = \"generate_release_info\",\n        )\n\n        val result = client.callTool(request)\n\n        return result?.content as List<TextContent>?\n    }\n\n    suspend fun getTools(): List<Tool> {\n        if (tools.isNotEmpty()) return tools\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n        return tools\n    }\n\n    suspend fun callTool(call: ToolCall): List<TextContent>? {\n        logReceiver.emitNewValue(\"Agent call tool:\\n$call\".createInfoLogEntry())\n\n        val arguments = buildJsonObject {\n            call.params.forEach {\n                put(it.key, it.value)\n            }\n        }\n\n        val request = CallToolRequest(\n            name = call.tool,\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        logReceiver.emitNewValue(\"result from tool ${call.tool} - ${result?.content}\".createInfoLogEntry())\n\n        return result?.content as List<TextContent>?\n    }\n\n    private fun createHttpClient() = HttpClient(CIO) {\n        install(ContentNegotiation) {\n            json(\n                Json {\n                    ignoreUnknownKeys = true\n                    prettyPrint = true\n                }\n            )\n        }\n\n        install(Logging) {\n            level = LogLevel.INFO\n        }\n\n        defaultRequest {\n            url {\n                protocol = URLProtocol.HTTPS\n                host = \"api.github.com\"\n            }\n\n            val token = apiConfig.githubApiKey\n            if (token.isNotEmpty()) {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            header(\"Accept\", \"application/vnd.github+json\")\n        }\n    }\n\n    private fun initTools() {\n        server.addTool(\n            name = \"get_commits\",\n            description = \"Get list of commits for a GitHub repository. Input is owner (username or organization) and repo name (e.g. octocat, Hello-World)\",\n            inputSchema = Tool.Input(\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":195,"endLine":351,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n    }\n\n    private fun initTools() {\n        server.addTool(\n            name = \"get_commits\",\n            description = \"Get list of commits for a GitHub repository. Input is owner (username or organization) and repo name (e.g. octocat, Hello-World)\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"owner\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"GitHub username or organization (e.g. octocat)\")\n                    }\n                    putJsonObject(\"repo\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Repository name (e.g. Hello-World)\")\n                    }\n                },\n                required = listOf(\"owner\", \"repo\")\n            )\n        ) { request ->\n            val owner = request.arguments[\"owner\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'owner' parameter is required.\"))\n            )\n            val repo = request.arguments[\"repo\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'repo' parameter is required.\"))\n            )\n            val commits = httpClient.getCommits(owner, repo)\n            CallToolResult(content = commits.map { TextContent(it) })\n        }\n\n        server.addTool(\n            name = \"generate_release_info\",\n            description = \"Generate next release version and changelog based on commits since last release.\",\n            inputSchema = Tool.Input()\n        ) { request ->\n            val owner = \"NikitaFrankov\" // Добавить потом извлечение из конфигурационного файла\n            val repo = \"MindWeaverStudio\" // Добавить потом извлечение из конфигурационного файла\n\n            try {\n                val (version, changelog) = generateReleaseInfo(owner, repo, apiConfig.githubApiKey)\n\n                CallToolResult(\n                    content = listOf(\n                        TextContent(\"version: $version,\\nchangelog:$changelog\"),\n                    )\n                )\n            } catch (e: Exception) {\n                CallToolResult(content = listOf(TextContent(\"Failed to generate release info: ${e.message}\")))\n            }\n        }\n\n        server.addTool(\n            name = \"create_release\",\n            description = \"Create a new GitHub release. Input includes version (tag), and  changelog.\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"version\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Release version or tag (e.g. v1.2.0)\")\n                    }\n                    putJsonObject(\"changelog\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Release description or changelog (Markdown supported)\")\n                    }\n                },\n                required = listOf(\"version\", \"changelog\")\n            )\n        ) { request ->\n            try {\n                val version = request.arguments[\"version\"]?.jsonPrimitive?.content\n                    ?: return@addTool CallToolResult(\n                        content = listOf(TextContent(\"The 'version' parameter is required.\"))\n                    )\n                val changelog = request.arguments[\"changelog\"]?.jsonPrimitive?.content\n                    ?: return@addTool CallToolResult(\n                        content = listOf(TextContent(\"The 'changelog' parameter is required.\"))\n                    )\n\n                val result = triggerReleaseWorkflow(\n                    owner = \"NikitaFrankov\",\n                    repo = \"MindWeaverStudio\",\n                    version = version,\n                    changelog = changelog,\n                    token = apiConfig.githubApiKey,\n                    client = httpClient\n                )\n\n                if (result.success) {\n                    CallToolResult(\n                        content = listOf(TextContent(\"Release $version created successfully! URL: ${result.url}\"))\n                    )\n                } else {\n                    CallToolResult(\n                        content = listOf(TextContent(\"Failed to create release: ${result.errorMessage}\"))\n                    )\n                }\n            } catch (e: Exception) {\n                e.printStackTrace()\n                CallToolResult(content = listOf(TextContent(\"Exception in create_release: ${e.message}\")))\n            }\n        }\n    }\n\n    suspend fun generateReleaseInfo(\n        owner: String,\n        repo: String,\n        token: String\n    ): Pair<String, String> { // (newVersion, changelog)\n        // 1. Узнаем последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer $token\")\n        }\n\n        val lastTag = if (lastReleaseResp.status.isSuccess()) {\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n        } else {\n            \"v0.0.0\"\n        }\n\n        // 2. Сравнение изменений с main\n        val commitMessages = getCommitsSinceLastRelease(\n            owner = owner,\n            repo = repo,\n            token = apiConfig.githubApiKey,\n        )\n\n        // 3. Генерация версии (patch bump)\n        val versionParts = lastTag.removePrefix(\"v\").split(\".\").map { it.toInt() }.toMutableList()\n        versionParts[2] += 1 // patch bump\n        val newVersion = \"v${versionParts.joinToString(\".\")}\"\n\n        // 4. Генерация changelog\n        val changelog = commitMessages.joinToString(\"\\n\") { \"- $it\" }\n\n        return newVersion to changelog\n    }\n\n    suspend fun getCommitsSinceLastRelease(\n        owner: String,\n        repo: String,\n        token: String\n    ): List<String> {\n        // 1. Пытаемся найти последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer $token\")\n        }\n\n        return if (lastReleaseResp.status.isSuccess()) {\n            // Есть релиз → берём diff по тегу\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            val lastTag = json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n\n            val compareResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/compare/$lastTag...main\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(compareResp.bodyAsText()).jsonObject\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":345,"endLine":426,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            val lastTag = json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n\n            val compareResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/compare/$lastTag...main\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(compareResp.bodyAsText()).jsonObject\n            val commits = commitsJson[\"commits\"]?.jsonArray ?: JsonArray(emptyList())\n\n            commits.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        } else {\n            // Релизов нет → берём ВСЕ коммиты в main\n            val commitsResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/commits\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(commitsResp.bodyAsText()).jsonArray\n            commitsJson.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        }\n    }\n\n    private suspend fun triggerReleaseWorkflow(\n        owner: String,\n        repo: String,\n        version: String,\n        changelog: String,\n        token: String,\n        client: HttpClient,\n    ): CreateReleaseResult {\n        return try {\n            val response = client.post(\"https://api.github.com/repos/$owner/$repo/actions/workflows/release.yml/dispatches\") {\n                header(\"Authorization\", \"Bearer $token\")\n                header(\"Accept\", \"application/vnd.github+json\")\n                contentType(ContentType.Application.Json)\n                setBody(\n                    buildJsonObject {\n                        put(\"ref\", \"main\")\n                        putJsonObject(\"inputs\") {\n                            put(\"version\", version)\n                            put(\"changelog\", changelog)\n                        }\n                    }\n                )\n            }\n\n            if (response.status.value == 204) {\n                CreateReleaseResult(\n                    success = true,\n                    url = \"Release version $version successfully registered, .dmg file is currently being created.\"\n                )\n            } else {\n                CreateReleaseResult(\n                    success = false,\n                    errorMessage = \"GitHub API returned status ${response.status.value}: ${response.bodyAsText()}\"\n                )\n            }\n        } catch (e: Exception) {\n            CreateReleaseResult(success = false, errorMessage = e.message)\n        }\n    }\n\n    private suspend fun HttpClient.getCommits(owner: String, repo: String): List<String> {\n        val uri = \"/repos/$owner/$repo/commits\"\n        val commits = get(uri).body<List<Commit>>()\n        return commits.map { commit ->\n            \"\"\"\n            SHA: ${commit.sha}\n            Message: ${commit.commit.message}\n            Author: ${commit.commit.author.name} (${commit.commit.author.email})\n            Date: ${commit.commit.author.date}\n        \"\"\".trimIndent()\n        }\n    }\n\n}\n","chunkType":"SUB_CHUNK","tokens":859,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/DockerMCPClient.kt","className":null,"methodName":null,"startLine":32,"endLine":181,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: DockerMCPClient\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n    private val clientOut = PipedOutputStream()\n    private val serverIn = PipedInputStream(clientOut)\n    private val serverOut = PipedOutputStream()\n    private val clientIn = PipedInputStream(serverOut)\n    private val clientTransport = StdioClientTransport(\n        input = clientIn.asSource().buffered(),\n        output = clientOut.asSink().buffered()\n    )\n    private val serverTransport = StdioServerTransport(\n        inputStream = serverIn.asSource().buffered(),\n        outputStream = serverOut.asSink().buffered()\n    )\n\n    private val server = Server(\n        serverInfo = Implementation(\n            name = \"example-server\",\n            version = \"1.0.0\"\n        ),\n        options = ServerOptions(\n            capabilities = ServerCapabilities(\n                resources = ServerCapabilities.Resources(\n                    subscribe = true,\n                    listChanged = true\n                ),\n                tools = ServerCapabilities.Tools(true),\n            )\n        )\n    )\n    private val client = Client(\n        clientInfo = Implementation(\n            name = \"example-client\",\n            version = \"1.0.0\"\n        )\n    )\n    private var tools: List<Tool> = emptyList()\n\n    init {\n        server.addTool(\n            name = \"run_junit_tests\",\n            description = \"Run JUnit tests on a given Kotlin source code file using provided test code in a isolated Docker container. The tool creates a full Java/Kotlin environment with Gradle and JUnit dependencies, compiles the code, and executes the tests. If tests succeed, saves the test code as a file in the same directory as the source file, named after the test class (e.g., MyTest.kt). Input is the file path to the source code and the test code as a string.\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"file_path\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"The file system path to the Kotlin source code file to be tested (e.g., /path/to/MyClass.kt)\")\n                    }\n                    putJsonObject(\"test_code\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"The Kotlin test code using JUnit (e.g., a class with @Test annotations). Included all necessary imports.\")\n                    }\n                },\n                required = listOf(\"file_path\", \"test_code\")\n            )\n        ) { request ->\n            val filePath = request.arguments[\"file_path\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'file_path' parameter is required.\"))\n            )\n            val testCode = request.arguments[\"test_code\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'test_code' parameter is required.\"))\n            )\n\n            // Step 1: Validate and read the source file\n            val sourceFile = File(filePath)\n            if (!sourceFile.exists() || !sourceFile.isFile) {\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"The provided file_path does not point to a valid file.\"))\n                )\n            }\n            val sourceCode = try {\n                sourceFile.readText()\n            } catch (e: Exception) {\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error reading the source file: ${e.message}\"))\n                )\n            }\n\n            // Step 2: Create a temporary directory for the project\n            val tempDir = Files.createTempDirectory(\"junit_test_project_\").toFile()\n            tempDir.deleteOnExit()\n\n            // Step 3: Set up project structure\n            // Create src/main/kotlin/Source.kt (assuming the source is a single file; adjust if needed)\n            val mainSrcDir = File(tempDir, \"src/main/kotlin\")\n            mainSrcDir.mkdirs()\n            val sourceFileName = sourceFile.name // Preserve original file name\n            File(mainSrcDir, sourceFileName).writeText(sourceCode)\n\n            // Create src/test/kotlin/Test.kt\n            val testSrcDir = File(tempDir, \"src/test/kotlin\")\n            testSrcDir.mkdirs()\n            val testFileName = \"Test.kt\" // Temporary name inside container\n            File(testSrcDir, testFileName).writeText(testCode)\n\n            // Create build.gradle for Kotlin + JUnit setup\n            val buildGradleContent = \"\"\"\n        plugins {\n            id 'org.jetbrains.kotlin.jvm' version '1.9.0'\n            id 'application'\n        }\n\n        group = 'com.example'\n        version = '1.0-SNAPSHOT'\n\n        repositories {\n            mavenCentral()\n        }\n\n        dependencies {\n            implementation 'org.jetbrains.kotlin:kotlin-stdlib'\n            testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'\n            testImplementation 'org.jetbrains.kotlin:kotlin-test'\n        }\n\n        test {\n            useJUnitPlatform()\n        }\n    \"\"\".trimIndent()\n            File(tempDir, \"build.gradle\").writeText(buildGradleContent)\n\n            // Create settings.gradle (required for Gradle)\n            File(tempDir, \"settings.gradle\").writeText(\"rootProject.name = 'junit_test_project'\")\n\n            // Pre-pull Docker image quietly to avoid verbose pull output in main run\n            val pullCommand = listOf(\"docker\", \"pull\", \"--quiet\", \"gradle:8.0-jdk17\")\n            val pullProcessBuilder = ProcessBuilder(pullCommand)\n            val pullProcess = try {\n                pullProcessBuilder.start()\n            } catch (e: Exception) {\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error pulling Docker image: ${e.message}. Ensure Docker is installed and running.\"))\n                )\n            }\n            pullProcess.waitFor()\n            if (pullProcess.exitValue() != 0) {\n                val pullError = BufferedReader(InputStreamReader(pullProcess.errorStream)).use { it.readText() }\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Failed to pull Docker image: $pullError\"))\n                )\n            }\n\n            // Step 4: Run Docker container with Gradle image\n            // Add --info for detailed test logging\n            val dockerCommand = listOf(\n                \"docker\", \"run\", \"--rm\",\n                \"-v\", \"${tempDir.absolutePath}:/project\",\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.models.mcp.base.ToolCall","com.example.mindweaverstudio.data.receivers.CodeEditorLogReceiver"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/DockerMCPClient.kt","className":null,"methodName":null,"startLine":175,"endLine":283,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: DockerMCPClient\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n\n            }\n\n            // Step 4: Run Docker container with Gradle image\n            // Add --info for detailed test logging\n            val dockerCommand = listOf(\n                \"docker\", \"run\", \"--rm\",\n                \"-v\", \"${tempDir.absolutePath}:/project\",\n                \"-w\", \"/project\",\n                // Используем gradle + jdk17 образ с полноценным Debian\n                \"gradle:8.5-jdk17\",\n                \"gradle\", \"clean\", \"test\", \"--no-daemon\", \"--console=plain\", \"--info\"\n            )\n\n            val processBuilder = ProcessBuilder(dockerCommand)\n            processBuilder.redirectErrorStream(true) // Merge stderr into stdout\n            val process = try {\n                processBuilder.start()\n            } catch (e: Exception) {\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error starting Docker process: ${e.message}. Ensure Docker is installed and running.\"))\n                )\n            }\n\n            // Capture output\n            val output = StringBuilder()\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                output.append(line).append(\"\\n\")\n            }\n            process.waitFor()\n\n            // Filter output to minimal useful info: start from first task line\n            val lines = output.toString().lines()\n            val startIndex = lines.indexOfFirst { it.startsWith(\">\") }\n            val filteredOutput = if (startIndex >= 0) {\n                lines.subList(startIndex, lines.size).joinToString(\"\\n\")\n            } else {\n                output.toString() // Fallback if no tasks found (e.g., early error)\n            }\n\n            // Clean up temp dir\n            tempDir.deleteRecursively()\n\n            // Step 5: Check if tests succeeded and save test code if yes\n            val exitValue = process.exitValue()\n            var resultContent = if (exitValue == 0) {\n                // Extract test class name from test_code using regex\n                val classNameRegex = Regex(\"\"\"class\\s+(\\w+)\\s*(?:\\{|:)\"\"\")\n                val match = classNameRegex.find(testCode)\n                val testClassName = match?.groupValues?.get(1) ?: \"GeneratedTest\" // Fallback if not found\n\n                // Save test code to file in source directory\n                val sourceDir = sourceFile.parentFile\n                println(\"info bout source file,  parentFile = ${sourceFile.parentFile}, absoluteFile = ${sourceFile.absoluteFile}, absolutePath = ${sourceFile.absolutePath}\")\n                val testOutputFile = File(sourceDir, \"$testClassName.kt\")\n                try {\n                    testOutputFile.writeText(testCode)\n                    \"Tests executed successfully. Test code saved to ${testOutputFile.absolutePath}.\\nOutput:\\n$filteredOutput\"\n                } catch (e: Exception) {\n                    \"Tests executed successfully, but error saving test file: ${e.message}.\\\\nOutput:\\\\n$filteredOutput\"\n                }\n            } else {\n                \"Tests failed with exit code $exitValue.\\nOutput:\\n$filteredOutput\"\n            }\n\n            CallToolResult(content = listOf(TextContent(resultContent)))\n        }\n    }\n\n    suspend fun init() {\n        server.connect(serverTransport)\n        client.connect(clientTransport)\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n    }\n\n    suspend fun getTools(): List<Tool> {\n        if (tools.isNotEmpty()) return tools\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n        return tools\n    }\n\n    suspend fun callTool(call: ToolCall): List<TextContent>? {\n        logReceiver.emitNewValue(\"Agent call tool:\\n$call\".createInfoLogEntry())\n\n        val arguments = buildJsonObject {\n            call.params.forEach {\n                put(it.key, it.value)\n            }\n        }\n\n        // Вызов tool\n        val request = CallToolRequest(\n            name = call.tool,\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        logReceiver.emitNewValue(\"result from tool ${call.tool} - ${result?.content}\".createInfoLogEntry())\n\n        return result?.content as List<TextContent>?\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.models.mcp.base.ToolCall","com.example.mindweaverstudio.data.receivers.CodeEditorLogReceiver"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/github/CreateReleaseResult.kt","className":null,"methodName":null,"startLine":3,"endLine":7,"content":"package com.example.mindweaverstudio.data.models.mcp.github\n\nclass CreateReleaseResult(\n    val success: Boolean,\n    val url: String? = null,\n    val errorMessage: String? = null\n)","chunkType":"CLASS","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.github","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/github/CommitData.kt","className":null,"methodName":null,"startLine":6,"endLine":22,"content":"package com.example.mindweaverstudio.data.models.mcp.github\n\nimport kotlinx.serialization.Serializable\n\ndata class Commit(\n    val sha: String,\n    val commit: CommitDetails\n)\n\n@Serializable\ndata class CommitDetails(\n    val author: Author,\n    val message: String\n)\n\n@Serializable\ndata class Author(\n    val name: String,\n    val email: String,\n    val date: String\n)","chunkType":"CLASS","tokens":92,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.github","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/base/ToolType.kt","className":null,"methodName":null,"startLine":3,"endLine":15,"content":"package com.example.mindweaverstudio.data.models.mcp.base\n\nenum class ToolType(val value: String) {\n    UNKNOWN(\"unknown\"),\n    FETCH_COMMITS(\"fetch_commits\"),\n    RUN_PROJECT_CONTAINER(\"run_project_container\");\n\n    companion object {\n        fun valueeOf(name: String): ToolType = when(name) {\n            FETCH_COMMITS.value -> FETCH_COMMITS\n            RUN_PROJECT_CONTAINER.value -> RUN_PROJECT_CONTAINER\n            else -> UNKNOWN\n        }\n    }\n}","chunkType":"CLASS","tokens":113,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.base","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/base/ToolCall.kt","className":null,"methodName":null,"startLine":6,"endLine":12,"content":"package com.example.mindweaverstudio.data.models.mcp.base\n\nimport kotlinx.serialization.Serializable\n\ndata class ToolCall(\n    val action: String,\n    val tool: String,\n    val params: Map<String, String> = emptyMap(),\n    val isError: Boolean = false,\n    val errorMessage: String? = null,\n)","chunkType":"CLASS","tokens":73,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.base","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":6,"endLine":28,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\ndata class UserPersonalization(\n    val name: String = \"User\",\n    val role: WorkRole = WorkRole.DEVELOPER,\n    val preferredLanguage: String = \"Kotlin\",\n    val responseFormat: ResponseFormat = ResponseFormat.MARKDOWN,\n    val experienceLevel: ExperienceLevel = ExperienceLevel.INTERMEDIATE,\n    val timeZone: String = \"UTC\",\n    val habits: List<String> = emptyList(),\n    val preferences: Map<String, String> = emptyMap(),\n    val history: List<String> = emptyList()\n)\n\n@Serializable\nenum class WorkRole(val displayName: String) {\n    DEVELOPER(\"Developer\"),\n    MANAGER(\"Manager\"),\n    DESIGNER(\"Designer\"),\n    QA_ENGINEER(\"QA Engineer\"),\n    DEVOPS(\"DevOps Engineer\"),\n    ARCHITECT(\"Architect\"),\n    STUDENT(\"Student\"),\n    OTHER(\"Other\")\n}","chunkType":"CLASS","tokens":212,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":31,"endLine":34,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\nenum class ResponseFormat(val displayName: String) {\n    MARKDOWN(\"Markdown\"),\n    PLAIN_TEXT(\"Plain Text\")\n}","chunkType":"CLASS","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":37,"endLine":42,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\nenum class ExperienceLevel(val displayName: String) {\n    BEGINNER(\"Beginner\"),\n    INTERMEDIATE(\"Intermediate\"),\n    ADVANCED(\"Advanced\"),\n    EXPERT(\"Expert\")\n}","chunkType":"CLASS","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/ai/memory/ProjectContext.kt","className":null,"methodName":null,"startLine":9,"endLine":9,"content":"package com.example.mindweaverstudio.data.models.ai.memory\n\nimport ai.koog.agents.memory.model.MemorySubject\nimport kotlinx.serialization.Serializable\n\n    override val promptDescription = \"Active development project context\"","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.ai.memory","imports":["ai.koog.agents.memory.model.MemorySubject","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/ai/Role.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.data.models.ai\n\nenum class Role {\n    ADMIN, USER, GUEST\n}","chunkType":"CLASS","tokens":23,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.ai","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/receivers/CodeEditorLogReceiver.kt","className":null,"methodName":null,"startLine":8,"endLine":15,"content":"package com.example.mindweaverstudio.data.receivers\n\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\nimport kotlinx.coroutines.flow.MutableSharedFlow\n\nclass CodeEditorLogReceiver {\n    private var _logFlow: MutableSharedFlow<LogEntry> = MutableSharedFlow()\n    val logFlow: SharedFlow<LogEntry> = _logFlow.asSharedFlow()\n\n    suspend fun emitNewValue(value: LogEntry) {\n        _logFlow.emit(value)\n    }\n}","chunkType":"CLASS","tokens":108,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.receivers","imports":["com.example.mindweaverstudio.components.codeeditor.models.LogEntry","kotlinx.coroutines.flow.MutableSharedFlow","kotlinx.coroutines.flow.SharedFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":null,"startLine":8,"endLine":12,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    private val json = Json {\n        prettyPrint = true\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }","chunkType":"PROPERTY","tokens":73,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":null,"startLine":13,"endLine":16,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    private val configFile = File(System.getProperty(\"user.home\") + \"/MindWeaverStudio/user_config.json\").apply {\n        parentFile.mkdirs()  // Создаём директорию, если нет\n        if (!exists()) createNewFile()  // Создаём пустой файл\n    }","chunkType":"PROPERTY","tokens":102,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"load","startLine":18,"endLine":25,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun load(): UserPersonalization {\n        val content = configFile.readText()\n        return if (content.isNotBlank()) {\n            json.decodeFromString(UserPersonalization.serializer(), content)\n        } else {\n            UserPersonalization()  // Дефолтные значения\n        }\n    }","chunkType":"FUNCTION","tokens":114,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"loadJsonConfig","startLine":27,"endLine":27,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun loadJsonConfig(): String = json.encodeToString(UserPersonalization.serializer(), load())","chunkType":"FUNCTION","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"save","startLine":29,"endLine":31,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun save(config: UserPersonalization) {\n        configFile.writeText(json.encodeToString(UserPersonalization.serializer(), config))\n    }","chunkType":"FUNCTION","tokens":77,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}}]}