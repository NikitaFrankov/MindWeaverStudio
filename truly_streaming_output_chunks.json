{"metadata":{"generatedAt":"2025-09-07T21:46:46.986334","isStreaming":true},"chunks":[{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/app/App.kt","className":null,"methodName":"App","startLine":21,"endLine":28,"content":"package com.example.mindweaverstudio.ui.app\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\n\nfun App(component: RootComponent) {\n    MindWeaverTheme {\n        RootContent(\n            component = component,\n            modifier = Modifier.background(MindWeaverTheme.colors.rootBackground)\n        )\n    }\n}","chunkType":"FUNCTION","tokens":87,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.app","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.*","androidx.compose.material3.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/app/App.kt","className":null,"methodName":"RootContent","startLine":32,"endLine":49,"content":"package com.example.mindweaverstudio.ui.app\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\n\nfun RootContent(component: RootComponent, modifier: Modifier = Modifier) {\n    Scaffold(\n        modifier = modifier,\n    ) { innerPadding ->\n        Children(\n            stack = component.stack,\n            modifier = modifier.padding(innerPadding),\n            animation = stackAnimation(animator = fade())\n        ) {\n            when (val child = it.instance) {\n                is Child.Authentication -> AuthenticationScreen(child.component)\n                is Child.ProjectSelection -> ProjectSelectionScreen(child.component)\n                is Child.CodeEditor -> CodeEditorScreen(child.component)\n                is Child.UserConfiguration -> UserConfigurationScreen(child.component)\n            }\n        }\n    }\n}","chunkType":"FUNCTION","tokens":215,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.app","imports":["androidx.compose.foundation.background","androidx.compose.foundation.layout.*","androidx.compose.material3.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarScreen","startLine":27,"endLine":34,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nfun SidebarScreen(component: SidebarComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    SidebarScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":86,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarScreen","startLine":37,"endLine":37,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarScreen(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarHeader","startLine":90,"endLine":90,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarHeader(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/sidebar/SidebarScreen.kt","className":null,"methodName":"SidebarMenuItemRow","startLine":118,"endLine":118,"content":"package com.example.mindweaverstudio.ui.screens.sidebar\n\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.background\n\nprivate fun SidebarMenuItemRow(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.sidebar","imports":["androidx.compose.animation.*","androidx.compose.foundation.background","androidx.compose.foundation.clickable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"UserConfigurationScreen","startLine":25,"endLine":33,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nfun UserConfigurationScreen(component: UserConfigurationComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    UserConfigurationScreen(\n        state = state,\n        intentHandler = component::onIntent,\n        onBackPressed = component::onBackPressed\n    )\n}","chunkType":"FUNCTION","tokens":111,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"UserConfigurationScreen","startLine":37,"endLine":37,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun UserConfigurationScreen(","chunkType":"FUNCTION","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":183,"endLine":183,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val role = WorkRole.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":214,"endLine":214,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val level = ExperienceLevel.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":67,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":228,"endLine":228,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n                            val format = ResponseFormat.entries.find { it.displayName == selectedDisplayName }","chunkType":"PROPERTY","tokens":67,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"ConfigurationSection","startLine":282,"endLine":282,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun ConfigurationSection(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":"DropdownField","startLine":311,"endLine":311,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\nprivate fun DropdownField(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/userconfiguration/UserConfigurationScreen.kt","className":null,"methodName":null,"startLine":317,"endLine":317,"content":"package com.example.mindweaverstudio.ui.screens.userconfiguration\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.background\n\n    var expanded by remember { mutableStateOf(false) }","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.userconfiguration","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.background","androidx.compose.foundation.rememberScrollState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":"SyntaxHighlightedEditor","startLine":21,"endLine":21,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\nfun SyntaxHighlightedEditor(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":null,"startLine":27,"endLine":27,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\n    var text by remember { mutableStateOf(initialContent) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/SyntaxHighlightedEditor.kt","className":null,"methodName":null,"startLine":29,"endLine":94,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.Composable\n\n    val textArea = remember {\n        RSyntaxTextArea().apply {\n            syntaxEditingStyle = if (isKotlin) SyntaxConstants.SYNTAX_STYLE_JAVA else SyntaxConstants.SYNTAX_STYLE_GROOVY\n            isCodeFoldingEnabled = true\n            antiAliasingEnabled = true\n            isBracketMatchingEnabled = true\n            font = java.awt.Font(\"JetBrains Mono\", java.awt.Font.PLAIN, 14)\n\n            // Тема Atom One Dark (адаптирована под доступные token types)\n            val theme = Theme(this).apply {\n                bgColor = java.awt.Color.decode(\"#282c34\") // Background\n                caretColor = java.awt.Color.decode(\"#528bff\") // Caret\n                currentLineHighlightColor = java.awt.Color.decode(\"#2c323c\")\n                fadeCurrentLineHighlight = true\n\n                // Цвета для токенов (расширенные для большего количества типов)\n                baseFont = font // Monospace\n//                baseStyle = Style().withForeground(java.awt.Color.decode(\"#abb2bf\")) // Default text\n//\n//                // Keywords (val, fun ~ reserved words in Java)\n//                keyword = Style().withForeground(java.awt.Color.decode(\"#c678dd\")).withBold(true)\n//\n//                // Identifiers (variables)\n//                identifier = Style().withForeground(java.awt.Color.decode(\"#abb2bf\"))\n//\n//                // Data types/classes\n//                dataType = Style().withForeground(java.awt.Color.decode(\"#e5c07b\"))\n//\n//                // Functions (обрабатываются как identifiers, но можно override в custom если нужно)\n//                function = Style().withForeground(java.awt.Color.decode(\"#61afef\"))\n//\n//                // Strings\n//                literalString = Style().withForeground(java.awt.Color.decode(\"#98c379\"))\n//\n//                // Numbers/literals\n//                literalNumber = Style().withForeground(java.awt.Color.decode(\"#d19a66\"))\n//\n//                // Operators\n//                operator = Style().withForeground(java.awt.Color.decode(\"#56b6c2\"))\n//\n//                // Comments\n//                comment = Style().withForeground(java.awt.Color.decode(\"#5c6370\")).withItalic(true)\n//                commentMultiline = Style().withForeground(java.awt.Color.decode(\"#5c6370\")).withItalic(true)\n//\n//                // Annotations (@)\n//                annotation = Style().withForeground(java.awt.Color.decode(\"#e5c07b\"))\n//\n//                // Errors\n//                errorIdentifier = Style().withForeground(java.awt.Color.decode(\"#e06c75\")).withUnderline(true)\n\n                // Brackets/marks\n                matchedBracketBorderColor = java.awt.Color.decode(\"#3a3f4b\")\n                matchedBracketFG = java.awt.Color.decode(\"#abb2bf\")\n                matchedBracketBG = java.awt.Color.decode(\"#3a3f4b\")\n            }\n            theme.apply(this)\n\n            this.text = initialContent\n\n            document.addDocumentListener(object : DocumentListener {\n                override fun insertUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n                override fun removeUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n                override fun changedUpdate(e: DocumentEvent?) { text = this@apply.text; onContentChanged(text) }\n            })\n        }\n    }","chunkType":"PROPERTY","tokens":862,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.layout.fillMaxSize","androidx.compose.runtime.Composable","androidx.compose.runtime.DisposableEffect"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"CodeEditorScreen","startLine":45,"endLine":53,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nfun CodeEditorScreen(component: CodeEditorComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n\n    CodeEditorScreen(\n        state = state,\n        intentHandler = component::onIntent,\n        onNavigateToUserConfiguration = component::onNavigateToUserConfiguration\n    )\n}","chunkType":"FUNCTION","tokens":114,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"CodeEditorScreen","startLine":57,"endLine":57,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun CodeEditorScreen(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":65,"endLine":70,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    val menuActionHandler = remember {\n        MenuActionHandler(\n            onEditorIntent = intentHandler,\n            onNavigateToUserConfiguration = onNavigateToUserConfiguration\n        )\n    }","chunkType":"PROPERTY","tokens":90,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":72,"endLine":72,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var leftPanelWidth by remember { mutableStateOf(250.dp) }","chunkType":"PROPERTY","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":73,"endLine":73,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var rightPanelWidth by remember { mutableStateOf(250.dp) }","chunkType":"PROPERTY","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":74,"endLine":74,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    var bottomPanelHeight by remember { mutableStateOf(100.dp) }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":84,"endLine":84,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n        val maxWidthDp = with(density) { constraints.maxWidth.toDp() }","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":106,"endLine":106,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dx = with(density) { drag.x.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":135,"endLine":135,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dx = with(density) { drag.x.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":167,"endLine":167,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n                        val dy = with(density) { drag.y.toDp() }","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ProjectTreePanel","startLine":187,"endLine":187,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ProjectTreePanel(","chunkType":"FUNCTION","tokens":47,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"FileNodeItem","startLine":229,"endLine":229,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun FileNodeItem(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"EditorPanel","startLine":314,"endLine":314,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun EditorPanel(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ChatPanel","startLine":350,"endLine":350,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ChatPanel(","chunkType":"FUNCTION","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"UserChatMessageItem","startLine":490,"endLine":523,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun UserChatMessageItem(message: UiChatMessage.UserMessage) {\n    val timeFormat = SimpleDateFormat(\"HH:mm\", Locale.getDefault())\n\n    Row(\n        modifier = Modifier.fillMaxWidth(),\n        horizontalArrangement = Arrangement.End\n    ) {\n        Card(\n            colors = CardDefaults.cardColors(\n                containerColor = MindWeaverTheme.colors.surface2\n            ),\n            modifier = Modifier.widthIn(max = 280.dp)\n        ) {\n            Column(\n                modifier = Modifier.padding(12.dp)\n            ) {\n                SelectionContainer {\n                    Text(\n                        text = message.content,\n                        style = MaterialTheme.typography.bodyMedium,\n                        color = MindWeaverTheme.colors.textPrimary\n                    )\n                }\n                Spacer(modifier = Modifier.height(4.dp))\n\n                Text(\n                    text = timeFormat.format(Date(message.timestamp)),\n                    style = MaterialTheme.typography.labelSmall,\n                    color = MindWeaverTheme.colors.textSecondary\n                )\n            }\n        }\n    }\n}","chunkType":"FUNCTION","tokens":329,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"AssistantChatMessageItem","startLine":526,"endLine":526,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun AssistantChatMessageItem(","chunkType":"FUNCTION","tokens":49,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":null,"startLine":530,"endLine":530,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\n    val timeFormat = SimpleDateFormat(\"HH:mm\", Locale.getDefault())","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"ThinkingChatMessageItem","startLine":575,"endLine":593,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun ThinkingChatMessageItem(message: UiChatMessage.ThinkingMessage) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(horizontal = 16.dp, vertical = 8.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        CircularProgressIndicator(\n            modifier = Modifier.size(16.dp),\n            strokeWidth = 2.dp\n        )\n        Spacer(modifier = Modifier.width(8.dp))\n        Text(\n            text = message.content,\n            style = MaterialTheme.typography.bodyMedium,\n            color = MindWeaverTheme.colors.textSecondary\n        )\n    }\n}","chunkType":"FUNCTION","tokens":194,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"LogsPanel","startLine":596,"endLine":596,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun LogsPanel(","chunkType":"FUNCTION","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/codeeditor/CodeEditorScreen.kt","className":null,"methodName":"LogEntryItem","startLine":637,"endLine":679,"content":"package com.example.mindweaverstudio.ui.screens.codeeditor\n\nimport androidx.compose.foundation.*\nimport androidx.compose.foundation.gestures.detectDragGestures\n\nprivate fun LogEntryItem(log: LogEntry) {\n    val timeFormat = SimpleDateFormat(\"HH:mm:ss\", Locale.getDefault())\n\n    Row(\n        modifier = Modifier.fillMaxWidth(),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = timeFormat.format(Date(log.timestamp)),\n            style = MaterialTheme.typography.labelSmall.copy(\n                fontFamily = FontFamily.Monospace\n            ),\n            color = MindWeaverTheme.colors.textSecondary,\n            modifier = Modifier.width(60.dp)\n        )\n        Spacer(modifier = Modifier.width(4.dp))\n\n        Text(\n            text = when (log.level) {\n                UiLogLevel.INFO -> \"ℹ️\"\n                UiLogLevel.WARNING -> \"⚠️\"\n                UiLogLevel.ERROR -> \"❌\"\n                UiLogLevel.DEBUG -> \"🐛\"\n            },\n            modifier = Modifier.width(24.dp)\n        )\n        Spacer(modifier = Modifier.width(4.dp))\n\n        SelectionContainer {\n            Text(\n                text = log.message,\n                style = MaterialTheme.typography.bodySmall.copy(\n                    fontFamily = FontFamily.Monospace\n                ),\n                color = when (log.level) {\n                    UiLogLevel.ERROR -> MindWeaverTheme.colors.error\n                    UiLogLevel.WARNING -> MindWeaverTheme.colors.warning\n                    else -> MindWeaverTheme.colors.textPrimary\n                }\n            )\n        }\n    }\n}","chunkType":"FUNCTION","tokens":401,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.codeeditor","imports":["androidx.compose.foundation.*","androidx.compose.foundation.gestures.detectDragGestures","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"ProjectSelectionScreen","startLine":25,"endLine":32,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nfun ProjectSelectionScreen(component: ProjectSelectionComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n    \n    ProjectSelectionScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":99,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"ProjectSelectionScreen","startLine":36,"endLine":36,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nprivate fun ProjectSelectionScreen(","chunkType":"FUNCTION","tokens":49,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":"RecentProjectCard","startLine":184,"endLine":184,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\nprivate fun RecentProjectCard(","chunkType":"FUNCTION","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":null,"startLine":189,"endLine":189,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\n    val dateFormat = remember { SimpleDateFormat(\"MMM dd, yyyy\", Locale.getDefault()) }","chunkType":"PROPERTY","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/projectselection/ProjectSelectionScreen.kt","className":null,"methodName":null,"startLine":190,"endLine":192,"content":"package com.example.mindweaverstudio.ui.screens.projectselection\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.foundation.lazy.LazyColumn\n\n    val formattedDate = remember(project.lastOpened) { \n        dateFormat.format(Date(project.lastOpened)) \n    }","chunkType":"PROPERTY","tokens":69,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.projectselection","imports":["androidx.compose.foundation.layout.*","androidx.compose.foundation.lazy.LazyColumn","androidx.compose.foundation.lazy.items"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":"AuthenticationScreen","startLine":23,"endLine":30,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nfun AuthenticationScreen(component: AuthenticationComponent) {\n    val state by component.state.collectAsStateWithLifecycle()\n    \n    AuthenticationScreen(\n        state = state,\n        intentHandler = component::onIntent\n    )\n}","chunkType":"FUNCTION","tokens":96,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":"AuthenticationScreen","startLine":34,"endLine":34,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nprivate fun AuthenticationScreen(","chunkType":"FUNCTION","tokens":46,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/screens/authentication/AuthenticationScreen.kt","className":null,"methodName":null,"startLine":38,"endLine":38,"content":"package com.example.mindweaverstudio.ui.screens.authentication\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\n    var isPasswordVisible by remember { mutableStateOf(false) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.screens.authentication","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.Email"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":"EditorMenuBar","startLine":22,"endLine":22,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\nfun EditorMenuBar(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\n    var openMenuId by remember { mutableStateOf<String?>(null) }","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorMenuBar.kt","className":null,"methodName":"MenuBarItem","startLine":59,"endLine":59,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.clickable\n\nprivate fun MenuBarItem(","chunkType":"FUNCTION","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.background","androidx.compose.foundation.clickable","androidx.compose.foundation.layout.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":null,"startLine":8,"endLine":10,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\nclass MenuActionHandler(\n    private val onEditorIntent: (CodeEditorStore.Intent) -> Unit,\n    private val onNavigateToUserConfiguration: () -> Unit = {}","chunkType":"CLASS","tokens":90,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"logAction","startLine":13,"endLine":19,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun logAction(message: String) {\n        val logEntry = LogEntry(\n            message = message,\n            level = UiLogLevel.INFO\n        )\n        onEditorIntent(CodeEditorStore.Intent.AddLogEntry(logEntry))\n    }","chunkType":"FUNCTION","tokens":109,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleAction","startLine":21,"endLine":29,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    fun handleAction(action: ToolbarAction) {\n        when (action) {\n            is ToolbarAction.MenuItemClicked -> handleMenuItemClick(action.menuId, action.itemId)\n            is ToolbarAction.MenuToggled -> {\n                // Menu toggle actions can be handled here if needed\n                // For now, we just track which menu is open in the component state\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":151,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleMenuItemClick","startLine":31,"endLine":39,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleMenuItemClick(menuId: String, itemId: String) {\n        when (menuId) {\n            \"FILE\" -> handleFileMenuAction(itemId)\n            \"EDIT\" -> handleEditMenuAction(itemId)\n            \"VIEW\" -> handleViewMenuAction(itemId)\n            \"TOOLS\" -> handleToolsMenuAction(itemId)\n            \"CONFIGURATION\" -> handleConfigurationMenuAction(itemId)\n        }\n    }","chunkType":"FUNCTION","tokens":148,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleFileMenuAction","startLine":41,"endLine":80,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleFileMenuAction(itemId: String) {\n        when (itemId) {\n            \"new_file\" -> {\n                // Log the action for now - could be extended to create new file\n                logAction(\"Creating new file...\")\n            }\n            \"open_file\" -> {\n                // Log the action for now - could be extended to open file dialog\n                logAction(\"Opening file dialog...\")\n            }\n            \"save\" -> {\n                // Could save current editor content\n                logAction(\"Saving current file...\")\n            }\n            \"save_as\" -> {\n                // Could open save as dialog\n                logAction(\"Opening Save As dialog...\")\n            }\n            \"save_all\" -> {\n                // Could save all open files\n                logAction(\"Saving all files...\")\n            }\n            \"close_file\" -> {\n                // Could close current file\n                logAction(\"Closing current file...\")\n            }\n            \"close_all\" -> {\n                // Could close all open files\n                logAction(\"Closing all files...\")\n            }\n            \"recent_files\" -> {\n                // Could show recent files menu\n                logAction(\"Showing recent files...\")\n            }\n            \"exit\" -> {\n                // Could exit the application\n                logAction(\"Exiting application...\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":409,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleEditMenuAction","startLine":82,"endLine":112,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleEditMenuAction(itemId: String) {\n        when (itemId) {\n            \"undo\" -> {\n                logAction(\"Undo operation performed\")\n            }\n            \"redo\" -> {\n                logAction(\"Redo operation performed\")\n            }\n            \"cut\" -> {\n                logAction(\"Text cut to clipboard\")\n            }\n            \"copy\" -> {\n                logAction(\"Text copied to clipboard\")\n            }\n            \"paste\" -> {\n                logAction(\"Text pasted from clipboard\")\n            }\n            \"select_all\" -> {\n                logAction(\"All text selected\")\n            }\n            \"find\" -> {\n                logAction(\"Find dialog opened\")\n            }\n            \"replace\" -> {\n                logAction(\"Replace dialog opened\")\n            }\n            \"find_in_files\" -> {\n                logAction(\"Find in Files dialog opened\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":283,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleViewMenuAction","startLine":114,"endLine":141,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleViewMenuAction(itemId: String) {\n        when (itemId) {\n            \"zoom_in\" -> {\n                logAction(\"Zooming in...\")\n            }\n            \"zoom_out\" -> {\n                logAction(\"Zooming out...\")\n            }\n            \"reset_zoom\" -> {\n                logAction(\"Zoom reset to 100%\")\n            }\n            \"fullscreen\" -> {\n                logAction(\"Toggled full screen mode\")\n            }\n            \"toggle_project\" -> {\n                logAction(\"Project tree panel visibility toggled\")\n            }\n            \"toggle_chat\" -> {\n                logAction(\"Chat panel visibility toggled\")\n            }\n            \"toggle_logs\" -> {\n                logAction(\"Logs panel visibility toggled\")\n            }\n            \"appearance\" -> {\n                logAction(\"Appearance settings opened\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":271,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleToolsMenuAction","startLine":143,"endLine":174,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleToolsMenuAction(itemId: String) {\n        when (itemId) {\n            \"terminal\" -> {\n                // TODO: Implement terminal\n                println(\"Terminal action\")\n            }\n            \"version_control\" -> {\n                // TODO: Implement version control\n                println(\"Version Control action\")\n            }\n            \"build\" -> {\n                // TODO: Implement build\n                println(\"Build Project action\")\n            }\n            \"run\" -> {\n                // TODO: Implement run\n                println(\"Run action\")\n            }\n            \"debug\" -> {\n                // TODO: Implement debug\n                println(\"Debug action\")\n            }\n            \"generate\" -> {\n                // TODO: Implement code generation\n                println(\"Generate Code action\")\n            }\n            \"database\" -> {\n                // TODO: Implement database tools\n                println(\"Database Tools action\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":306,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/MenuActionHandler.kt","className":null,"methodName":"handleConfigurationMenuAction","startLine":176,"endLine":207,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport com.example.mindweaverstudio.components.codeeditor.CodeEditorStore\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\n\n    private fun handleConfigurationMenuAction(itemId: String) {\n        when (itemId) {\n            \"user_configuration\" -> {\n                logAction(\"Opening User Configuration...\")\n                onNavigateToUserConfiguration()\n            }\n            \"plugins\" -> {\n                // TODO: Implement plugins\n                println(\"Plugins action\")\n            }\n            \"appearance_behavior\" -> {\n                // TODO: Implement appearance & behavior settings\n                println(\"Appearance & Behavior action\")\n            }\n            \"keymap\" -> {\n                // TODO: Implement keymap settings\n                println(\"Keymap action\")\n            }\n            \"import_settings\" -> {\n                // TODO: Implement import settings\n                println(\"Import Settings action\")\n            }\n            \"export_settings\" -> {\n                // TODO: Implement export settings\n                println(\"Export Settings action\")\n            }\n            \"about\" -> {\n                // TODO: Implement about dialog\n                println(\"About action\")\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":332,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["com.example.mindweaverstudio.components.codeeditor.CodeEditorStore","com.example.mindweaverstudio.components.codeeditor.models.LogEntry","com.example.mindweaverstudio.components.codeeditor.models.UiLogLevel"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/models/ToolbarMenu.kt","className":null,"methodName":null,"startLine":7,"endLine":105,"content":"package com.example.mindweaverstudio.ui.components.toolbar.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\ndata class ToolbarMenuItem(\n    val id: String,\n    val title: String,\n    val icon: ImageVector? = null,\n    val shortcut: String? = null,\n    val enabled: Boolean = true,\n    val separator: Boolean = false\n)\n\nenum class ToolbarMenu(\n    val title: String,\n    val items: List<ToolbarMenuItem>\n) {\n    FILE(\n        title = \"File\",\n        items = listOf(\n            ToolbarMenuItem(\"new_file\", \"New File\", Icons.Default.Add, \"Ctrl+N\"),\n            ToolbarMenuItem(\"open_file\", \"Open File\", Icons.Default.FolderOpen, \"Ctrl+O\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"save\", \"Save\", Icons.Default.Save, \"Ctrl+S\"),\n            ToolbarMenuItem(\"save_as\", \"Save As...\", Icons.Default.SaveAs, \"Ctrl+Shift+S\"),\n            ToolbarMenuItem(\"save_all\", \"Save All\", Icons.Default.Save, \"Ctrl+Alt+S\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"close_file\", \"Close File\", Icons.Default.Close, \"Ctrl+W\"),\n            ToolbarMenuItem(\"close_all\", \"Close All\", Icons.Default.CloseFullscreen, \"Ctrl+Shift+W\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"recent_files\", \"Recent Files\", Icons.Default.History),\n            ToolbarMenuItem(\"separator_4\", \"\", separator = true),\n            ToolbarMenuItem(\"exit\", \"Exit\", Icons.Default.ExitToApp, \"Ctrl+Q\")\n        )\n    ),\n    \n    EDIT(\n        title = \"Edit\",\n        items = listOf(\n            ToolbarMenuItem(\"undo\", \"Undo\", Icons.Default.Undo, \"Ctrl+Z\"),\n            ToolbarMenuItem(\"redo\", \"Redo\", Icons.Default.Redo, \"Ctrl+Y\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"cut\", \"Cut\", Icons.Default.ContentCut, \"Ctrl+X\"),\n            ToolbarMenuItem(\"copy\", \"Copy\", Icons.Default.ContentCopy, \"Ctrl+C\"),\n            ToolbarMenuItem(\"paste\", \"Paste\", Icons.Default.ContentPaste, \"Ctrl+V\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"select_all\", \"Select All\", Icons.Default.SelectAll, \"Ctrl+A\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"find\", \"Find\", Icons.Default.Search, \"Ctrl+F\"),\n            ToolbarMenuItem(\"replace\", \"Replace\", Icons.Default.FindReplace, \"Ctrl+H\"),\n            ToolbarMenuItem(\"find_in_files\", \"Find in Files\", Icons.Default.FolderOpen, \"Ctrl+Shift+F\")\n        )\n    ),\n    \n    VIEW(\n        title = \"View\",\n        items = listOf(\n            ToolbarMenuItem(\"zoom_in\", \"Zoom In\", Icons.Default.ZoomIn, \"Ctrl++\"),\n            ToolbarMenuItem(\"zoom_out\", \"Zoom Out\", Icons.Default.ZoomOut, \"Ctrl+-\"),\n            ToolbarMenuItem(\"reset_zoom\", \"Reset Zoom\", Icons.Default.CenterFocusStrong, \"Ctrl+0\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"fullscreen\", \"Toggle Full Screen\", Icons.Default.Fullscreen, \"F11\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"toggle_project\", \"Toggle Project Tree\", Icons.Default.AccountTree, \"Alt+1\"),\n            ToolbarMenuItem(\"toggle_chat\", \"Toggle Chat Panel\", Icons.Default.Chat, \"Alt+2\"),\n            ToolbarMenuItem(\"toggle_logs\", \"Toggle Logs Panel\", Icons.Default.Article, \"Alt+3\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"appearance\", \"Appearance\", Icons.Default.Palette)\n        )\n    ),\n    \n    TOOLS(\n        title = \"Tools\",\n        items = listOf(\n            ToolbarMenuItem(\"terminal\", \"Terminal\", Icons.Default.Terminal, \"Alt+F12\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"version_control\", \"Version Control\", Icons.Default.Source, \"Alt+9\"),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"build\", \"Build Project\", Icons.Default.Build, \"Ctrl+F9\"),\n            ToolbarMenuItem(\"run\", \"Run\", Icons.Default.PlayArrow, \"Shift+F10\"),\n            ToolbarMenuItem(\"debug\", \"Debug\", Icons.Default.BugReport, \"Shift+F9\"),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"generate\", \"Generate Code\", Icons.Default.AutoFixHigh, \"Alt+Insert\"),\n            ToolbarMenuItem(\"database\", \"Database Tools\", Icons.Default.Storage)\n        )\n    ),\n    \n    CONFIGURATION(\n        title = \"Configuration\",\n        items = listOf(\n            ToolbarMenuItem(\"user_configuration\", \"User configuration\", Icons.Default.Settings, \"Ctrl+Alt+S\"),\n            ToolbarMenuItem(\"separator_1\", \"\", separator = true),\n            ToolbarMenuItem(\"plugins\", \"Plugins\", Icons.Default.Extension),\n            ToolbarMenuItem(\"appearance_behavior\", \"Appearance & Behavior\", Icons.Default.Tune),\n            ToolbarMenuItem(\"keymap\", \"Keymap\", Icons.Default.Keyboard),\n            ToolbarMenuItem(\"separator_2\", \"\", separator = true),\n            ToolbarMenuItem(\"import_settings\", \"Import Settings\", Icons.Default.GetApp),\n            ToolbarMenuItem(\"export_settings\", \"Export Settings\", Icons.Default.Publish),\n            ToolbarMenuItem(\"separator_3\", \"\", separator = true),\n            ToolbarMenuItem(\"about\", \"About\", Icons.Default.Info)\n        )\n    )\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/models/ToolbarMenu.kt","className":null,"methodName":null,"startLine":107,"endLine":110,"content":"package com.example.mindweaverstudio.ui.components.toolbar.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\nsealed class ToolbarAction {\n    data class MenuItemClicked(val menuId: String, val itemId: String) : ToolbarAction()\n    data class MenuToggled(val menuId: String, val isOpen: Boolean) : ToolbarAction()\n}","chunkType":"CLASS","tokens":91,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorToolbar.kt","className":null,"methodName":"EditorToolbar","startLine":16,"endLine":16,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nfun EditorToolbar(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/components/toolbar/EditorToolbar.kt","className":null,"methodName":"ToolbarButton","startLine":85,"endLine":85,"content":"package com.example.mindweaverstudio.ui.components.toolbar\n\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.icons.Icons\n\nprivate fun ToolbarButton(","chunkType":"FUNCTION","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.components.toolbar","imports":["androidx.compose.foundation.layout.*","androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverTheme.kt","className":null,"methodName":null,"startLine":5,"endLine":5,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.runtime.*\n\nval LocalColors = staticCompositionLocalOf { DarkPalette }","chunkType":"PROPERTY","tokens":35,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.runtime.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverTheme.kt","className":null,"methodName":"MindWeaverTheme","startLine":15,"endLine":15,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.runtime.*\n\nfun MindWeaverTheme(","chunkType":"FUNCTION","tokens":25,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.runtime.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/ui/theme/MindWeaverPalette.kt","className":null,"methodName":null,"startLine":5,"endLine":109,"content":"package com.example.mindweaverstudio.ui.theme\n\nimport androidx.compose.ui.graphics.Color\n\ndata class MindWeaverPalette(\n    // Background and Surfaces\n    val rootBackground: Color,\n    val surface1: Color,\n    val surface2: Color,\n    val surface3: Color,\n    val surface4: Color,\n    \n    // Borders\n    val borderSubtle: Color,\n    val borderNeutral: Color,\n    val borderStrong: Color,\n    \n    // Text Colors\n    val textPrimary: Color,\n    val textSecondary: Color,\n    val textMuted: Color,\n    val textDisabled: Color,\n    val textInvert: Color,\n    \n    // Accent Colors\n    val accent300: Color,\n    val accent400: Color,\n    val accent500: Color,\n    val accent600: Color,\n    val accent700: Color,\n    \n    // Semantic Colors - Success\n    val success: Color,\n    val successSurface: Color,\n    val successBorder: Color,\n    \n    // Semantic Colors - Warning\n    val warning: Color,\n    val warningSurface: Color,\n    val warningBorder: Color,\n    \n    // Semantic Colors - Error\n    val error: Color,\n    val errorSurface: Color,\n    val errorBorder: Color,\n    \n    // Semantic Colors - Info\n    val info: Color,\n    val infoSurface: Color,\n    val infoBorder: Color,\n    \n    // Editor Specific Colors\n    val selection: Color,\n    val caret: Color,\n    val matchBrackets: Color,\n)\n\nval DarkPalette = MindWeaverPalette(\n    // Background and Surfaces\n    rootBackground = MindWeaverDarkColors.RootBackground,\n    surface1 = MindWeaverDarkColors.Surface1,\n    surface2 = MindWeaverDarkColors.Surface2,\n    surface3 = MindWeaverDarkColors.Surface3,\n    surface4 = MindWeaverDarkColors.Surface4,\n\n    // Borders\n    borderSubtle = MindWeaverDarkColors.BorderSubtle,\n    borderNeutral = MindWeaverDarkColors.BorderNeutral,\n    borderStrong = MindWeaverDarkColors.BorderStrong,\n\n    // Text Colors\n    textPrimary = MindWeaverDarkColors.TextPrimary,\n    textSecondary = MindWeaverDarkColors.TextSecondary,\n    textMuted = MindWeaverDarkColors.TextMuted,\n    textDisabled = MindWeaverDarkColors.TextDisabled,\n    textInvert = MindWeaverDarkColors.TextInvert,\n\n    // Accent Colors\n    accent300 = MindWeaverDarkColors.Accent300,\n    accent400 = MindWeaverDarkColors.Accent400,\n    accent500 = MindWeaverDarkColors.Accent500,\n    accent600 = MindWeaverDarkColors.Accent600,\n    accent700 = MindWeaverDarkColors.Accent700,\n\n    // Semantic Colors - Success\n    success = MindWeaverDarkColors.Success,\n    successSurface = MindWeaverDarkColors.SuccessSurface,\n    successBorder = MindWeaverDarkColors.SuccessBorder,\n\n    // Semantic Colors - Warning\n    warning = MindWeaverDarkColors.Warning,\n    warningSurface = MindWeaverDarkColors.WarningSurface,\n    warningBorder = MindWeaverDarkColors.WarningBorder,\n\n    // Semantic Colors - Error\n    error = MindWeaverDarkColors.Error,\n    errorSurface = MindWeaverDarkColors.ErrorSurface,\n    errorBorder = MindWeaverDarkColors.ErrorBorder,\n\n    // Semantic Colors - Info\n    info = MindWeaverDarkColors.Info,\n    infoSurface = MindWeaverDarkColors.InfoSurface,\n    infoBorder = MindWeaverDarkColors.InfoBorder,\n\n    // Editor Specific Colors\n    selection = MindWeaverDarkColors.Selection,\n    caret = MindWeaverDarkColors.Caret,\n    matchBrackets = MindWeaverDarkColors.MatchBrackets,\n)","chunkType":"CLASS","tokens":809,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.ui.theme","imports":["androidx.compose.ui.graphics.Color"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/AgentsModule.kt","className":null,"methodName":null,"startLine":36,"endLine":115,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT\nimport com.example.mindweaverstudio.data.ai.agents.Agent\n\nval agentsModule = module {\n    factory<Agent>(qualifier = named(TEST_CREATOR_AGENT)) {\n        TestCreatorAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            dockerMCPClient = get(),\n        )\n    }\n    factory<Agent>(qualifier = named(TEST_RUNNER_AGENT)) {\n        TestRunnerAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            dockerMCPClient = get(),\n        )\n    }\n    factory<Agent>(qualifier = named(CHAT_AGENT)) {\n        ChatAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(ARCHITECT_VALIDATOR_OPTIMIZER_AGENT)) {\n        ArchitectValidatorOptimizerAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(DETAILED_ARCHITECT_DESIGNER_AGENT)) {\n        DetailedArchitectDesignerAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(HIGH_LEVEL_ARCHITECT_AGENT)) {\n        HighLevelArchitectAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(REQUIREMENTS_ANALYST_AGENT)) {\n        RequirementsAnalystAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(CODE_FIXER_AGENT)) {\n        CodeFixerAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(CODE_REVIEWER_AGENT)) {\n        CodeReviewerAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(CODE_TESTER_AGENT)) {\n        CodeTesterAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(CODE_CREATOR_AGENT)) {\n        CodeCreatorAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n        )\n    }\n    factory<Agent>(qualifier = named(RELEASE_NOTES_GENERATION_AGENT)) {\n        ReleaseNotesGeneratorAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            mcpClient = get(),\n            receiver = get(),\n        )\n    }\n    factory<Agent>(qualifier = named(GITHUB_RELEASE_AGENT)) {\n        GithubReleaseAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            mcpClient = get(),\n            receiver = get(),\n        )\n    }\n    factory<Agent>(qualifier = named(REASONING_AGENT)) {\n        ReasoningAgent(\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            authManager = get(),\n            limitManager = get(),\n        )\n    }\n}","chunkType":"PROPERTY","tokens":695,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT","com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.CHAT_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/AppModule.kt","className":null,"methodName":null,"startLine":32,"endLine":87,"content":"package com.example.mindweaverstudio.di\n\nimport com.arkivanov.mvikotlin.core.store.StoreFactory\nimport com.arkivanov.mvikotlin.main.store.DefaultStoreFactory\n\nval appModule = module {\n\n    single { Settings.createDefault(\"com.example.mindweaverstudio\") }\n    singleOf(::AuthManager)\n    singleOf(::LimitManager)\n\n\n    single { Jedis(\"localhost\", 6379) }\n    singleOf(::RedisMemoryStore) bind MemoryStore::class\n\n    // Configuration\n    singleOf(ApiConfiguration::load) bind ApiConfiguration::class\n\n    // Receivers\n    singleOf(::CodeEditorLogReceiver)\n\n    // Ai Clients\n    includes(aiClientsModule)\n\n    // Agents\n    includes(agentsModule)\n\n    // Pipelines\n    includes(pipelinesModule)\n\n    // STT\n    factoryOf(::SpeechRecognizer)\n\n    singleOf(::AgentsOrchestratorFactory)\n\n    //Orchestrator\n    factory<CodeOrchestrator> { (pipelineNames: List<String>) ->\n        val registry = PipelineRegistry().apply {\n            pipelineNames.forEach { pipelineName ->\n                register(pipelineName, get<Pipeline>(named(pipelineName)))\n            }\n        }\n        CodeOrchestrator(\n            registry = registry,\n            aiClient = get<AiClient>(named(\"chatgpt\")),\n            memoryStore = get(),\n        )\n    }\n\n    // MCP clients\n    singleOf(::GithubMCPClient)\n    singleOf(::DockerMCPClient)\n    singleOf(::ThinkMcpClient)\n\n    // Stores\n    singleOf(::DefaultStoreFactory) bind StoreFactory::class\n    factoryOf(::AuthenticationStoreFactory)\n    factoryOf(::ProjectSelectionStoreFactory)\n    factoryOf(::CodeEditorStoreFactory)\n    factoryOf(::UserConfigurationStoreFactory)\n}","chunkType":"PROPERTY","tokens":400,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.arkivanov.mvikotlin.core.store.StoreFactory","com.arkivanov.mvikotlin.main.store.DefaultStoreFactory","com.example.mindweaverstudio.components.authentication.AuthenticationStoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/AiClientsModule.kt","className":null,"methodName":null,"startLine":10,"endLine":20,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.data.ai.aiClients.AiClient\nimport com.example.mindweaverstudio.data.ai.aiClients.ChatGPTApiClient\n\nval aiClientsModule = module {\n    single<AiClient>(named(\"deepseek\")) {\n        LocalDeepSeekApiClient()\n    }\n    single<AiClient>(named(\"gemini\")) {\n        GeminiApiClient(get())\n    }\n    single<AiClient>(named(\"chatgpt\")) {\n        ChatGPTApiClient(get())\n    }\n}","chunkType":"PROPERTY","tokens":111,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.data.ai.aiClients.AiClient","com.example.mindweaverstudio.data.ai.aiClients.ChatGPTApiClient","com.example.mindweaverstudio.data.ai.aiClients.GeminiApiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/di/PipelinesModule.kt","className":null,"methodName":null,"startLine":23,"endLine":85,"content":"package com.example.mindweaverstudio.di\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\n\nval pipelinesModule = module {\n    singleOf(::PipelineFactory)\n\n    factory<Pipeline>(named(CHAT_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().chatPipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        ChatPipeline(agentsRegistry = registry)\n    }\n\n    factory<Pipeline>(named(CODE_FIX_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().codeFixerPipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        CodeFixPipeline(agentsRegistry = registry)\n    }\n\n    factory<Pipeline>(named(CODE_CREATOR_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().codeCreatorPipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        CodeCreatorPipeline(agentsRegistry = registry)\n    }\n\n    factory<Pipeline>(named(CODE_REVIEW_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().codeReviewPipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        CodeReviewPipeline(agentsRegistry = registry)\n    }\n\n    factory<Pipeline>(named(GITHUB_RELEASE_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().githubReleasePipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        GithubReleasePipeline(agentsRegistry = registry)\n    }\n\n    factory<Pipeline>(named(ARCHITECTURE_PIPELINE)) {\n        val agentNames = get<PipelineFactory>().architecturePipelineAgents\n        val registry = AgentsRegistry().apply {\n            agentNames.forEach { agentName ->\n                register(agentName, get<Agent>(named(agentName)))\n            }\n        }\n        ArchitecturePipeline(agentsRegistry = registry)\n    }\n}","chunkType":"PROPERTY","tokens":611,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.di","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.pipelines.ARCHITECTURE_PIPELINE"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/main.kt","className":null,"methodName":"main","startLine":14,"endLine":36,"content":"package com.example.mindweaverstudio\n\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\n\nfun main() {\n    startKoin {\n        modules(appModule)\n    }\n\n    application {\n        val lifecycle = LifecycleRegistry()\n        val root = DefaultRootComponent(componentContext = DefaultComponentContext(lifecycle = lifecycle),)\n\n        val windowState = rememberWindowState()\n        LifecycleController(lifecycle, windowState)\n\n        Window(\n            onCloseRequest = ::exitApplication,\n            state = windowState,\n            title = \"mindweaverstudio\"\n        ) {\n            window.minimumSize = java.awt.Dimension(1200, 800)\n\n            App(component = root)\n        }\n    }\n}","chunkType":"FUNCTION","tokens":181,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio","imports":["androidx.compose.ui.window.Window","androidx.compose.ui.window.application","androidx.compose.ui.window.rememberWindowState"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":9,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface SidebarComponent {\n    val state: StateFlow<SidebarStore.State>\n\n    fun onIntent(intent: SidebarStore.Intent)\n}","chunkType":"INTERFACE","tokens":55,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/DefaultSidebarComponent.kt","className":null,"methodName":null,"startLine":9,"endLine":24,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultSidebarComponent(\n    private val sidebarStoreFactory: SidebarStoreFactory,\n    componentContext: ComponentContext,\n) : SidebarComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        sidebarStoreFactory.create()\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<SidebarStore.State> = store.stateFlow\n\n    override fun onIntent(intent: SidebarStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":165,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarStoreFactory.kt","className":null,"methodName":null,"startLine":14,"endLine":77,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass SidebarStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): SidebarStore =\n        object : SidebarStore, Store<SidebarStore.Intent, SidebarStore.State, SidebarStore.Label> by storeFactory.create(\n            name = \"SidebarStore\",\n            initialState = SidebarStore.State(),\n            bootstrapper = SimpleBootstrapper(SidebarStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<SidebarStore.Intent, SidebarStore.Action, SidebarStore.State, Msg, SidebarStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: SidebarStore.Action) = when(action) {\n            SidebarStore.Action.Init -> {\n                // Initialize any required resources\n            }\n        }\n\n        override fun executeIntent(intent: SidebarStore.Intent) {\n            when (intent) {\n                SidebarStore.Intent.ToggleSidebar -> {\n                    dispatch(SidebarToggled)\n                }\n                \n                SidebarStore.Intent.CloseSidebar -> {\n                    dispatch(SidebarClosed)\n                }\n                \n                is SidebarStore.Intent.SelectMenuItem -> {\n                    dispatch(MenuItemSelected(intent.menuItem))\n                }\n                \n                is SidebarStore.Intent.ToggleMenuExpansion -> {\n                    dispatch(MenuItemExpansionToggled(intent.menuItem))\n                }\n                \n                is SidebarStore.Intent.ExecuteSubMenuAction -> {\n                    publish(SidebarStore.Label.SubMenuActionRequested(intent.action, intent.menuItem))\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<SidebarStore.State, Msg> {\n        override fun SidebarStore.State.reduce(msg: Msg): SidebarStore.State =\n            when (msg) {\n                is SidebarToggled -> copy(isVisible = !isVisible)\n                is SidebarClosed -> copy(isVisible = false, selectedMenuItem = null, expandedMenuItems = emptySet())\n                is MenuItemSelected -> copy(selectedMenuItem = msg.menuItem)\n                is MenuItemExpansionToggled -> {\n                    val updatedExpanded = if (expandedMenuItems.contains(msg.menuItem)) {\n                        expandedMenuItems - msg.menuItem\n                    } else {\n                        expandedMenuItems + msg.menuItem\n                    }\n                    copy(expandedMenuItems = updatedExpanded)\n                }\n            }\n    }\n}","chunkType":"CLASS","tokens":697,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/sidebar/SidebarStore.kt","className":null,"methodName":null,"startLine":6,"endLine":36,"content":"package com.example.mindweaverstudio.components.sidebar\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.components.codeeditor.models.SidebarMenuItem\n\ninterface SidebarStore : Store<SidebarStore.Intent, SidebarStore.State, SidebarStore.Label> {\n\n    data class State(\n        val isVisible: Boolean = false,\n        val selectedMenuItem: SidebarMenuItem? = null,\n        val expandedMenuItems: Set<SidebarMenuItem> = emptySet()\n    )\n\n    sealed class Intent {\n        data object ToggleSidebar : Intent()\n        data class SelectMenuItem(val menuItem: SidebarMenuItem) : Intent()\n        data class ToggleMenuExpansion(val menuItem: SidebarMenuItem) : Intent()\n        data class ExecuteSubMenuAction(val action: String, val menuItem: SidebarMenuItem) : Intent()\n        data object CloseSidebar : Intent()\n    }\n\n    sealed class Label {\n        data class SubMenuActionRequested(val action: String, val menuItem: SidebarMenuItem) : Label()\n    }\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        data object SidebarToggled : Msg()\n        data object SidebarClosed : Msg()\n        data class MenuItemSelected(val menuItem: SidebarMenuItem) : Msg()\n        data class MenuItemExpansionToggled(val menuItem: SidebarMenuItem) : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":332,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.sidebar","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.components.codeeditor.models.SidebarMenuItem"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/DefaultUserConfigurationComponent.kt","className":null,"methodName":null,"startLine":9,"endLine":29,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultUserConfigurationComponent(\n    private val userConfigurationStoreFactory: UserConfigurationStoreFactory,\n    componentContext: ComponentContext,\n    private val onNavigateBack: () -> Unit\n) : UserConfigurationComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        userConfigurationStoreFactory.create()\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<UserConfigurationStore.State> = store.stateFlow\n\n    override fun onIntent(intent: UserConfigurationStore.Intent) {\n        store.accept(intent)\n    }\n\n    override fun onBackPressed() {\n        onNavigateBack()\n    }\n}","chunkType":"CLASS","tokens":213,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationStoreFactory.kt","className":null,"methodName":null,"startLine":16,"endLine":176,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass UserConfigurationStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): UserConfigurationStore =\n        object : UserConfigurationStore, Store<UserConfigurationStore.Intent, UserConfigurationStore.State, UserConfigurationStore.Label> by storeFactory.create(\n            name = \"UserConfigurationStore\",\n            initialState = UserConfigurationStore.State(),\n            bootstrapper = SimpleBootstrapper(UserConfigurationStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<UserConfigurationStore.Intent, UserConfigurationStore.Action, UserConfigurationStore.State, Msg, UserConfigurationStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: UserConfigurationStore.Action) = when(action) {\n            UserConfigurationStore.Action.Init -> {\n                loadUserConfiguration()\n            }\n        }\n\n        override fun executeIntent(intent: UserConfigurationStore.Intent) = when(intent) {\n            is UserConfigurationStore.Intent.UpdateName -> {\n                dispatch(NameUpdated(intent.name))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateRole -> {\n                dispatch(RoleUpdated(intent.role))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdatePreferredLanguage -> {\n                dispatch(PreferredLanguageUpdated(intent.language))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateResponseFormat -> {\n                dispatch(ResponseFormatUpdated(intent.format))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateExperienceLevel -> {\n                dispatch(ExperienceLevelUpdated(intent.level))\n                checkForUnsavedChanges()\n            }\n            is UserConfigurationStore.Intent.UpdateTimeZone -> {\n                dispatch(TimeZoneUpdated(intent.timeZone))\n                checkForUnsavedChanges()\n            }\n            UserConfigurationStore.Intent.SaveConfiguration -> {\n                saveUserConfiguration()\n            }\n            UserConfigurationStore.Intent.ResetConfiguration -> {\n                resetToDefaults()\n            }\n            UserConfigurationStore.Intent.ClearError -> {\n                dispatch(ErrorCleared)\n            }\n        }\n\n        private fun loadUserConfiguration() {\n            dispatch(LoadingStarted)\n            scope.launch {\n                try {\n                    val userPersonalization = PersonalizationConfig.load()\n                    dispatch(UserPersonalizationLoaded(userPersonalization))\n                } catch (e: Exception) {\n                    dispatch(ErrorOccurred(\"Failed to load user configuration: ${e.message}\"))\n                } finally {\n                    dispatch(LoadingFinished)\n                }\n            }\n        }\n\n        private fun saveUserConfiguration() {\n            dispatch(ConfigurationSaveStarted)\n            scope.launch {\n                try {\n                    PersonalizationConfig.save(state().userPersonalization)\n                    dispatch(ConfigurationSaved)\n                    dispatch(UnsavedChangesUpdated(false))\n                    publish(UserConfigurationStore.Label.ConfigurationSaved)\n                } catch (e: Exception) {\n                    dispatch(ErrorOccurred(\"Failed to save user configuration: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun resetToDefaults() {\n            val defaultPersonalization = UserPersonalization()\n            dispatch(UserPersonalizationLoaded(defaultPersonalization))\n            checkForUnsavedChanges()\n        }\n\n        private fun checkForUnsavedChanges() {\n            scope.launch {\n                try {\n                    val savedConfig = PersonalizationConfig.load()\n                    val currentConfig = state().userPersonalization\n                    val hasChanges = savedConfig != currentConfig\n                    dispatch(UnsavedChangesUpdated(hasChanges))\n                } catch (e: Exception) {\n                    // If we can't load saved config, assume we have changes\n                    dispatch(UnsavedChangesUpdated(true))\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<UserConfigurationStore.State, Msg> {\n        override fun UserConfigurationStore.State.reduce(msg: Msg): UserConfigurationStore.State =\n            when (msg) {\n                is UserPersonalizationLoaded -> copy(\n                    userPersonalization = msg.userPersonalization,\n                    hasUnsavedChanges = false\n                )\n                is NameUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(name = msg.name)\n                )\n                is RoleUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(role = msg.role)\n                )\n                is PreferredLanguageUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(preferredLanguage = msg.language)\n                )\n                is ResponseFormatUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(responseFormat = msg.format)\n                )\n                is ExperienceLevelUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(experienceLevel = msg.level)\n                )\n                is TimeZoneUpdated -> copy(\n                    userPersonalization = userPersonalization.copy(timeZone = msg.timeZone)\n                )\n                is ConfigurationSaveStarted -> copy(\n                    isSaving = true,\n                    error = null\n                )\n                is ConfigurationSaved -> copy(\n                    isSaving = false,\n                    error = null\n                )\n                is ErrorOccurred -> copy(\n                    error = msg.error,\n                    isLoading = false,\n                    isSaving = false\n                )\n                is ErrorCleared -> copy(\n                    error = null\n                )\n                is LoadingStarted -> copy(\n                    isLoading = true,\n                    error = null\n                )\n                is LoadingFinished -> copy(\n                    isLoading = false\n                )\n                is UnsavedChangesUpdated -> copy(\n                    hasUnsavedChanges = msg.hasChanges\n                )\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationStore.kt","className":null,"methodName":null,"startLine":9,"endLine":56,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\n\ninterface UserConfigurationStore : Store<UserConfigurationStore.Intent, UserConfigurationStore.State, UserConfigurationStore.Label> {\n\n    data class State(\n        val userPersonalization: UserPersonalization = UserPersonalization(),\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isSaving: Boolean = false,\n        val hasUnsavedChanges: Boolean = false\n    )\n\n    sealed class Intent {\n        data class UpdateName(val name: String) : Intent()\n        data class UpdateRole(val role: WorkRole) : Intent()\n        data class UpdatePreferredLanguage(val language: String) : Intent()\n        data class UpdateResponseFormat(val format: ResponseFormat) : Intent()\n        data class UpdateExperienceLevel(val level: ExperienceLevel) : Intent()\n        data class UpdateTimeZone(val timeZone: String) : Intent()\n        data object SaveConfiguration : Intent()\n        data object ResetConfiguration : Intent()\n        data object ClearError : Intent()\n    }\n\n    sealed class Label {\n        data object ConfigurationSaved : Label()\n        data class NavigationRequested(val destination: String) : Label()\n    }\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        data class UserPersonalizationLoaded(val userPersonalization: UserPersonalization) : Msg()\n        data class NameUpdated(val name: String) : Msg()\n        data class RoleUpdated(val role: WorkRole) : Msg()\n        data class PreferredLanguageUpdated(val language: String) : Msg()\n        data class ResponseFormatUpdated(val format: ResponseFormat) : Msg()\n        data class ExperienceLevelUpdated(val level: ExperienceLevel) : Msg()\n        data class TimeZoneUpdated(val timeZone: String) : Msg()\n        data object ConfigurationSaveStarted : Msg()\n        data object ConfigurationSaved : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        data object LoadingStarted : Msg()\n        data object LoadingFinished : Msg()\n        data class UnsavedChangesUpdated(val hasChanges: Boolean) : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":579,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.data.models.profile.UserPersonalization","com.example.mindweaverstudio.data.models.profile.WorkRole"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/userconfiguration/UserConfigurationComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":10,"content":"package com.example.mindweaverstudio.components.userconfiguration\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface UserConfigurationComponent {\n    val state: StateFlow<UserConfigurationStore.State>\n\n    fun onIntent(intent: UserConfigurationStore.Intent)\n    fun onBackPressed()\n}","chunkType":"INTERFACE","tokens":71,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.userconfiguration","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":null,"startLine":10,"endLine":14,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultCodeEditorComponent(\n    private val codeEditorStoreFactory: CodeEditorStoreFactory,\n    componentContext: ComponentContext,\n    private val project: Project,\n    private val onNavigateToUserConfiguration: () -> Unit = {}","chunkType":"CLASS","tokens":100,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":null,"startLine":17,"endLine":19,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\n    private val store = instanceKeeper.getStore {\n        codeEditorStoreFactory.create(project = project)\n    }","chunkType":"PROPERTY","tokens":70,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":null,"startLine":22,"endLine":22,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\n    override val state: StateFlow<CodeEditorStore.State> = store.stateFlow","chunkType":"PROPERTY","tokens":60,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":"onIntent","startLine":24,"endLine":26,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\n    override fun onIntent(intent: CodeEditorStore.Intent) {\n        store.accept(intent)\n    }","chunkType":"FUNCTION","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/DefaultCodeEditorComponent.kt","className":null,"methodName":"onNavigateToUserConfiguration","startLine":28,"endLine":30,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\n    override fun onNavigateToUserConfiguration() {\n        onNavigateToUserConfiguration.invoke()\n    }","chunkType":"FUNCTION","tokens":68,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorStoreFactory.kt","className":null,"methodName":null,"startLine":31,"endLine":230,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.SimpleBootstrapper\n\nclass CodeEditorStoreFactory(\n    orchestratorFactory: AgentsOrchestratorFactory,\n    private val speechRecognizer: SpeechRecognizer,\n    private val logReceiver: CodeEditorLogReceiver,\n    private val dockerMCPClient: DockerMCPClient,\n    private val githubMCPClient: GithubMCPClient,\n    private val storeFactory: StoreFactory,\n) {\n\n    private val orchestrator = orchestratorFactory.editorOrchestrator\n\n    fun create(project: Project): CodeEditorStore =\n        object : CodeEditorStore, Store<CodeEditorStore.Intent, CodeEditorStore.State, CodeEditorStore.Label> by storeFactory.create(\n            name = \"CodeEditorStore\",\n            initialState = CodeEditorStore.State(project = project),\n            bootstrapper = SimpleBootstrapper(CodeEditorStore.Action.Init),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private inner class ExecutorImpl : CoroutineExecutor<CodeEditorStore.Intent, CodeEditorStore.Action, CodeEditorStore.State, Msg, CodeEditorStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        override fun executeAction(action: CodeEditorStore.Action) = when(action) {\n            CodeEditorStore.Action.Init -> {\n                initMcpServer()\n                fetchRootNode(state().project.path)\n                setupLogListener()\n                setupVoiceListener()\n            }\n        }\n\n        private fun initMcpServer() {\n            scope.launch {\n                dockerMCPClient.init()\n                githubMCPClient.init()\n            }\n        }\n\n        private fun setupVoiceListener() {\n            scope.launch {\n                speechRecognizer.textChannel.receiveAsFlow().collectLatest {\n                    dispatch(ChatInputUpdated(it))\n                }\n            }\n        }\n\n        private fun fetchRootNode(filePath: String) {\n            scope.launch {\n                val node = scanDirectoryToFileNode(rootPathStr = filePath)\n                dispatch(OnNodesReceived(node))\n            }\n        }\n\n        private fun setupLogListener() {\n            scope.launch {\n                logReceiver.logFlow.collect { logEntry ->\n                    dispatch(LogEntryAdded(logEntry))\n                }\n            }\n        }\n\n        private fun toggleFolderExpansion(nodes: List<FileNode>, targetPath: String): List<FileNode> {\n            return nodes.map { node ->\n                if (node.path == targetPath && node.isDirectory) {\n                    node.copy(expanded = !node.expanded)\n                } else if (node.isDirectory && node.children.isNotEmpty()) {\n                    node.copy(children = toggleFolderExpansion(node.children, targetPath))\n                } else {\n                    node\n                }\n            }\n        }\n\n        override fun executeIntent(intent: CodeEditorStore.Intent) {\n            when (intent) {\n                is CodeEditorStore.Intent.SelectFile -> {\n                    if (!intent.file.isDirectory) {\n                        dispatch(FileSelected(intent.file))\n                        dispatch(EditorContentUpdated(intent.file.content.orEmpty()))\n                        dispatch(\n                            LogEntryAdded(\n                                LogEntry(\n                                    \"Opened file: ${intent.file.name}\",\n                                    UiLogLevel.INFO\n                                )\n                            )\n                        )\n                    }\n                }\n                \n                is CodeEditorStore.Intent.ToggleFolderExpanded -> {\n                    val currentTree = state().projectTree\n                    val updatedTree = toggleFolderExpansion(currentTree, intent.folderPath)\n                    dispatch(ProjectTreeUpdated(updatedTree))\n                }\n                \n                is CodeEditorStore.Intent.UpdateEditorContent -> {\n                    dispatch(EditorContentUpdated(intent.content))\n                }\n                \n                is CodeEditorStore.Intent.UpdateChatInput -> {\n                    dispatch(ChatInputUpdated(intent.input))\n                }\n                \n                is CodeEditorStore.Intent.SendChatMessage -> {\n                    val currentState = state()\n                    if (currentState.chatInput.isNotBlank() && !currentState.isLoading) {\n                        sendMessage(currentState.chatInput, currentState.chatMessages)\n                    }\n                }\n                \n                is CodeEditorStore.Intent.ClearError -> dispatch(ErrorCleared)\n\n                is CodeEditorStore.Intent.UpdatePanelWidth -> {\n                    val clampedWidth = min(0.8f, max(0.1f, intent.width))\n                    dispatch(PanelWidthUpdated(intent.uiPanel, clampedWidth))\n                }\n                \n                is CodeEditorStore.Intent.UpdateBottomPanelHeight -> {\n                    val clampedHeight = min(0.7f, max(0.1f, intent.height))\n                    dispatch(BottomPanelHeightUpdated(clampedHeight))\n                }\n                \n                is CodeEditorStore.Intent.AddLogEntry -> {\n                    dispatch(LogEntryAdded(intent.entry))\n                }\n\n                CodeEditorStore.Intent.RecordVoiceClick -> {\n                    when(state().isVoiceRecording) {\n                        true -> speechRecognizer.stopRecognition()\n                        false -> speechRecognizer.startRecognition(scope)\n                    }\n                    dispatch(VoiceRecordingStateChange)\n                }\n\n                is CodeEditorStore.Intent.PlayMessage -> playMessage(intent.message)\n            }\n        }\n\n        private fun playMessage(message: String) {\n            ProcessBuilder(\"say\", message).start()\n        }\n\n        private fun sendMessage(\n            message: String,\n            currentMessages: List<UiChatMessage>,\n        ) {\n            val userMessage = UiChatMessage.createUserMessage(message)\n            val thinkingMessage = UiChatMessage.createThinkingMessage()\n\n            val updatedMessages = currentMessages + userMessage + thinkingMessage\n            dispatch(MessagesUpdated(updatedMessages))\n            dispatch(ChatInputUpdated(\"\"))\n            dispatch(LoadingChanged(true))\n\n            scope.launch {\n                try {\n                    val result = orchestrator.handleMessage(message)\n\n                    if (result.isError) {\n                        dispatch(ErrorOccurred(result.message))\n                    }\n                    val finalMessages = currentMessages + userMessage + listOf(UiChatMessage.createAssistantMessage(result.message))\n\n                    dispatch(MessagesUpdated(finalMessages))\n                    dispatch(LoadingChanged(false))\n                } catch (e: Exception) {\n                    val errorMessages = currentMessages + userMessage\n                    dispatch(MessagesUpdated(errorMessages))\n                    dispatch(ErrorOccurred(e.message ?: \"Unknown error occurred\"))\n                    dispatch(LoadingChanged(false))\n                }\n            }\n        }\n    }\n\n    private object ReducerImpl : Reducer<CodeEditorStore.State, Msg> {\n        override fun CodeEditorStore.State.reduce(msg: Msg): CodeEditorStore.State =\n            when (msg) {\n                is FileSelected -> copy(selectedFile = msg.file)\n                is EditorContentUpdated -> copy(editorContent = msg.content)\n                is ChatInputUpdated -> copy(chatInput = msg.input)\n                is ChatMessageAdded -> copy(chatMessages = chatMessages + msg.message)\n                is PanelWidthUpdated -> when (msg.uiPanel) {\n                    UiPanel.LEFT -> copy(leftPanelWidth = msg.width)\n                    UiPanel.RIGHT -> copy(rightPanelWidth = msg.width)\n                }\n                is BottomPanelHeightUpdated -> copy(bottomPanelHeight = msg.height)\n                is LogEntryAdded -> copy(logs = logs + msg.entry)\n                is OnNodesReceived -> copy(projectTree = msg.node.children)\n                is ProjectTreeUpdated -> copy(projectTree = msg.tree)\n                is MessagesUpdated -> copy(chatMessages = msg.messages)\n                is LoadingChanged -> copy(isLoading = msg.isLoading)\n                is ErrorOccurred -> copy(error = msg.error, isLoading = false)\n                is ErrorCleared -> copy(error = null)\n                is VoiceRecordingStateChange -> copy(isVoiceRecording = !isVoiceRecording)\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.SimpleBootstrapper","com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"scanDirectoryToFileNode","startLine":19,"endLine":19,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\nsuspend fun scanDirectoryToFileNode(","chunkType":"FUNCTION","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    val rootReal = try { rootPath.toRealPath(LinkOption.NOFOLLOW_LINKS) } catch (e: IOException) { rootPath.toAbsolutePath() }","chunkType":"PROPERTY","tokens":76,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"uiPathFor","startLine":31,"endLine":39,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    fun uiPathFor(p: Path): String {\n        return try {\n            val rel = rootReal.relativize(p).toString().replace(File.separatorChar, '/')\n            if (rel.isEmpty()) \"/${rootReal.fileName?.toString() ?: \"\"}\" else \"/$rel\"\n        } catch (e: IllegalArgumentException) {\n            // p is on different root (shouldn't happen for normal recursion) — use absolute\n            p.toAbsolutePath().toString().replace(File.separatorChar, '/')\n        }\n    }","chunkType":"FUNCTION","tokens":160,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/utils/scanDirectoryToFileNode.kt","className":null,"methodName":"walk","startLine":41,"endLine":115,"content":"package com.example.mindweaverstudio.components.codeeditor.utils\n\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\nimport kotlinx.coroutines.Dispatchers\n\n    fun walk(p: Path, depth: Int): FileNode {\n        if (fileCounter >= maxFiles) return FileNode(\n            name = p.fileName?.toString() ?: p.toString(),\n            path = uiPathFor(p),\n            isDirectory = Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS),\n            children = emptyList(),\n            expanded = depth == 0 // Only root level expanded by default\n        )\n\n        val isDir = Files.isDirectory(p, LinkOption.NOFOLLOW_LINKS)\n        val name = p.fileName?.toString() ?: p.toString()\n        val pathStr = uiPathFor(p)\n\n        if (!includeHidden) {\n            try {\n                if (Files.isHidden(p)) {\n                    return FileNode(\n                        name = name,\n                        path = pathStr,\n                        isDirectory = isDir,\n                        children = emptyList(),\n                        expanded = depth == 0\n                    )\n                }\n            } catch (_: IOException) {}\n        }\n\n        if (!isDir) {\n            fileCounter++\n            val content = try {\n                Files.readString(p) // читаем содержимое файла\n            } catch (_: IOException) {\n                null // если не удалось прочитать (например бинарник или нет доступа)\n            }\n            return FileNode(\n                name = name,\n                path = pathStr,\n                isDirectory = false,\n                content = content,\n                expanded = false // Files don't need expanded state\n            )\n        }\n\n        // directory: protect against symlink loops\n        val real = try { p.toRealPath(LinkOption.NOFOLLOW_LINKS) } catch (e: IOException) { p.toAbsolutePath() }\n        if (!visited.add(real)) {\n            // already visited (symlink loop) — return empty children to avoid recursion\n            return FileNode(name = name, path = pathStr, isDirectory = true, children = emptyList(), expanded = depth == 0)\n        }\n\n        if (depth >= maxDepth) {\n            return FileNode(name = name, path = pathStr, isDirectory = true, children = emptyList(), expanded = depth == 0)\n        }\n\n        val children = ArrayList<FileNode>()\n        try {\n            Files.newDirectoryStream(p).use { ds ->\n                for (child in ds) {\n                    // re-check fileCounter limit\n                    if (fileCounter >= maxFiles) break\n                    // try skip hidden\n                    if (!includeHidden) {\n                        try { if (Files.isHidden(child)) continue } catch (_: IOException) {}\n                    }\n                    children.add(walk(child, depth + 1))\n                }\n            }\n        } catch (e: IOException) {\n            // On permission error or I/O error — just skip children\n        }\n\n        // sort children by name for stable UI order\n        children.sortBy { it.name }\n        return FileNode(name = name, path = pathStr, isDirectory = true, children = children, expanded = depth == 0)\n    }","chunkType":"FUNCTION","tokens":788,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.utils","imports":["com.example.mindweaverstudio.components.codeeditor.models.FileNode","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorStore.kt","className":null,"methodName":null,"startLine":10,"endLine":64,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport com.example.mindweaverstudio.components.codeeditor.models.FileNode\n\ninterface CodeEditorStore : Store<CodeEditorStore.Intent, CodeEditorStore.State, CodeEditorStore.Label> {\n\n    data class State(\n        val project: Project,\n        val projectTree: List<FileNode> = emptyList(),\n        val selectedFile: FileNode? = null,\n        val editorContent: String = \"\",\n        val chatMessages: List<UiChatMessage> = emptyList(),\n        val chatInput: String = \"\",\n        val logs: List<LogEntry> = emptyList(),\n        val leftPanelWidth: Float = 0.2f,\n        val rightPanelWidth: Float = 0.3f,\n        val bottomPanelHeight: Float = 0.3f,\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isVoiceRecording: Boolean = false,\n    )\n\n    sealed class Intent {\n        class SelectFile(val file: FileNode) : Intent()\n        class ToggleFolderExpanded(val folderPath: String) : Intent()\n        class UpdateEditorContent(val content: String) : Intent()\n        class UpdateChatInput(val input: String) : Intent()\n        class PlayMessage(val message: String) : Intent()\n        data object SendChatMessage : Intent()\n        data class UpdatePanelWidth(val uiPanel: UiPanel, val width: Float) : Intent()\n        data class UpdateBottomPanelHeight(val height: Float) : Intent()\n        data class AddLogEntry(val entry: LogEntry) : Intent()\n        data object ClearError : Intent()\n        data object RecordVoiceClick : Intent()\n    }\n\n    sealed class Label\n\n    sealed interface Action {\n        data object Init : Action\n    }\n\n    sealed class Msg {\n        class FileSelected(val file: FileNode) : Msg()\n        class EditorContentUpdated(val content: String) : Msg()\n        class ChatInputUpdated(val input: String) : Msg()\n        class ChatMessageAdded(val message: UiChatMessage) : Msg()\n        class MessagesUpdated(val messages: List<UiChatMessage>) : Msg()\n        class LoadingChanged(val isLoading: Boolean) : Msg()\n        class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        class PanelWidthUpdated(val uiPanel: UiPanel, val width: Float) : Msg()\n        class BottomPanelHeightUpdated(val height: Float) : Msg()\n        class LogEntryAdded(val entry: LogEntry) : Msg()\n        class OnNodesReceived(val node: FileNode) : Msg()\n        class ProjectTreeUpdated(val tree: List<FileNode>) : Msg()\n        data object VoiceRecordingStateChange : Msg()\n    }\n}","chunkType":"INTERFACE","tokens":642,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["com.arkivanov.mvikotlin.core.store.Store","com.example.mindweaverstudio.components.codeeditor.models.FileNode","com.example.mindweaverstudio.components.codeeditor.models.LogEntry"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/ChatMessage.kt","className":null,"methodName":null,"startLine":5,"endLine":53,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport com.example.mindweaverstudio.data.models.chat.remote.ChatMessage\n\nsealed class UiChatMessage {\n    abstract val content: String\n    abstract val timestamp: Long\n    \n    data class UserMessage(\n        override val content: String,\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n    \n    data class AssistantMessage(\n        override val content: String,\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n    \n    data class ThinkingMessage(\n        override val content: String = \"Thinking...\",\n        override val timestamp: Long = System.currentTimeMillis()\n    ) : UiChatMessage()\n    \n    fun toChatMessage(): ChatMessage {\n        return when (this) {\n            is UserMessage -> ChatMessage(role = \"user\", content = content)\n            is AssistantMessage -> ChatMessage(role = \"assistant\", content = content)\n            is ThinkingMessage -> ChatMessage(role = \"assistant\", content = content)\n        }\n    }\n    \n    companion object {\n        fun fromChatMessage(chatMessage: ChatMessage): UiChatMessage {\n            return when (chatMessage.role) {\n                \"user\" -> UserMessage(content = chatMessage.content)\n                \"assistant\" -> AssistantMessage(content = chatMessage.content)\n                else -> AssistantMessage(content = chatMessage.content)\n            }\n        }\n        \n        fun createUserMessage(content: String): UserMessage {\n            return UserMessage(content = content)\n        }\n        \n        fun createAssistantMessage(content: String): AssistantMessage {\n            return AssistantMessage(content = content)\n        }\n        \n        fun createThinkingMessage(): ThinkingMessage {\n            return ThinkingMessage()\n        }\n    }\n}","chunkType":"CLASS","tokens":465,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["com.example.mindweaverstudio.data.models.chat.remote.ChatMessage"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/UiPanel.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nenum class UiPanel {\n    LEFT, RIGHT\n}","chunkType":"CLASS","tokens":26,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/UiLogLevel.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nenum class UiLogLevel {\n    INFO, WARNING, ERROR, DEBUG\n}","chunkType":"CLASS","tokens":31,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/FileNode.kt","className":null,"methodName":null,"startLine":3,"endLine":10,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\ndata class FileNode(\n    val name: String,\n    val path: String,\n    val isDirectory: Boolean,\n    val content: String? = null,\n    val children: List<FileNode> = emptyList(),\n    val expanded: Boolean = true\n)","chunkType":"CLASS","tokens":69,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/SidebarMenuItem.kt","className":null,"methodName":null,"startLine":7,"endLine":64,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\nenum class SidebarMenuItem(\n    val title: String,\n    val icon: ImageVector,\n    val items: List<SidebarSubMenuItem> = emptyList()\n) {\n    FILE(\n        title = \"File\",\n        icon = Icons.Default.Folder,\n        items = listOf(\n            SidebarSubMenuItem(\"New File\", Icons.Default.Add, \"new_file\"),\n            SidebarSubMenuItem(\"Open File\", Icons.Default.FolderOpen, \"open_file\"),\n            SidebarSubMenuItem(\"Save\", Icons.Default.Save, \"save\"),\n            SidebarSubMenuItem(\"Save As...\", Icons.Default.SaveAs, \"save_as\"),\n            SidebarSubMenuItem(\"Close\", Icons.Default.Close, \"close\")\n        )\n    ),\n    EDIT(\n        title = \"Edit\",\n        icon = Icons.Default.Edit,\n        items = listOf(\n            SidebarSubMenuItem(\"Cut\", Icons.Default.ContentCut, \"cut\"),\n            SidebarSubMenuItem(\"Copy\", Icons.Default.ContentCopy, \"copy\"),\n            SidebarSubMenuItem(\"Paste\", Icons.Default.ContentPaste, \"paste\"),\n            SidebarSubMenuItem(\"Find\", Icons.Default.Search, \"find\"),\n            SidebarSubMenuItem(\"Replace\", Icons.Default.FindReplace, \"replace\")\n        )\n    ),\n    VIEW(\n        title = \"View\",\n        icon = Icons.Default.Visibility,\n        items = listOf(\n            SidebarSubMenuItem(\"Zoom In\", Icons.Default.ZoomIn, \"zoom_in\"),\n            SidebarSubMenuItem(\"Zoom Out\", Icons.Default.ZoomOut, \"zoom_out\"),\n            SidebarSubMenuItem(\"Full Screen\", Icons.Default.Fullscreen, \"full_screen\"),\n            SidebarSubMenuItem(\"Toggle Sidebar\", Icons.Default.Menu, \"toggle_sidebar\")\n        )\n    ),\n    TOOLS(\n        title = \"Tools\",\n        icon = Icons.Default.Build,\n        items = listOf(\n            SidebarSubMenuItem(\"Terminal\", Icons.Default.Terminal, \"terminal\"),\n            SidebarSubMenuItem(\"Git\", Icons.Default.Storage, \"git\"),\n            SidebarSubMenuItem(\"Build\", Icons.Default.PlayArrow, \"build\"),\n            SidebarSubMenuItem(\"Debug\", Icons.Default.BugReport, \"debug\")\n        )\n    ),\n    CONFIGURATION(\n        title = \"Configuration\",\n        icon = Icons.Default.Settings,\n        items = listOf(\n            SidebarSubMenuItem(\"Preferences\", Icons.Default.Tune, \"preferences\"),\n            SidebarSubMenuItem(\"Plugins\", Icons.Default.Extension, \"plugins\"),\n            SidebarSubMenuItem(\"Themes\", Icons.Default.Palette, \"themes\"),\n            SidebarSubMenuItem(\"Shortcuts\", Icons.Default.Keyboard, \"shortcuts\")\n        )\n    )\n}","chunkType":"CLASS","tokens":644,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/SidebarMenuItem.kt","className":null,"methodName":null,"startLine":66,"endLine":70,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.filled.*\n\ndata class SidebarSubMenuItem(\n    val title: String,\n    val icon: ImageVector,\n    val action: String\n)","chunkType":"CLASS","tokens":66,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["androidx.compose.material.icons.Icons","androidx.compose.material.icons.filled.*","androidx.compose.ui.graphics.vector.ImageVector"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/models/LogEntry.kt","className":null,"methodName":null,"startLine":5,"endLine":14,"content":"package com.example.mindweaverstudio.components.codeeditor.models\n\nimport kotlin.String\n\nclass LogEntry(\n    val message: String,\n    val level: UiLogLevel,\n    val timestamp: Long = System.currentTimeMillis()\n)\n\nfun String.createInfoLogEntry() = LogEntry(\n    level = UiLogLevel.INFO,\n    message = this,\n)","chunkType":"CLASS","tokens":76,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor.models","imports":["kotlin.String"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/codeeditor/CodeEditorComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":10,"content":"package com.example.mindweaverstudio.components.codeeditor\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface CodeEditorComponent {\n    val state: StateFlow<CodeEditorStore.State>\n\n    fun onIntent(intent: CodeEditorStore.Intent)\n    fun onNavigateToUserConfiguration()\n}","chunkType":"INTERFACE","tokens":68,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.codeeditor","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/DefaultProjectSelectionComponent.kt","className":null,"methodName":null,"startLine":15,"endLine":51,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultProjectSelectionComponent(\n    private val projectSelectionStoreFactory: ProjectSelectionStoreFactory,\n    componentContext: ComponentContext,\n    private val onProjectSelected: (Project) -> Unit,\n) : ProjectSelectionComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        projectSelectionStoreFactory.create()\n    }\n    \n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n\n    init {\n        store.labels\n            .onEach { label ->\n                when (label) {\n                    is ProjectSelectionStore.Label.ProjectSelected -> {\n                        onProjectSelected(label.project)\n                    }\n                    is ProjectSelectionStore.Label.ShowError -> {\n                        // Error handling could be implemented here if needed\n                    }\n                    is ProjectSelectionStore.Label.ShowFilePicker -> {\n                        // File picker is handled within the store\n                    }\n                }\n            }\n            .launchIn(componentScope)\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<ProjectSelectionStore.State> = store.stateFlow\n\n    override fun onIntent(intent: ProjectSelectionStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":381,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStore.kt","className":null,"methodName":null,"startLine":6,"endLine":27,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport kotlinx.serialization.Serializable\n\ninterface ProjectSelectionStore : Store<ProjectSelectionStore.Intent, ProjectSelectionStore.State, ProjectSelectionStore.Label> {\n\n    data class State(\n        val projects: List<Project> = emptyList(),\n        val isLoading: Boolean = false,\n        val error: String? = null\n    )\n\n    sealed class Intent {\n        object LoadRecentProjects : Intent()\n        object SelectNewProject : Intent()\n        class OpenProject(val project: Project) : Intent()\n        class RemoveProject(val path: String) : Intent()\n        class AddRecentProject(val path: String) : Intent()\n    }\n\n    sealed class Label {\n        class ShowError(val message: String) : Label()\n        class ProjectSelected(val project: Project) : Label()\n        object ShowFilePicker : Label()\n    }\n}","chunkType":"INTERFACE","tokens":232,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Store","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStore.kt","className":null,"methodName":null,"startLine":30,"endLine":34,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Store\nimport kotlinx.serialization.Serializable\n\ndata class Project(\n    val path: String,\n    val name: String,\n    val lastOpened: Long\n)","chunkType":"CLASS","tokens":61,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Store","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStoreFactory.kt","className":null,"methodName":null,"startLine":19,"endLine":214,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nclass ProjectSelectionStoreFactory(\n    private val storeFactory: StoreFactory,\n) {\n\n    fun create(): ProjectSelectionStore =\n        object : ProjectSelectionStore, Store<ProjectSelectionStore.Intent, ProjectSelectionStore.State, ProjectSelectionStore.Label> by storeFactory.create(\n            name = \"ProjectSelectionStore\",\n            initialState = ProjectSelectionStore.State(),\n            bootstrapper = Bootstrapper(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private sealed class Action {\n        data object LoadRecentProjects : Action()\n    }\n\n    private sealed class Msg {\n        data class RecentProjectsLoaded(val projects: List<Project>) : Msg()\n        data class LoadingChanged(val isLoading: Boolean) : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n    }\n\n    private inner class Bootstrapper: CoroutineBootstrapper<Action>() {\n        override fun invoke() {\n            dispatch(Action.LoadRecentProjects)\n        }\n    }\n\n    private inner class ExecutorImpl : CoroutineExecutor<ProjectSelectionStore.Intent, Action, ProjectSelectionStore.State, Msg, ProjectSelectionStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        private val preferences = Preferences.userNodeForPackage(ProjectSelectionStoreFactory::class.java)\n        private val json = Json { ignoreUnknownKeys = true }\n\n        override fun executeIntent(intent: ProjectSelectionStore.Intent) {\n            when (intent) {\n                is ProjectSelectionStore.Intent.AddRecentProject -> addRecentProject(intent.path)\n                is ProjectSelectionStore.Intent.OpenProject -> selectProject(intent.project)\n                is ProjectSelectionStore.Intent.RemoveProject -> removeProject(intent.path)\n                is ProjectSelectionStore.Intent.LoadRecentProjects -> loadRecentProjects()\n                is ProjectSelectionStore.Intent.SelectNewProject -> showFilePicker()\n            }\n        }\n\n        override fun executeAction(action: Action) {\n            when (action) {\n                is Action.LoadRecentProjects -> loadRecentProjects()\n            }\n        }\n\n        private fun loadRecentProjects() {\n            dispatch(Msg.LoadingChanged(true))\n            scope.launch {\n                try {\n                    val projectsJson = preferences.get(\"recent_projects\", \"[]\")\n                    val storedProjects = json.decodeFromString<List<StoredProject>>(projectsJson)\n                    \n                    val projects = storedProjects\n                        .filter { File(it.path).exists() } // Only include existing directories\n                        .map { stored ->\n                            Project(\n                                path = stored.path,\n                                name = File(stored.path).name.takeIf { it.isNotEmpty() } ?: stored.path,\n                                lastOpened = stored.lastOpened\n                            )\n                        }\n                        .sortedByDescending { it.lastOpened }\n                        .take(10) // Limit to 10 recent projects\n                    \n                    // Clean up preferences if we filtered out non-existing projects\n                    if (projects.size != storedProjects.size) {\n                        saveRecentProjects(projects)\n                    }\n                    \n                    dispatch(Msg.RecentProjectsLoaded(projects))\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to load recent projects: ${e.message}\"))\n                } finally {\n                    dispatch(Msg.LoadingChanged(false))\n                }\n            }\n        }\n\n        private fun addRecentProject(path: String) {\n            scope.launch {\n                try {\n                    val currentProjects = state().projects.toMutableList()\n                    \n                    // Remove if already exists\n                    currentProjects.removeAll { it.path == path }\n                    \n                    // Add at the beginning\n                    val newProject = Project(\n                        path = path,\n                        name = File(path).name.takeIf { it.isNotEmpty() } ?: path,\n                        lastOpened = System.currentTimeMillis()\n                    )\n                    currentProjects.add(0, newProject)\n                    \n                    // Keep only last 10\n                    val limitedProjects = currentProjects.take(10)\n                    \n                    saveRecentProjects(limitedProjects)\n                    dispatch(Msg.RecentProjectsLoaded(limitedProjects))\n                    \n                    selectProject(newProject)\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to add recent project: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun removeProject(path: String) {\n            scope.launch {\n                try {\n                    val updatedProjects = state().projects.filter { it.path != path }\n                    saveRecentProjects(updatedProjects)\n                    dispatch(Msg.RecentProjectsLoaded(updatedProjects))\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Failed to remove project: ${e.message}\"))\n                }\n            }\n        }\n\n        private fun saveRecentProjects(projects: List<Project>) {\n            val storedProjects = projects.map { \n                StoredProject(path = it.path, lastOpened = it.lastOpened) \n            }\n            val json = json.encodeToString(storedProjects)\n            preferences.put(\"recent_projects\", json)\n        }\n\n        private fun showFilePicker() {\n            SwingUtilities.invokeLater {\n                val fileChooser = JFileChooser().apply {\n                    dialogTitle = \"Select Project Directory\"\n                    fileSelectionMode = JFileChooser.DIRECTORIES_ONLY\n                    isAcceptAllFileFilterUsed = false\n                    \n                    // Set current directory to user home or last opened project directory\n                    val lastProject = state().projects.firstOrNull()\n                    if (lastProject != null) {\n                        val lastProjectDir = File(lastProject.path).parentFile\n                        if (lastProjectDir?.exists() == true) {\n                            currentDirectory = lastProjectDir\n                        }\n                    } else {\n                        currentDirectory = File(System.getProperty(\"user.home\"))\n                    }\n                }\n                \n                val result = fileChooser.showOpenDialog(null)\n                if (result == JFileChooser.APPROVE_OPTION) {\n                    val selectedDirectory = fileChooser.selectedFile\n                    if (selectedDirectory != null && selectedDirectory.isDirectory) {\n                        // Add to recent projects and navigate\n                        scope.launch {\n                            try {\n                                addRecentProject(selectedDirectory.absolutePath)\n                            } catch (e: Exception) {\n                                dispatch(Msg.ErrorOccurred(\"Failed to select project: ${e.message}\"))\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Select file and create RAG chunk file\n        private fun selectProject(project: Project) {\n            scope.launch(Dispatchers.IO) {\n                RAGChunkingUtility().processRepositoryStreaming(\n                    repositoryPath = project.path,\n                    outputBasePath = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/truly_streaming_output\",\n                    includeTests = false,\n                    createRAGOutput = true,\n                    ragBatchSize = 500,\n                )\n            }\n            publish(ProjectSelectionStore.Label.ProjectSelected(project))\n        }\n\n    }\n\n    private object ReducerImpl : Reducer<ProjectSelectionStore.State, Msg> {\n        override fun ProjectSelectionStore.State.reduce(msg: Msg): ProjectSelectionStore.State =\n            when (msg) {\n                is Msg.RecentProjectsLoaded -> copy(projects = msg.projects, error = null)\n                is Msg.LoadingChanged -> copy(isLoading = msg.isLoading)\n                is Msg.ErrorOccurred -> copy(error = msg.error)\n                is Msg.ErrorCleared -> copy(error = null)\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionStoreFactory.kt","className":null,"methodName":null,"startLine":217,"endLine":220,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nprivate data class StoredProject(\n    val path: String,\n    val lastOpened: Long\n)","chunkType":"CLASS","tokens":61,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/projectselection/ProjectSelectionComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":9,"content":"package com.example.mindweaverstudio.components.projectselection\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface ProjectSelectionComponent {\n    val state: StateFlow<ProjectSelectionStore.State>\n\n    fun onIntent(intent: ProjectSelectionStore.Intent)\n}","chunkType":"INTERFACE","tokens":64,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.projectselection","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/root/DefaultRootComponent.kt","className":null,"methodName":null,"startLine":24,"endLine":141,"content":"package com.example.mindweaverstudio.components.root\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.decompose.router.stack.ChildStack\n\nclass DefaultRootComponent(componentContext: ComponentContext) : RootComponent, KoinComponent, ComponentContext by componentContext {\n\n    /** Private properties */\n\n    private val navigation = StackNavigation<Config>()\n\n    /** Public properties */\n\n    override val stack: Value<ChildStack<*, Child>> = childStack(\n        source = navigation,\n        serializer = Config.serializer(),\n        initialConfiguration = Config.Authentication,\n        handleBackButton = true,\n        childFactory = ::child\n    )\n\n    /** Private methods */\n\n    private fun child(config: Config, componentContext: ComponentContext): Child {\n        return when(config) {\n            is Config.Authentication -> Child.Authentication(authenticationComponent(componentContext))\n            is Config.ProjectSelection -> Child.ProjectSelection(projectSelectionComponent(componentContext))\n            is Config.CodeEditor -> Child.CodeEditor(codeEditorComponent(\n                componentContext = componentContext,\n                project = config.project\n            ))\n            is Config.UserConfiguration -> Child.UserConfiguration(userConfigurationComponent(componentContext))\n        }\n    }\n\n    private fun authenticationComponent(componentContext: ComponentContext): AuthenticationComponent {\n        return DefaultAuthenticationComponent(\n            authenticationStoreFactory = get(),\n            componentContext = componentContext,\n            onAuthenticationSuccessful = {\n                navigateToProjectSelection()\n            }\n        )\n    }\n\n    private fun projectSelectionComponent(componentContext: ComponentContext): ProjectSelectionComponent {\n        return DefaultProjectSelectionComponent(\n            projectSelectionStoreFactory = get(),\n            componentContext = componentContext,\n            onProjectSelected = { projectPath ->\n                navigateToCodeEditor(projectPath)\n            }\n        )\n    }\n\n    private fun codeEditorComponent(\n        componentContext: ComponentContext,\n        project: Project,\n    ): CodeEditorComponent {\n        return DefaultCodeEditorComponent(\n            componentContext = componentContext,\n            codeEditorStoreFactory = get(),\n            project = project,\n            onNavigateToUserConfiguration = {\n                navigateToUserConfiguration()\n            }\n        )\n    }\n\n    private fun userConfigurationComponent(componentContext: ComponentContext): UserConfigurationComponent {\n        return DefaultUserConfigurationComponent(\n            userConfigurationStoreFactory = get(),\n            componentContext = componentContext,\n            onNavigateBack = {\n                navigateBack()\n            }\n        )\n    }\n\n    /** Child components callbacks */\n\n    override fun navigateToAuthentication() {\n        navigation.navigate(\n            transformer = { _: List<Config> -> listOf(Config.Authentication) },\n            onComplete = { _, _ -> }\n        )\n    }\n\n    override fun navigateToProjectSelection() {\n        navigation.navigate(\n            transformer = { _: List<Config> -> listOf(Config.ProjectSelection) },\n            onComplete = { _, _ -> }\n        )\n    }\n\n    override fun navigateToCodeEditor(project: Project) {\n        navigation.bringToFront(Config.CodeEditor(project))\n    }\n\n    override fun navigateToUserConfiguration() {\n        navigation.bringToFront(Config.UserConfiguration)\n    }\n\n    override fun navigateBack() {\n        navigation.pop()\n    }\n\n    @Serializable\n    private sealed interface Config {\n        \n        @Serializable\n        data object Authentication : Config\n        \n        @Serializable\n        data object ProjectSelection : Config\n        \n        @Serializable\n        class CodeEditor(val project: Project) : Config\n        \n        @Serializable\n        data object UserConfiguration : Config\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.root","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.decompose.router.stack.ChildStack","com.arkivanov.decompose.router.stack.StackNavigation"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/root/RootComponent.kt","className":null,"methodName":null,"startLine":11,"endLine":26,"content":"package com.example.mindweaverstudio.components.root\n\nimport com.arkivanov.decompose.router.stack.ChildStack\nimport com.arkivanov.decompose.value.Value\n\ninterface RootComponent {\n    val stack: Value<ChildStack<*, Child>>\n\n    fun navigateToAuthentication()\n    fun navigateToProjectSelection()\n    fun navigateToCodeEditor(project: Project)\n    fun navigateToUserConfiguration()\n    fun navigateBack()\n\n    sealed interface Child {\n        class Authentication(val component: AuthenticationComponent) : Child\n        class ProjectSelection(val component: ProjectSelectionComponent) : Child\n        class CodeEditor(val component: CodeEditorComponent) : Child\n        class UserConfiguration(val component: UserConfigurationComponent) : Child\n    }\n}","chunkType":"INTERFACE","tokens":187,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.root","imports":["com.arkivanov.decompose.router.stack.ChildStack","com.arkivanov.decompose.value.Value","com.example.mindweaverstudio.components.authentication.AuthenticationComponent"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationStoreFactory.kt","className":null,"methodName":null,"startLine":14,"endLine":156,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.mvikotlin.core.store.Reducer\nimport com.arkivanov.mvikotlin.core.store.Store\n\nclass AuthenticationStoreFactory(\n    private val storeFactory: StoreFactory,\n    private val authManager: AuthManager,\n) {\n\n    fun create(): AuthenticationStore =\n        object : AuthenticationStore, Store<AuthenticationStore.Intent, AuthenticationStore.State, AuthenticationStore.Label> by storeFactory.create(\n            name = \"AuthenticationStore\",\n            initialState = AuthenticationStore.State(),\n            bootstrapper = Bootstrapper(),\n            executorFactory = ::ExecutorImpl,\n            reducer = ReducerImpl\n        ) {}\n\n    private sealed class Action {\n        data object CheckAuthenticationStatus : Action()\n    }\n\n    private sealed class Msg {\n        data class EmailUpdated(val email: String, val isValid: Boolean) : Msg()\n        data class PasswordUpdated(val password: String, val isValid: Boolean) : Msg()\n        data class LoadingChanged(val isLoading: Boolean) : Msg()\n        data class ErrorOccurred(val error: String) : Msg()\n        data object ErrorCleared : Msg()\n        data object AuthenticationSucceeded : Msg()\n    }\n\n    private inner class Bootstrapper: CoroutineBootstrapper<Action>() {\n        override fun invoke() {\n            dispatch(Action.CheckAuthenticationStatus)\n        }\n    }\n\n    private inner class ExecutorImpl : CoroutineExecutor<AuthenticationStore.Intent, Action, AuthenticationStore.State, Msg, AuthenticationStore.Label>(\n        mainContext = Dispatchers.Swing\n    ) {\n        private val preferences = Preferences.userNodeForPackage(AuthenticationStoreFactory::class.java)\n\n        override fun executeIntent(intent: AuthenticationStore.Intent) {\n            when (intent) {\n                is AuthenticationStore.Intent.UpdateEmail -> {\n                    val isValid = isValidEmail(intent.email)\n                    dispatch(Msg.EmailUpdated(intent.email, isValid))\n                }\n                \n                is AuthenticationStore.Intent.UpdatePassword -> {\n                    val isValid = isValidPassword(intent.password)\n                    dispatch(Msg.PasswordUpdated(intent.password, isValid))\n                }\n                \n                is AuthenticationStore.Intent.SignIn -> {\n                    signIn()\n                }\n                \n                is AuthenticationStore.Intent.ClearError -> {\n                    dispatch(Msg.ErrorCleared)\n                }\n            }\n        }\n\n        override fun executeAction(action: Action) {\n            when (action) {\n                is Action.CheckAuthenticationStatus -> checkAuthenticationStatus()\n            }\n        }\n\n        private fun checkAuthenticationStatus() {\n            scope.launch {\n                try {\n                    val isAuthenticated = preferences.getBoolean(\"is_authenticated\", false)\n                    if (isAuthenticated) {\n                        dispatch(Msg.AuthenticationSucceeded)\n                        publish(AuthenticationStore.Label.AuthenticationSuccessful)\n                    }\n                } catch (e: Exception) {\n                    // Ignore errors during status check\n                }\n            }\n        }\n\n        private fun signIn() {\n            val state = state()\n            \n            if (!state.isEmailValid || !state.isPasswordValid) {\n                dispatch(Msg.ErrorOccurred(\"Please enter valid email and password\"))\n                return\n            }\n            \n            if (state.email.isBlank()) {\n                dispatch(Msg.ErrorOccurred(\"Email is required\"))\n                return\n            }\n            \n            if (state.password.isBlank()) {\n                dispatch(Msg.ErrorOccurred(\"Password is required\"))\n                return\n            }\n\n            dispatch(Msg.LoadingChanged(true))\n            \n            scope.launch {\n                try {\n                    val token = authManager.generateToken(state.email, state.password)\n\n                    if (token != null) {\n                        dispatch(Msg.AuthenticationSucceeded)\n                        publish(AuthenticationStore.Label.AuthenticationSuccessful)\n                    } else {\n                        dispatch(Msg.ErrorOccurred(\"Invalid credentials\"))\n                    }\n                } catch (e: Exception) {\n                    dispatch(Msg.ErrorOccurred(\"Authentication failed: ${e.message}\"))\n                } finally {\n                    dispatch(Msg.LoadingChanged(false))\n                }\n            }\n        }\n\n        private fun isValidEmail(email: String): Boolean {\n            return email.isNotBlank()\n        }\n\n        private fun isValidPassword(password: String): Boolean {\n            return password.length >= 2\n        }\n    }\n\n    private object ReducerImpl : Reducer<AuthenticationStore.State, Msg> {\n        override fun AuthenticationStore.State.reduce(msg: Msg): AuthenticationStore.State =\n            when (msg) {\n                is Msg.EmailUpdated -> copy(email = msg.email, isEmailValid = msg.isValid, error = null)\n                is Msg.PasswordUpdated -> copy(password = msg.password, isPasswordValid = msg.isValid, error = null)\n                is Msg.LoadingChanged -> copy(isLoading = msg.isLoading)\n                is Msg.ErrorOccurred -> copy(error = msg.error)\n                is Msg.ErrorCleared -> copy(error = null)\n                is Msg.AuthenticationSucceeded -> copy(\n                    isAuthenticated = true,\n                    isLoading = false,\n                    error = null\n                )\n            }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.mvikotlin.core.store.Reducer","com.arkivanov.mvikotlin.core.store.Store","com.arkivanov.mvikotlin.core.store.StoreFactory"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationComponent.kt","className":null,"methodName":null,"startLine":5,"endLine":9,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport kotlinx.coroutines.flow.StateFlow\n\ninterface AuthenticationComponent {\n    val state: StateFlow<AuthenticationStore.State>\n\n    fun onIntent(intent: AuthenticationStore.Intent)\n}","chunkType":"INTERFACE","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["kotlinx.coroutines.flow.StateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/DefaultAuthenticationComponent.kt","className":null,"methodName":null,"startLine":15,"endLine":49,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.decompose.ComponentContext\nimport com.arkivanov.mvikotlin.core.instancekeeper.getStore\n\nclass DefaultAuthenticationComponent(\n    private val authenticationStoreFactory: AuthenticationStoreFactory,\n    componentContext: ComponentContext,\n    private val onAuthenticationSuccessful: () -> Unit,\n) : AuthenticationComponent, ComponentContext by componentContext {\n\n    private val store = instanceKeeper.getStore {\n        authenticationStoreFactory.create()\n    }\n    \n    private val componentScope = CoroutineScope(Dispatchers.Main + SupervisorJob())\n\n    init {\n        store.labels\n            .onEach { label ->\n                when (label) {\n                    is AuthenticationStore.Label.AuthenticationSuccessful -> {\n                        onAuthenticationSuccessful()\n                    }\n                    is AuthenticationStore.Label.ShowError -> {\n                        // Error handling could be implemented here if needed\n                        // For now, errors are handled through state\n                    }\n                }\n            }\n            .launchIn(componentScope)\n    }\n\n    @OptIn(ExperimentalCoroutinesApi::class)\n    override val state: StateFlow<AuthenticationStore.State> = store.stateFlow\n\n    override fun onIntent(intent: AuthenticationStore.Intent) {\n        store.accept(intent)\n    }\n}","chunkType":"CLASS","tokens":355,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.decompose.ComponentContext","com.arkivanov.mvikotlin.core.instancekeeper.getStore","com.arkivanov.mvikotlin.extensions.coroutines.stateFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/components/authentication/AuthenticationStore.kt","className":null,"methodName":null,"startLine":5,"endLine":28,"content":"package com.example.mindweaverstudio.components.authentication\n\nimport com.arkivanov.mvikotlin.core.store.Store\n\ninterface AuthenticationStore : Store<AuthenticationStore.Intent, AuthenticationStore.State, AuthenticationStore.Label> {\n\n    data class State(\n        val email: String = \"\",\n        val password: String = \"\",\n        val isLoading: Boolean = false,\n        val error: String? = null,\n        val isEmailValid: Boolean = true,\n        val isPasswordValid: Boolean = true,\n        val isAuthenticated: Boolean = false\n    )\n\n    sealed class Intent {\n        data class UpdateEmail(val email: String) : Intent()\n        data class UpdatePassword(val password: String) : Intent()\n        object SignIn : Intent()\n        object ClearError : Intent()\n    }\n\n    sealed class Label {\n        object AuthenticationSuccessful : Label()\n        data class ShowError(val message: String) : Label()\n    }\n}","chunkType":"INTERFACE","tokens":228,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.components.authentication","imports":["com.arkivanov.mvikotlin.core.store.Store"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/settings/Settings.kt","className":null,"methodName":null,"startLine":46,"endLine":51,"content":"package com.example.mindweaverstudio.data.settings\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\n\nprivate data class StoredEntry(val type: String, val value: String)\n\nprivate val mapSerializer: KSerializer<Map<String, StoredEntry>> =\n    MapSerializer(String.serializer(), StoredEntry.serializer())\n\nprivate val json = Json { prettyPrint = false; encodeDefaults = true }","chunkType":"CLASS","tokens":101,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.settings","imports":["kotlinx.coroutines.CoroutineScope","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.flow.Flow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/settings/Settings.kt","className":null,"methodName":null,"startLine":56,"endLine":186,"content":"package com.example.mindweaverstudio.data.settings\n\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\n\nclass Settings(\n    private val file: File,\n    private val ioScope: CoroutineScope = CoroutineScope(Dispatchers.IO)\n) {\n    private val mutex = Mutex()\n\n    // in-memory cache\n    private val backing: MutableMap<String, StoredEntry> = mutableMapOf()\n\n    // change emitter: emits keys that changed\n    private val _changes = MutableSharedFlow<String>(extraBufferCapacity = 64)\n    val changes: Flow<String> get() = _changes\n\n    init {\n        if (!file.exists()) {\n            file.parentFile?.mkdirs()\n        } else {\n            try {\n                val text = file.readText()\n                if (text.isNotEmpty()) {\n                    val map = json.decodeFromString(mapSerializer, text)\n                    backing.putAll(map)\n                }\n            } catch (e: Exception) {\n                // If file corrupted, ignore - start empty. You may want to log.\n            }\n        }\n    }\n\n    // ----------------------------\n    // Basic operations\n    // ----------------------------\n    suspend fun clear() {\n        mutex.withLock {\n            backing.clear()\n            persistSync()\n            _changes.tryEmit(ALL_KEYS)\n        }\n    }\n\n    suspend fun remove(key: String) {\n        mutex.withLock {\n            val removed = backing.remove(key)\n            if (removed != null) {\n                persistSync()\n                _changes.tryEmit(key)\n            }\n        }\n    }\n\n    suspend fun hasKey(key: String): Boolean = mutex.withLock { backing.containsKey(key) }\n\n    // String\n    suspend fun putString(key: String, value: String) = putTyped(key, \"string\", value)\n    suspend fun getString(key: String, default: String): String = getTyped(key, \"string\")?.value ?: default\n    suspend fun getStringOrNull(key: String): String? = getTyped(key, \"string\")?.value\n\n    // Int\n    suspend fun putInt(key: String, value: Int) = putTyped(key, \"int\", value.toString())\n    suspend fun getInt(key: String, default: Int): Int = getTyped(key, \"int\")?.value?.toIntOrNull() ?: default\n\n    // Long\n    suspend fun putLong(key: String, value: Long) = putTyped(key, \"long\", value.toString())\n    suspend fun getLong(key: String, default: Long): Long = getTyped(key, \"long\")?.value?.toLongOrNull() ?: default\n\n    // Float\n    suspend fun putFloat(key: String, value: Float) = putTyped(key, \"float\", value.toString())\n    suspend fun getFloat(key: String, default: Float): Float = getTyped(key, \"float\")?.value?.toFloatOrNull() ?: default\n\n    // Boolean\n    suspend fun putBoolean(key: String, value: Boolean) = putTyped(key, \"boolean\", value.toString())\n    suspend fun getBoolean(key: String, default: Boolean): Boolean = getTyped(key, \"boolean\")?.value?.toBoolean() ?: default\n\n    // Observe as Flow<String> emitting the value serialized as string. You can map/convert in callers.\n    fun observe(key: String): Flow<String?> =\n        changes.filter { it == key || it == ALL_KEYS }.map {\n            // read current value on collector side - but we need to avoid suspending here, so do IO in coroutine\n            // To keep API simple, the user can call getX from a coroutine; however we also allow reading current value synchronously from cache\n            synchronized(backing) {\n                backing[key]?.value\n            }\n        }\n\n    // Helper for convenience: observe typed values\n    fun observeString(key: String, default: String): Flow<String> =\n        observe(key).map { it ?: default }\n\n    // ----------------------------\n    // Internal helpers\n    // ----------------------------\n    private suspend fun putTyped(key: String, type: String, value: String) {\n        mutex.withLock {\n            backing[key] = StoredEntry(type, value)\n            persistSync()\n            _changes.tryEmit(key)\n        }\n    }\n\n    private suspend fun getTyped(key: String, expectedType: String): StoredEntry? = mutex.withLock {\n        val entry = backing[key]\n        if (entry == null) return null\n        // If types mismatch, we still return value as string for backward compatibility, but you can enforce type here.\n        entry\n    }\n\n    private fun persistSync() {\n        try {\n            val tmp = File(file.parentFile, \"${file.name}.tmp\")\n            val serialized = json.encodeToString(mapSerializer, backing)\n            tmp.writeText(serialized)\n            Files.move(tmp.toPath(), file.toPath(), StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)\n        } catch (e: Exception) {\n            // best-effort: ignore or log\n        }\n    }\n\n    companion object Companion {\n        private const val ALL_KEYS = \"__ALL_KEYS__\"\n\n        /**\n         * Convenience factory that creates DesktopSettings in the platform's application data directory.\n         * Example path: ~/.config/<appId>/settings.json\n         */\n        fun createDefault(appId: String, fileName: String = \"settings.json\"): Settings {\n            val home = System.getProperty(\"user.home\") ?: \".\"\n            val configDir = File(home, \".config/$appId\")\n            val file = File(configDir, fileName)\n            return Settings(file)\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.settings","imports":["kotlinx.coroutines.CoroutineScope","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.flow.Flow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/auth/AuthManager.kt","className":null,"methodName":null,"startLine":12,"endLine":58,"content":"package com.example.mindweaverstudio.data.auth\n\nimport com.auth0.jwt.JWT\nimport com.auth0.jwt.JWTVerifier\n\nclass AuthManager(\n    private val settings: Settings\n) {\n    private val secret = \"your-secure-secret-key\"\n    private val algorithm = Algorithm.HMAC256(secret)\n    private val verifier: JWTVerifier = JWT.require(algorithm).build()\n\n    private val users = mutableMapOf(\n        \"admin\" to (\"adminpass\" to \"ADMIN\"),\n        \"user\" to (\"userpass\" to \"USER\")\n    )\n\n    suspend fun generateToken(username: String, password: String): String? {\n        val userData = users[username]\n        if (userData != null && password == userData.first) {\n            val role = userData.second\n            return JWT.create()\n                .withSubject(username)\n                .withClaim(\"role\", role)\n                .withExpiresAt(Date(System.currentTimeMillis() + 86_400_000))\n                .sign(algorithm)\n                .also { saveToken(it) }\n        }\n        return null\n    }\n\n    fun validateToken(token: String): Map<String, Any>? {\n        return try {\n            val decoded = verifier.verify(token)\n            mapOf(\n                \"username\" to decoded.subject,\n                \"role\" to decoded.getClaim(\"role\").asString()\n            )\n        } catch (e: JWTVerificationException) {\n            null\n        }\n    }\n\n    suspend fun saveToken(token: String) { settings.putString(TOKEN_KEY, token) }\n    suspend fun getToken(): String? = settings.getString(TOKEN_KEY, \"\")\n    suspend fun clearToken() { settings.remove(TOKEN_KEY) }\n\n    // Добавь пользователя (для динамики)\n    fun registerUser(username: String, password: String, role: String) {\n        users[username] = password to role\n    }\n}","chunkType":"CLASS","tokens":430,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.auth","imports":["com.auth0.jwt.JWT","com.auth0.jwt.JWTVerifier","com.auth0.jwt.algorithms.Algorithm"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/limits/LimitManager.kt","className":null,"methodName":null,"startLine":5,"endLine":30,"content":"package com.example.mindweaverstudio.data.limits\n\nimport com.example.mindweaverstudio.data.models.ai.Role\n\nclass LimitManager {\n    private val usage = mutableMapOf<String, MutableMap<String, Pair<Int, Long>>>()\n    private val defaultLimits = mapOf(\n        Role.ADMIN to mapOf(\"daily_queries\" to Int.MAX_VALUE),\n        Role.USER to mapOf(\"daily_queries\" to 100),\n        Role.GUEST to mapOf(\"daily_queries\" to 10)\n    )\n\n    fun checkAndConsume(username: String, limitKey: String, role: Role, consumption: Int = 1): Boolean {\n        val maxLimit = defaultLimits[role]?.get(limitKey) ?: 0\n        val userUsage = usage.getOrPut(username) { mutableMapOf() }\n        val now = System.currentTimeMillis()\n        var (used, resetAt) = userUsage.getOrPut(limitKey) { 0 to (now + 86_400_000) }\n\n        if (now > resetAt) {\n            used = 0\n            resetAt = now + 86_400_000\n        }\n\n        if (used + consumption > maxLimit) return false\n\n        used += consumption\n        userUsage[limitKey] = used to resetAt\n        return true\n    }\n}","chunkType":"CLASS","tokens":262,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.limits","imports":["com.example.mindweaverstudio.data.models.ai.Role"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/config/ApiConfiguration.kt","className":null,"methodName":null,"startLine":5,"endLine":46,"content":"package com.example.mindweaverstudio.data.utils.config\n\nimport java.util.Properties\n\ndata class ApiConfiguration(\n    val deepSeekApiKey: String,\n    val openAiApiKey: String,\n    val geminiApiKey: String,\n    val githubApiKey: String,\n    val thinkApiKey: String,\n) {\n    companion object {\n        fun load(): ApiConfiguration {\n            val properties = Properties()\n            \n            // Try to load from config file first\n            try {\n                val configStream = ApiConfiguration::class.java.classLoader\n                    .getResourceAsStream(\"api-config.properties\")\n                if (configStream != null) {\n                    properties.load(configStream)\n                }\n            } catch (e: Exception) {\n                // Config file not found, will use environment variables\n            }\n            \n            return ApiConfiguration(\n                deepSeekApiKey = properties.getProperty(\"deepseek.api.key\") \n                    ?: System.getenv(\"DEEPSEEK_API_KEY\") \n                    ?: \"\",\n                openAiApiKey = properties.getProperty(\"openai.api.key\") \n                    ?: System.getenv(\"OPENAI_API_KEY\") \n                    ?: \"\",\n                geminiApiKey = properties.getProperty(\"gemini.api.key\")\n                    ?: System.getenv(\"GEMINI_API_KEY\") \n                    ?: \"\",\n                githubApiKey = properties.getProperty(\"github.api.key\")\n                    ?: System.getenv(\"GITHUB_API_KEY\")\n                    ?: \"\",\n                thinkApiKey = properties.getProperty(\"think.api.key\")\n                    ?: System.getenv(\"think.api.key\")\n                    ?: \"\",\n            )\n        }\n    }\n}","chunkType":"CLASS","tokens":422,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.config","imports":["java.util.Properties"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/extensions/McpToolUtils.kt","className":null,"methodName":"Tool","startLine":6,"endLine":12,"content":"package com.example.mindweaverstudio.data.utils.extensions\n\nimport com.example.mindweaverstudio.data.models.mcp.base.ToolType\nimport io.modelcontextprotocol.kotlin.sdk.Tool\n\nfun Tool.getToolReportFormat(): String {\n    return when(ToolType.valueeOf(name)) {\n        ToolType.UNKNOWN -> \"\"\n        ToolType.FETCH_COMMITS -> \"\"\n        ToolType.RUN_PROJECT_CONTAINER -> runProjectContainerReportFormat\n    }\n}","chunkType":"FUNCTION","tokens":101,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.extensions","imports":["com.example.mindweaverstudio.data.models.mcp.base.ToolType","io.modelcontextprotocol.kotlin.sdk.Tool"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/JsonExporter.kt","className":null,"methodName":null,"startLine":15,"endLine":147,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument\n\nclass JsonExporter(\n    private val outputPath: String,\n    private val includeMetadata: Boolean = false\n) : ChunkProcessor {\n    \n    private val json = Json {\n        prettyPrint = false // Use compact format for streaming\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }\n    \n    private val writer: BufferedWriter\n    private val statistics = StreamingStatistics()\n    private var isFirstChunk = true\n    \n    init {\n        val file = File(outputPath)\n        file.parentFile?.mkdirs()\n        writer = BufferedWriter(FileWriter(file))\n        \n        // Write JSON opening\n        writer.write(\"{\")\n        \n        if (includeMetadata) {\n            writer.write(\"\\\"metadata\\\":{\")\n            writer.write(\"\\\"generatedAt\\\":\\\"${LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)}\\\",\")\n            writer.write(\"\\\"isStreaming\\\":true\")\n            writer.write(\"},\")\n        }\n        \n        writer.write(\"\\\"chunks\\\":[\")\n        writer.flush()\n    }\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        try {\n            // Update statistics\n            updateStatistics(chunk)\n            \n            // Write chunk separator\n            if (!isFirstChunk) {\n                writer.write(\",\")\n            } else {\n                isFirstChunk = false\n            }\n            \n            // Write chunk as JSON\n            val chunkJson = json.encodeToString(chunk)\n            writer.write(chunkJson)\n            writer.flush()\n            \n            // Suggest GC every 100 chunks to help with memory\n            if (statistics.totalChunks % 100 == 0) {\n                System.gc()\n                \n                // Print progress\n                val runtime = Runtime.getRuntime()\n                val usedMemory = runtime.totalMemory() - runtime.freeMemory()\n                val maxMemory = runtime.maxMemory()\n                val memoryPercent = (usedMemory.toDouble() / maxMemory * 100).toInt()\n                println(\"  Written ${statistics.totalChunks} chunks, Memory: ${memoryPercent}%\")\n            }\n            \n        } catch (e: Exception) {\n            println(\"Error writing chunk: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        try {\n            // Close JSON array and object\n            writer.write(\"]\")\n            \n            if (includeMetadata) {\n                // Add final statistics to metadata\n//                writer.write(\",\\\"finalStatistics\\\":{\")\n//                writer.write(\"\\\"totalFiles\\\":${statistics.totalFiles},\")\n//                writer.write(\"\\\"totalChunks\\\":${statistics.totalChunks},\")\n//                writer.write(\"\\\"totalTokens\\\":${statistics.totalTokens},\")\n//                writer.write(\"\\\"averageTokensPerChunk\\\":${statistics.averageTokensPerChunk},\")\n//                writer.write(\"\\\"chunksByType\\\":${json.encodeToString(statistics.chunksByType)},\")\n//                writer.write(\"\\\"largestChunkTokens\\\":${statistics.largestChunkTokens},\")\n//                writer.write(\"\\\"smallestChunkTokens\\\":${if (statistics.smallestChunkTokens == Int.MAX_VALUE) 0 else statistics.smallestChunkTokens},\")\n//                writer.write(\"\\\"chunksWithOverlap\\\":${statistics.chunksWithOverlap},\")\n//                writer.write(\"\\\"skippedFiles\\\":${statistics.skippedFiles},\")\n//                writer.write(\"\\\"errorFiles\\\":${statistics.errorFiles}\")\n//                writer.write(\"}\")\n            }\n            \n            writer.write(\"}\")\n            writer.flush()\n            writer.close()\n            \n            println(\"\\nStreaming export completed:\")\n            println(\"- Output file: $outputPath\")\n            println(\"- Total chunks written: ${statistics.totalChunks}\")\n            println(\"- Total files processed: ${statistics.totalFiles}\")\n            \n        } catch (e: Exception) {\n            println(\"Error completing export: ${e.message}\")\n        }\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument","kotlinx.serialization.json.Json"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/JsonExporter.kt","className":null,"methodName":null,"startLine":152,"endLine":283,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument\n\nclass RAGExporter(\n    private val outputBasePath: String,\n    private val batchSize: Int = 1000\n) : ChunkProcessor {\n    \n    private val json = Json {\n        prettyPrint = false\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }\n    \n    private val statistics = StreamingStatistics()\n    private var currentBatch = mutableListOf<RAGDocument>()\n    private var currentBatchId = 1\n    private var totalBatches = 0\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        try {\n            updateStatistics(chunk)\n            \n            // Convert chunk to RAG document\n            val ragDoc = RAGDocument(\n                id = generateDocumentId(chunk),\n                content = chunk.content,\n                metadata = mapOf(\n                    \"filePath\" to chunk.filePath,\n                    \"className\" to (chunk.className ?: \"\"),\n                    \"methodName\" to (chunk.methodName ?: \"\"),\n                    \"chunkType\" to chunk.chunkType.name,\n//                    \"startLine\" to chunk.startLine.toString(),\n//                    \"endLine\" to chunk.endLine.toString(),\n//                    \"tokens\" to chunk.tokens.toString(),\n//                    \"overlapsWithPrevious\" to chunk.overlapsWithPrevious.toString()\n                )\n            )\n            \n            currentBatch.add(ragDoc)\n            \n            // Write batch if full\n            if (currentBatch.size >= batchSize) {\n                writeBatch()\n            }\n            \n        } catch (e: Exception) {\n            println(\"Error processing chunk for RAG export: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        // Write remaining chunks in final batch\n        if (currentBatch.isNotEmpty()) {\n            writeBatch()\n        }\n        \n        println(\"\\nRAG streaming export completed:\")\n        println(\"- Total batches created: $totalBatches\")\n        println(\"- Total chunks exported: ${statistics.totalChunks}\")\n        println(\"- Batch files pattern: ${outputBasePath.replace(\".json\", \"_batch_*.json\")}\")\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun writeBatch() {\n        if (currentBatch.isEmpty()) return\n        \n        try {\n            val batchFile = File(outputBasePath.replace(\".json\", \"_batch_${currentBatchId}.json\"))\n            batchFile.parentFile?.mkdirs()\n            \n            val ragExport = mapOf(\n                \"batchId\" to currentBatchId,\n                \"totalBatches\" to \"TBD\", // Will be unknown until the end\n                \"documents\" to currentBatch.toList() // Create a copy\n            )\n            \n            val jsonContent = json.encodeToString(ragExport)\n            batchFile.writeText(jsonContent)\n            \n            println(\"  Written batch $currentBatchId (${currentBatch.size} documents)\")\n            \n            // Clear current batch and increment\n            currentBatch.clear()\n            currentBatchId++\n            totalBatches++\n            \n            // Suggest GC after each batch\n            System.gc()\n            \n        } catch (e: Exception) {\n            println(\"Error writing RAG batch: ${e.message}\")\n            statistics.errorFiles++\n        }\n    }\n    \n    private fun generateDocumentId(chunk: ChunkMetadata): String {\n        val fileName = File(chunk.filePath).nameWithoutExtension\n        val identifier = when {\n            chunk.methodName != null -> \"${chunk.className}_${chunk.methodName}\"\n            chunk.className != null -> chunk.className\n            else -> fileName\n        }\n        return \"${fileName}_${identifier}_${chunk.startLine}-${chunk.endLine}\".replace(\" \", \"_\")\n    }\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.RAGDocument","kotlinx.serialization.json.Json"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":15,"endLine":88,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass AnalyticsOnlyProcessor : ChunkProcessor {\n    private val statistics = StreamingStatistics()\n    private val chunkSizes = mutableListOf<Int>()\n    private val fileChunkCounts = mutableMapOf<String, Int>()\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        updateStatistics(chunk)\n        chunkSizes.add(chunk.tokens)\n        \n        val fileName = File(chunk.filePath).nameWithoutExtension\n        fileChunkCounts[fileName] = fileChunkCounts.getOrDefault(fileName, 0) + 1\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n    }\n    \n    override fun onComplete() {\n        println(\"\\n=== Analytics Report ===\")\n        println(\"Files analyzed: ${statistics.totalFiles}\")\n        println(\"Chunks analyzed: ${statistics.totalChunks}\")\n        println(\"Total tokens: ${statistics.totalTokens}\")\n        \n        // Token distribution analysis\n        val sortedSizes = chunkSizes.sorted()\n        val median = if (sortedSizes.isNotEmpty()) sortedSizes[sortedSizes.size / 2] else 0\n        val percentile95 = if (sortedSizes.isNotEmpty()) sortedSizes[(sortedSizes.size * 0.95).toInt()] else 0\n        \n        println(\"\\nToken Distribution:\")\n        println(\"  Minimum: ${statistics.smallestChunkTokens}\")\n        println(\"  Median: $median\")\n        println(\"  95th percentile: $percentile95\")\n        println(\"  Maximum: ${statistics.largestChunkTokens}\")\n        println(\"  Average: ${statistics.averageTokensPerChunk}\")\n        \n        // Top files by chunk count\n        println(\"\\nTop Files by Chunk Count:\")\n        fileChunkCounts.entries.sortedByDescending { it.value }.take(10).forEach { (file, count) ->\n            println(\"  $file: $count chunks\")\n        }\n        \n        // Chunk type distribution\n        println(\"\\nChunk Type Distribution:\")\n        statistics.chunksByType.entries.sortedByDescending { it.value }.forEach { (type, count) ->\n            val percentage = (count.toDouble() / statistics.totalChunks * 100).toInt()\n            println(\"  $type: $count ($percentage%)\")\n        }\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":791,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":93,"endLine":134,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass FilteringProcessor(\n    private val delegate: ChunkProcessor,\n    private val chunkTypeFilter: Set<ChunkType>? = null,\n    private val minTokens: Int = 0,\n    private val maxTokens: Int = Int.MAX_VALUE,\n    private val filePathFilter: ((String) -> Boolean)? = null\n) : ChunkProcessor {\n    \n    private var filteredCount = 0\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        // Apply filters\n        if (chunkTypeFilter != null && chunk.chunkType !in chunkTypeFilter) {\n            filteredCount++\n            return\n        }\n        \n        if (chunk.tokens < minTokens || chunk.tokens > maxTokens) {\n            filteredCount++\n            return\n        }\n        \n        if (filePathFilter != null && !filePathFilter.invoke(chunk.filePath)) {\n            filteredCount++\n            return\n        }\n        \n        // Chunk passes all filters, delegate to actual processor\n        delegate.processChunk(chunk)\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        delegate.onFileComplete(filePath, chunkCount)\n    }\n    \n    override fun onComplete() {\n        println(\"Filtered out $filteredCount chunks based on criteria\")\n        delegate.onComplete()\n    }\n    \n    override fun getStatistics(): StreamingStatistics = delegate.getStatistics()\n}","chunkType":"CLASS","tokens":385,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":139,"endLine":165,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass MultiOutputProcessor(\n    private val processors: List<ChunkProcessor>\n) : ChunkProcessor {\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        processors.forEach { processor ->\n            try {\n                processor.processChunk(chunk)\n            } catch (e: Exception) {\n                println(\"Error in processor ${processor::class.simpleName}: ${e.message}\")\n            }\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        processors.forEach { it.onFileComplete(filePath, chunkCount) }\n    }\n    \n    override fun onComplete() {\n        processors.forEach { it.onComplete() }\n    }\n    \n    override fun getStatistics(): StreamingStatistics {\n        // Return statistics from the first processor\n        return processors.firstOrNull()?.getStatistics() ?: StreamingStatistics()\n    }\n}","chunkType":"CLASS","tokens":273,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":null,"startLine":170,"endLine":227,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\nclass ConsoleLoggingProcessor(\n    private val verbose: Boolean = false\n) : ChunkProcessor {\n    \n    private val statistics = StreamingStatistics()\n    \n    override fun processChunk(chunk: ChunkMetadata) {\n        updateStatistics(chunk)\n        \n        if (verbose) {\n            println(\"Chunk #${statistics.totalChunks}: ${chunk.chunkType} '${chunk.className ?: chunk.methodName ?: \"N/A\"}' (${chunk.tokens} tokens)\")\n        } else if (statistics.totalChunks % 100 == 0) {\n            println(\"Processed ${statistics.totalChunks} chunks...\")\n        }\n    }\n    \n    override fun onFileComplete(filePath: String, chunkCount: Int) {\n        statistics.totalFiles++\n        if (chunkCount == 0) {\n            statistics.skippedFiles++\n        }\n        \n        if (verbose) {\n            val fileName = File(filePath).name\n            println(\"File complete: $fileName -> $chunkCount chunks\")\n        }\n    }\n    \n    override fun onComplete() {\n        println(\"\\n=== Console Logging Summary ===\")\n        println(\"Total files: ${statistics.totalFiles}\")\n        println(\"Total chunks: ${statistics.totalChunks}\")\n        println(\"Total tokens: ${statistics.totalTokens}\")\n        println(\"Average tokens per chunk: ${statistics.averageTokensPerChunk}\")\n    }\n    \n    override fun getStatistics(): StreamingStatistics = statistics\n    \n    private fun updateStatistics(chunk: ChunkMetadata) {\n        statistics.totalChunks++\n        statistics.totalTokens += chunk.tokens\n        \n        val chunkTypeKey = chunk.chunkType.name\n        statistics.chunksByType[chunkTypeKey] = statistics.chunksByType.getOrDefault(chunkTypeKey, 0) + 1\n        \n        if (chunk.tokens > statistics.largestChunkTokens) {\n            statistics.largestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.tokens < statistics.smallestChunkTokens) {\n            statistics.smallestChunkTokens = chunk.tokens\n        }\n        \n        if (chunk.overlapsWithPrevious) {\n            statistics.chunksWithOverlap++\n        }\n    }\n}","chunkType":"CLASS","tokens":563,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runAnalyticsOnly","startLine":234,"endLine":243,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runAnalyticsOnly() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        val processor = AnalyticsOnlyProcessor()\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = processor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":134,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runFilteredExport","startLine":245,"endLine":261,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runFilteredExport() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        \n        // Only export CLASS and INTERFACE chunks with >100 tokens\n        val jsonExporter = JsonExporter(\"./filtered_chunks.json\")\n        val filteredProcessor = FilteringProcessor(\n            delegate = jsonExporter,\n            chunkTypeFilter = setOf(ChunkType.CLASS, ChunkType.INTERFACE),\n            minTokens = 100\n        )\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = filteredProcessor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":210,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/CustomProcessors.kt","className":null,"methodName":"runMultiOutput","startLine":263,"endLine":281,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\n    fun runMultiOutput() {\n        val utility = RAGChunkingUtility.createMemoryOptimized()\n        \n        // Export to both regular JSON and RAG format simultaneously\n        val processors = listOf(\n            JsonExporter(\"./chunks.json\"),\n            RAGExporter(\"./rag_chunks.json\", batchSize = 500),\n            AnalyticsOnlyProcessor(),\n            ConsoleLoggingProcessor(verbose = false)\n        )\n        \n        val multiProcessor = MultiOutputProcessor(processors)\n        \n        utility.chunkWithCustomProcessor(\n            repositoryPath = \".\",\n            processor = multiProcessor,\n            includeTests = false\n        )\n    }","chunkType":"FUNCTION","tokens":220,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.RAGChunkingUtility","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata","com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":9,"endLine":158,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\nclass KotlinCodeParser {\n\n    fun parseFile(file: File): FileAnalysis {\n        val lines = file.readLines()\n        val content = lines.joinToString(\"\\n\")\n\n        return FileAnalysis(\n            filePath = file.absolutePath,\n            packageDeclaration = extractPackageDeclaration(lines),\n            imports = extractImports(lines),\n            elements = parseCodeElements(lines),\n            totalLines = lines.size\n        )\n    }\n\n    private fun extractPackageDeclaration(lines: List<String>): String? {\n        return lines.find { it.trim().startsWith(\"package \") }\n            ?.substringAfter(\"package \")\n            ?.substringBefore(\"//\")\n            ?.trim()\n    }\n\n    private fun extractImports(lines: List<String>): List<String> {\n        return lines.filter { it.trim().startsWith(\"import \") }\n            .map {\n                it.substringAfter(\"import \")\n                    .substringBefore(\"//\")\n                    .trim()\n            }\n    }\n\n    private fun parseCodeElements(lines: List<String>): List<CodeElement> {\n        val elements = mutableListOf<CodeElement>()\n        var currentDoc: String? = null\n        var i = 0\n\n        while (i < lines.size) {\n            val line = lines[i].trim()\n\n            when {\n                isDocumentationComment(line) -> {\n                    val docEnd = findDocumentationEnd(lines, i)\n                    currentDoc = extractDocumentation(lines, i, docEnd)\n                    i = docEnd\n                }\n\n                isClassDeclaration(line) -> {\n                    val element = parseClass(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isInterfaceDeclaration(line) -> {\n                    val element = parseInterface(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isEnumDeclaration(line) -> {\n                    val element = parseEnum(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isFunctionDeclaration(line) -> {\n                    val element = parseFunction(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                isPropertyDeclaration(line) -> {\n                    val element = parseProperty(lines, i, currentDoc)\n                    elements.add(element)\n                    currentDoc = null\n                    i = element.endLine\n                }\n\n                else -> i++\n            }\n        }\n\n        return elements\n    }\n\n    private fun isDocumentationComment(line: String): Boolean {\n        return line.startsWith(\"/**\") || line.startsWith(\"/*\")\n    }\n\n    private fun findDocumentationEnd(lines: List<String>, start: Int): Int {\n        for (i in start until lines.size) {\n            if (lines[i].trim().endsWith(\"*/\")) {\n                return i + 1\n            }\n        }\n        return start + 1\n    }\n\n    private fun extractDocumentation(lines: List<String>, start: Int, end: Int): String {\n        return lines.subList(start, end).joinToString(\"\\n\")\n    }\n\n    private fun isClassDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*(abstract|sealed|open|final)?\\s*class\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isInterfaceDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*interface\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isEnumDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*enum\\s+class\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isFunctionDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return Regex(\"\"\"(public|private|internal|protected)?\\s*(override|suspend|inline|infix)?\\s*fun\\s+\\w+\"\"\")\n            .find(cleanLine) != null\n    }\n\n    private fun isPropertyDeclaration(line: String): Boolean {\n        val cleanLine = line.removeAnnotations().trim()\n        return (Regex(\"\"\"(public|private|internal|protected)?\\s*(val|var)\\s+\\w+\"\"\").find(cleanLine) != null) &&\n                hasComplexInitialization(cleanLine)\n    }\n\n    private fun hasComplexInitialization(line: String): Boolean {\n        return line.contains(\"{\") || line.contains(\"=\") && line.length > 50\n    }\n\n    private fun String.removeAnnotations(): String {\n        return this.replace(Regex(\"\"\"@\\w+(\\([^)]*\\))?\\s*\"\"\"), \"\")\n    }\n\n    private fun parseClass(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1 // Convert to 1-based indexing\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildClassSignature(lines, startIndex)\n        val name = extractClassName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":152,"endLine":308,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\n    private fun parseClass(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1 // Convert to 1-based indexing\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildClassSignature(lines, startIndex)\n        val name = extractClassName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.CLASS,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseInterface(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildInterfaceSignature(lines, startIndex)\n        val name = extractInterfaceName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.INTERFACE,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseEnum(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findBlockEnd(lines, startIndex)\n        val signature = buildEnumSignature(lines, startIndex)\n        val name = extractEnumName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.ENUM,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseFunction(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findFunctionEnd(lines, startIndex)\n        val signature = buildFunctionSignature(lines, startIndex, endLine - 1)\n        val name = extractFunctionName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.FUNCTION,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun parseProperty(lines: List<String>, startIndex: Int, documentation: String?): CodeElement {\n        val startLine = startIndex + 1\n        val endLine = findPropertyEnd(lines, startIndex)\n        val signature = buildPropertySignature(lines, startIndex, endLine - 1)\n        val name = extractPropertyName(lines[startIndex])\n        val modifiers = extractModifiers(lines[startIndex])\n\n        return CodeElement(\n            type = ChunkType.PROPERTY,\n            name = name,\n            startLine = startLine,\n            endLine = endLine,\n            signature = signature,\n            modifiers = modifiers,\n            isPrivate = modifiers.contains(\"private\"),\n            documentation = documentation\n        )\n    }\n\n    private fun findBlockEnd(lines: List<String>, startIndex: Int): Int {\n        var braceCount = 0\n        var foundFirstBrace = false\n\n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        foundFirstBrace = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (foundFirstBrace && braceCount == 0) {\n                            return i + 1 // Convert to 1-based indexing\n                        }\n                    }\n                }\n            }\n        }\n        return lines.size\n    }\n\n    private fun findFunctionEnd(lines: List<String>, startIndex: Int): Int {\n        val line = lines[startIndex]\n        return if (line.contains(\"{\")) {\n            findBlockEnd(lines, startIndex)\n        } else {\n            // Single expression function or abstract function\n            startIndex + 1\n        }\n    }\n\n    private fun findPropertyEnd(lines: List<String>, startIndex: Int): Int {\n        val line = lines[startIndex]\n        return if (line.contains(\"{\")) {\n            findBlockEnd(lines, startIndex)\n        } else {\n            startIndex + 1\n        }\n    }\n\n    private fun buildClassSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildInterfaceSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildEnumSignature(lines: List<String>, startIndex: Int): String {\n        val endIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildFunctionSignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/KotlinCodeParser.kt","className":null,"methodName":null,"startLine":302,"endLine":361,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: KotlinCodeParser\nclass KotlinCodeParser {\n\n        return lines.subList(startIndex, endIndex + 1).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildFunctionSignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n\n    private fun buildPropertySignature(lines: List<String>, startIndex: Int, endIndex: Int): String {\n        val signatureEndIndex = findSignatureEnd(lines, startIndex)\n        return lines.subList(startIndex, minOf(signatureEndIndex + 1, endIndex + 1)).joinToString(\"\\n\").trim()\n    }\n\n    private fun findSignatureEnd(lines: List<String>, startIndex: Int): Int {\n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            if (line.contains(\"{\") || line.contains(\"=\")) {\n                return i\n            }\n        }\n        return startIndex\n    }\n\n    private fun extractClassName(line: String): String {\n        return Regex(\"\"\"class\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownClass\"\n    }\n\n    private fun extractInterfaceName(line: String): String {\n        return Regex(\"\"\"interface\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownInterface\"\n    }\n\n    private fun extractEnumName(line: String): String {\n        return Regex(\"\"\"enum\\s+class\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownEnum\"\n    }\n\n    private fun extractFunctionName(line: String): String {\n        return Regex(\"\"\"fun\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(1) ?: \"UnknownFunction\"\n    }\n\n    private fun extractPropertyName(line: String): String {\n        return Regex(\"\"\"(val|var)\\s+(\\w+)\"\"\").find(line)?.groupValues?.get(2) ?: \"UnknownProperty\"\n    }\n\n    private fun extractModifiers(line: String): List<String> {\n        val modifiers = mutableListOf<String>()\n        val possibleModifiers = listOf(\n            \"public\", \"private\", \"internal\", \"protected\",\n            \"abstract\", \"sealed\", \"open\", \"final\",\n            \"override\", \"suspend\", \"inline\", \"infix\"\n        )\n\n        for (modifier in possibleModifiers) {\n            if (Regex(\"\"\"\\b$modifier\\b\"\"\").find(line) != null) {\n                modifiers.add(modifier)\n            }\n        }\n\n        return modifiers\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":607,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkType","com.example.mindweaverstudio.data.utils.ragchunking.models.CodeElement","com.example.mindweaverstudio.data.utils.ragchunking.models.FileAnalysis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/ChunkProcessor.kt","className":null,"methodName":null,"startLine":8,"endLine":30,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\ninterface ChunkProcessor {\n    /**\n     * Called when a new chunk is generated.\n     * The processor should immediately handle the chunk (write to file, etc.)\n     * and not keep it in memory.\n     */\n    fun processChunk(chunk: ChunkMetadata)\n    \n    /**\n     * Called when processing of a file is complete.\n     */\n    fun onFileComplete(filePath: String, chunkCount: Int)\n    \n    /**\n     * Called when all processing is complete.\n     */\n    fun onComplete()\n    \n    /**\n     * Get lightweight statistics without keeping chunk objects in memory.\n     */\n    fun getStatistics(): StreamingStatistics\n}","chunkType":"INTERFACE","tokens":188,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/ChunkProcessor.kt","className":null,"methodName":null,"startLine":35,"endLine":48,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata\n\ndata class StreamingStatistics(\n    var totalFiles: Int = 0,\n    var totalChunks: Int = 0,\n    var totalTokens: Long = 0,\n    var chunksByType: MutableMap<String, Int> = mutableMapOf(),\n    var largestChunkTokens: Int = 0,\n    var smallestChunkTokens: Int = Int.MAX_VALUE,\n    var chunksWithOverlap: Int = 0,\n    var skippedFiles: Int = 0,\n    var errorFiles: Int = 0\n) {\n    val averageTokensPerChunk: Int\n        get() = if (totalChunks > 0) (totalTokens / totalChunks).toInt() else 0\n}","chunkType":"CLASS","tokens":159,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.ChunkMetadata"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":10,"endLine":159,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n    private val maxChunkSize: Int = 300,\n    private val largeElementThreshold: Int = 200,\n    private val overlapSize: Int = 7,\n    private val maxContentLength: Int = 10000\n) {\n    \n    /**\n     * Process a file with streaming callback - no chunks are accumulated in memory.\n     */\n    fun processFileStreaming(file: File, processor: ChunkProcessor): Int {\n        if (!file.exists() || !file.isFile) {\n            return 0\n        }\n        \n        // Check file size first\n        val fileSize = file.length()\n        if (fileSize > 1_000_000) { // 1MB limit for individual files\n            println(\"  Skipping very large file: ${file.name} (${fileSize / 1024}KB)\")\n            return 0\n        }\n        \n        return try {\n            // Parse file structure - this gives us metadata without full content\n            val analysis = parser.parseFile(file)\n            val fileLines = file.readLines() // We need this for content extraction\n            \n            var chunkCount = 0\n            \n            // Process each element immediately without accumulating\n            for (element in analysis.elements) {\n                try {\n                    chunkCount += processElementStreaming(element, analysis, fileLines, processor)\n                    \n                    // Suggest GC after processing large elements\n                    if (element.endLine - element.startLine > 100) {\n                        System.gc()\n                    }\n                    \n                } catch (e: Exception) {\n                    println(\"    Error processing element ${element.name}: ${e.message}\")\n                    continue // Skip this element, continue with others\n                }\n            }\n            \n            chunkCount\n            \n        } catch (e: OutOfMemoryError) {\n            println(\"    OutOfMemoryError processing ${file.name} - file too large\")\n            System.gc()\n            0\n        } catch (e: Exception) {\n            println(\"    Error processing file ${file.name}: ${e.message}\")\n            0\n        }\n    }\n    \n    /**\n     * Process a single code element with streaming - no chunk accumulation.\n     */\n    private fun processElementStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        processor: ChunkProcessor\n    ): Int {\n        val elementSize = element.endLine - element.startLine + 1\n        \n        // Skip extremely large elements entirely\n        if (elementSize > 2000) {\n            println(\"      Skipping extremely large element: ${element.name} ($elementSize lines)\")\n            return 0\n        }\n        \n        val contextualInfo = buildContextualInfoMinimal(element, analysis)\n        \n        return if (elementSize > largeElementThreshold) {\n            processLargeElementStreaming(element, analysis, fileLines, contextualInfo, processor)\n        } else {\n            processSingleChunkStreaming(element, analysis, fileLines, contextualInfo, processor)\n            1\n        }\n    }\n    \n    /**\n     * Process a large element by splitting into sub-chunks and streaming each immediately.\n     */\n    private fun processLargeElementStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        processor: ChunkProcessor\n    ): Int {\n        val elementLines = try {\n            fileLines.subList(element.startLine - 1, minOf(element.endLine, fileLines.size))\n        } catch (e: Exception) {\n            println(\"      Error extracting element lines for ${element.name}\")\n            return 0\n        }\n        \n        val logicalBlocks = findSimpleBlocks(elementLines, element.startLine - 1)\n        \n        var currentChunkStart = element.startLine\n        var chunkCount = 0\n        val maxChunksPerElement = 10 // Strict limit\n        \n        for (block in logicalBlocks) {\n            if (chunkCount >= maxChunksPerElement) {\n                println(\"      Reached chunk limit for element: ${element.name}\")\n                break\n            }\n            \n            val chunkEnd = minOf(block.endLine, element.endLine)\n            \n            if (chunkEnd <= currentChunkStart || chunkEnd - currentChunkStart < 3) {\n                continue\n            }\n            \n            try {\n                val chunkContent = buildSubChunkContentMinimal(\n                    element, analysis, fileLines, contextualInfo,\n                    currentChunkStart, chunkEnd\n                )\n                \n                if (chunkContent.length > maxContentLength) {\n                    println(\"      Chunk content too large, truncating: ${element.name}\")\n                    continue\n                }\n                \n                val tokens = estimateTokens(chunkContent)\n                \n                val chunk = ChunkMetadata(\n                    filePath = analysis.filePath,\n                    className = findContainingClassName(element, analysis),\n                    methodName = if (element.type == ChunkType.FUNCTION) element.name else null,\n                    startLine = currentChunkStart,\n                    endLine = chunkEnd,\n                    content = chunkContent,\n                    chunkType = ChunkType.SUB_CHUNK,\n                    tokens = tokens,\n                    contextualInfo = contextualInfo\n                )\n                \n                // Stream chunk immediately\n                processor.processChunk(chunk)\n                chunkCount++\n                \n                currentChunkStart = chunkEnd - overlapSize + 1\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":153,"endLine":309,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\n                )\n                \n                // Stream chunk immediately\n                processor.processChunk(chunk)\n                chunkCount++\n                \n                currentChunkStart = chunkEnd - overlapSize + 1\n                \n            } catch (e: OutOfMemoryError) {\n                println(\"      OutOfMemoryError creating sub-chunk for ${element.name}\")\n                System.gc()\n                break\n            } catch (e: Exception) {\n                println(\"      Error creating sub-chunk: ${e.message}\")\n                continue\n            }\n        }\n        \n        return chunkCount\n    }\n    \n    /**\n     * Process a single chunk and stream it immediately.\n     */\n    private fun processSingleChunkStreaming(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        processor: ChunkProcessor\n    ) {\n        try {\n            val chunkContent = buildChunkContentMinimal(element, analysis, fileLines, contextualInfo)\n            \n            if (chunkContent.length > maxContentLength) {\n                println(\"      Single chunk too large, skipping: ${element.name}\")\n                return\n            }\n            \n            val tokens = estimateTokens(chunkContent)\n            \n            val chunk = ChunkMetadata(\n                filePath = analysis.filePath,\n                className = findContainingClassName(element, analysis),\n                methodName = if (element.type == ChunkType.FUNCTION) element.name else null,\n                startLine = element.startLine,\n                endLine = element.endLine,\n                content = chunkContent,\n                chunkType = element.type,\n                tokens = tokens,\n                contextualInfo = contextualInfo\n            )\n            \n            // Stream chunk immediately\n            processor.processChunk(chunk)\n            \n        } catch (e: OutOfMemoryError) {\n            println(\"      OutOfMemoryError creating chunk for ${element.name}\")\n            System.gc()\n        } catch (e: Exception) {\n            println(\"      Error creating chunk: ${e.message}\")\n        }\n    }\n    \n    /**\n     * Find simple logical blocks without complex analysis to save memory.\n     */\n    private fun findSimpleBlocks(elementLines: List<String>, baseLineIndex: Int): List<LogicalBlock> {\n        val blocks = mutableListOf<LogicalBlock>()\n        \n        // Simple approach: split by fixed size chunks if no logical blocks found\n        val chunkSize = maxChunkSize / 2\n        for (i in 0 until elementLines.size step chunkSize) {\n            val endIndex = minOf(i + chunkSize, elementLines.size)\n            blocks.add(LogicalBlock(\n                baseLineIndex + i + 1,\n                baseLineIndex + endIndex,\n                BlockType.SEQUENTIAL\n            ))\n        }\n        \n        return blocks.take(10) // Limit number of blocks\n    }\n    \n    /**\n     * Build minimal contextual info to save memory.\n     */\n    private fun buildContextualInfoMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis\n    ): ContextualInfo {\n        return ContextualInfo(\n            packageDeclaration = analysis.packageDeclaration,\n            imports = analysis.imports.take(3), // Only first 3 imports\n            classSignature = findContainingClassName(element, analysis)?.let { \"$it class signature\" },\n            relatedPrivateMethods = emptyList() // Skip to save memory\n        )\n    }\n    \n    /**\n     * Build minimal chunk content to prevent memory issues.\n     */\n    private fun buildChunkContentMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo\n    ): String {\n        val content = StringBuilder(2000) // Small initial capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n            content.appendLine()\n        }\n        \n        // Add only essential imports (first 2)\n        contextualInfo.imports.take(2).forEach { import ->\n            content.appendLine(\"import $import\")\n        }\n        if (contextualInfo.imports.isNotEmpty()) content.appendLine()\n        \n        // Add the element content with size limits\n        try {\n            val elementContent = extractElementContentSafe(element, fileLines)\n            if (content.length + elementContent.length > maxContentLength) {\n                val availableSpace = maxContentLength - content.length - 50\n                if (availableSpace > 50) {\n                    content.append(elementContent.take(availableSpace))\n                    content.append(\"\\n// ... truncated ...\")\n                }\n            } else {\n                content.append(elementContent)\n            }\n        } catch (e: Exception) {\n            content.append(\"// Error extracting content: ${e.message}\")\n        }\n        \n        return content.toString()\n    }\n    \n    /**\n     * Build minimal sub-chunk content.\n     */\n    private fun buildSubChunkContentMinimal(\n        element: CodeElement,\n        analysis: FileAnalysis,\n        fileLines: List<String>,\n        contextualInfo: ContextualInfo,\n        startLine: Int,\n        endLine: Int\n    ): String {\n        val content = StringBuilder(1500) // Small capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/Chunker.kt","className":null,"methodName":null,"startLine":303,"endLine":375,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n// CLASS: Chunker\nclass Chunker(\n    private val parser: KotlinCodeParser = KotlinCodeParser(),\n\n        endLine: Int\n    ): String {\n        val content = StringBuilder(1500) // Small capacity\n        \n        // Add minimal context\n        contextualInfo.packageDeclaration?.let {\n            content.appendLine(\"package $it\")\n        }\n        \n        // Add element signature\n        content.appendLine(\"// ${element.type.name}: ${element.name}\")\n        content.appendLine(element.signature.take(150)) // Truncated signature\n        content.appendLine()\n        \n        // Add sub-chunk content with bounds checking\n        try {\n            val actualStartLine = maxOf(0, startLine - 1)\n            val actualEndLine = minOf(fileLines.size, endLine)\n            \n            if (actualStartLine < actualEndLine) {\n                val subChunkLines = fileLines.subList(actualStartLine, actualEndLine)\n                \n                var currentLength = content.length\n                for (line in subChunkLines) {\n                    if (currentLength + line.length + 1 > maxContentLength) {\n                        content.appendLine(\"// ... truncated ...\")\n                        break\n                    }\n                    content.appendLine(line)\n                    currentLength = content.length\n                }\n            }\n        } catch (e: Exception) {\n            content.appendLine(\"// Error extracting sub-chunk: ${e.message}\")\n        }\n        \n        return content.toString()\n    }\n    \n    /**\n     * Safe element content extraction with error handling.\n     */\n    private fun extractElementContentSafe(element: CodeElement, fileLines: List<String>): String {\n        return try {\n            if (element.startLine <= 0 || element.endLine > fileLines.size || element.startLine > element.endLine) {\n                \"// Invalid line numbers: ${element.startLine}-${element.endLine}\"\n            } else {\n                fileLines.subList(element.startLine - 1, element.endLine).joinToString(\"\\n\")\n            }\n        } catch (e: Exception) {\n            \"// Error extracting content: ${e.message}\"\n        }\n    }\n    \n    /**\n     * Find containing class name without complex analysis.\n     */\n    private fun findContainingClassName(element: CodeElement, analysis: FileAnalysis): String? {\n        return analysis.elements.find { classElement ->\n            (classElement.type == ChunkType.CLASS || classElement.type == ChunkType.INTERFACE) &&\n            classElement.startLine <= element.startLine &&\n            classElement.endLine >= element.endLine &&\n            classElement != element\n        }?.name\n    }\n    \n    /**\n     * Simple token estimation.\n     */\n    private fun estimateTokens(content: String): Int {\n        return minOf(content.length / 4, 1000) // Cap at 1000 tokens\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":726,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["com.example.mindweaverstudio.data.utils.ragchunking.models.*","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/logic/RepositoryScanner.kt","className":null,"methodName":null,"startLine":9,"endLine":195,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.logic\n\nimport java.io.File\n\nclass RepositoryScanner(\n    private val chunker: Chunker = Chunker()\n) {\n\n    private val supportedExtensions = setOf(\".kt\", \".java\")\n    private val excludedDirectories = setOf(\n        \"build\", \"target\", \".gradle\", \".idea\", \".git\", \"node_modules\",\n        \".vscode\", \"out\", \"bin\", \"generated\", \"resources\"\n    )\n\n    /**\n     * Scan repository and stream chunks to processor immediately.\n     * This prevents memory accumulation by not keeping chunks in memory.\n     */\n    fun scanRepositoryStreaming(\n        rootPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ) {\n        val rootFile = File(rootPath)\n        if (!rootFile.exists() || !rootFile.isDirectory) {\n            throw IllegalArgumentException(\"Invalid repository path: $rootPath\")\n        }\n\n        val sourceFiles = findSourceFiles(rootFile, includeTests)\n\n        println(\"Found ${sourceFiles.size} source files to process...\")\n        println(\"Using streaming mode to avoid memory issues...\")\n\n        // Process files one by one, immediately streaming chunks to processor\n        sourceFiles.forEachIndexed { index, file ->\n            try {\n                // Skip very large files to prevent memory issues\n                val fileSize = file.length()\n                if (fileSize > 500_000) { // 500KB limit\n                    println(\"Skipping large file: ${file.name} (${fileSize / 1024}KB)\")\n                    processor.onFileComplete(file.absolutePath, 0)\n                    return@forEachIndexed\n                }\n\n                print(\"Processing file ${index + 1}/${sourceFiles.size}: ${file.name}...\")\n\n                // Process file with true streaming - no chunk lists created at all!\n                val chunkCount = chunker.processFileStreaming(file, processor)\n\n                println(\" ✓ ${chunkCount} chunks\")\n                processor.onFileComplete(file.absolutePath, chunkCount)\n\n                // No objects to clean up - everything was streamed directly!\n\n                // Suggest GC every 20 files to help with memory pressure\n                if ((index + 1) % 20 == 0) {\n                    System.gc()\n\n                    // Print memory status\n                    val runtime = Runtime.getRuntime()\n                    val usedMemory = runtime.totalMemory() - runtime.freeMemory()\n                    val maxMemory = runtime.maxMemory()\n                    val memoryPercent = (usedMemory.toDouble() / maxMemory * 100).toInt()\n                    println(\"  Memory usage: ${memoryPercent}%\")\n                }\n\n            } catch (e: Exception) {\n                println(\"Error processing file ${file.absolutePath}: ${e.message}\")\n                processor.onFileComplete(file.absolutePath, 0)\n            }\n        }\n\n        // Notify processor that all processing is complete\n        processor.onComplete()\n\n        val stats = processor.getStatistics()\n        println(\"\\nStreaming scan complete:\")\n        println(\"- Files processed: ${stats.totalFiles}\")\n        println(\"- Chunks generated: ${stats.totalChunks}\")\n        println(\"- Average chunks per file: ${stats.totalChunks / stats.totalFiles.coerceAtLeast(1)}\")\n        println(\"- Files skipped: ${stats.skippedFiles}\")\n        println(\"- Files with errors: ${stats.errorFiles}\")\n    }\n\n    /**\n     * Scan single file in streaming mode.\n     */\n    fun scanFileStreaming(\n        filePath: String,\n        processor: ChunkProcessor\n    ) {\n        val file = File(filePath)\n        if (!file.exists() || !file.isFile) {\n            throw IllegalArgumentException(\"Invalid file path: $filePath\")\n        }\n\n        if (!isSupportedFile(file)) {\n            throw IllegalArgumentException(\"Unsupported file type: ${file.extension}\")\n        }\n\n        println(\"Processing single file: ${file.name}\")\n\n        try {\n            val chunkCount = chunker.processFileStreaming(file, processor)\n            processor.onFileComplete(file.absolutePath, chunkCount)\n            println(\"Generated ${chunkCount} chunks\")\n\n        } catch (e: Exception) {\n            println(\"Error processing file: ${e.message}\")\n            processor.onFileComplete(file.absolutePath, 0)\n        }\n\n        processor.onComplete()\n    }\n\n    /**\n     * Scan directory in streaming mode.\n     */\n    fun scanDirectoryStreaming(\n        directoryPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ) {\n        val directory = File(directoryPath)\n        if (!directory.exists() || !directory.isDirectory) {\n            throw IllegalArgumentException(\"Invalid directory path: $directoryPath\")\n        }\n\n        val sourceFiles = findSourceFiles(directory, includeTests)\n\n        println(\"Processing directory: $directoryPath\")\n        println(\"Found ${sourceFiles.size} source files\")\n\n        sourceFiles.forEachIndexed { index, file ->\n            try {\n                print(\"Processing ${index + 1}/${sourceFiles.size}: ${file.name}...\")\n\n                val chunkCount = chunker.processFileStreaming(file, processor)\n                processor.onFileComplete(file.absolutePath, chunkCount)\n                println(\" ✓ ${chunkCount} chunks\")\n\n            } catch (e: Exception) {\n                println(\"Error processing file ${file.absolutePath}: ${e.message}\")\n                processor.onFileComplete(file.absolutePath, 0)\n            }\n        }\n\n        processor.onComplete()\n    }\n\n    private fun findSourceFiles(rootDirectory: File, includeTests: Boolean): List<File> {\n        val sourceFiles = mutableListOf<File>()\n\n        rootDirectory.walkTopDown()\n            .filter { file ->\n                // Skip excluded directories\n                !shouldExcludeDirectory(file, rootDirectory) &&\n                // Include only supported files\n                file.isFile && isSupportedFile(file) &&\n                // Filter test files if needed\n                (includeTests || !isTestFile(file))\n            }\n            .forEach { file ->\n                sourceFiles.add(file)\n            }\n\n        return sourceFiles\n    }\n\n    private fun shouldExcludeDirectory(file: File, rootDirectory: File): Boolean {\n        val relativePath = file.relativeTo(rootDirectory).path\n        return excludedDirectories.any { excludedDir ->\n            relativePath.startsWith(excludedDir) || relativePath.contains(\"/$excludedDir/\")\n        }\n    }\n\n    private fun isSupportedFile(file: File): Boolean {\n        return supportedExtensions.any { extension ->\n            file.name.endsWith(extension)\n        }\n    }\n\n    private fun isTestFile(file: File): Boolean {\n        val fileName = file.name.lowercase()\n        val pathComponents = file.path.lowercase().split(File.separator)\n\n        return fileName.contains(\"test\") ||\n                fileName.contains(\"spec\") ||\n                pathComponents.any { it == \"test\" || it == \"tests\" || it.contains(\"test\") }\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.logic","imports":["java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/ChunkMetadata.kt","className":null,"methodName":null,"startLine":6,"endLine":36,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class ChunkMetadata(\n    val filePath: String,\n    val className: String? = null,\n    val methodName: String? = null,\n    val startLine: Int,\n    val endLine: Int,\n    val content: String,\n    val chunkType: ChunkType,\n    val tokens: Int,\n    val overlapsWithPrevious: Boolean = false,\n    val contextualInfo: ContextualInfo\n)\n\n@Serializable\ndata class ContextualInfo(\n    val packageDeclaration: String? = null,\n    val imports: List<String> = emptyList(),\n    val classSignature: String? = null,\n    val relatedPrivateMethods: List<String> = emptyList()\n)\n\n@Serializable\nenum class ChunkType {\n    CLASS,\n    INTERFACE,\n    ENUM,\n    METHOD,\n    FUNCTION,\n    PROPERTY,\n    SUB_CHUNK\n}","chunkType":"CLASS","tokens":201,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/ChunkMetadata.kt","className":null,"methodName":null,"startLine":39,"endLine":67,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class CodeElement(\n    val type: ChunkType,\n    val name: String,\n    val startLine: Int,\n    val endLine: Int,\n    val signature: String,\n    val modifiers: List<String> = emptyList(),\n    val isPrivate: Boolean = false,\n    val documentation: String? = null\n)\n\n@Serializable\ndata class FileAnalysis(\n    val filePath: String,\n    val packageDeclaration: String?,\n    val imports: List<String>,\n    val elements: List<CodeElement>,\n    val totalLines: Int\n)\n\ndata class LogicalBlock(\n    val startLine: Int,\n    val endLine: Int,\n    val type: BlockType\n)\n\nenum class BlockType {\n    CONDITIONAL, LOOP, EXCEPTION, WHEN, SEQUENTIAL\n}","chunkType":"CLASS","tokens":187,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/models/RAGDocument.kt","className":null,"methodName":null,"startLine":6,"endLine":10,"content":"package com.example.mindweaverstudio.data.utils.ragchunking.models\n\nimport kotlinx.serialization.Serializable\n\ndata class RAGDocument(\n    val id: String,\n    val content: String,\n    val metadata: Map<String, String>\n)","chunkType":"CLASS","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking.models","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/RAGChunkingUtility.kt","className":null,"methodName":null,"startLine":11,"endLine":160,"content":"package com.example.mindweaverstudio.data.utils.ragchunking\n// CLASS: RAGChunkingUtility\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n    largeElementThreshold: Int = 200,\n    overlapSize: Int = 7,\n    maxContentLength: Int = 10000\n) {\n    \n    private val chunker = Chunker(\n        maxChunkSize = maxChunkSize,\n        largeElementThreshold = largeElementThreshold,\n        overlapSize = overlapSize,\n        maxContentLength = maxContentLength\n    )\n    \n    private val scanner = RepositoryScanner(chunker)\n    \n    /**\n     * Process an entire repository with streaming output to avoid memory issues.\n     * Chunks are written to output files immediately as they're generated.\n     */\n    fun chunkRepositoryStreaming(\n        repositoryPath: String,\n        outputPath: String,\n        includeTests: Boolean = true,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Starting streaming repository chunking...\")\n        println(\"Repository: $repositoryPath\")\n        println(\"Output: $outputPath\")\n        println(\"Include tests: $includeTests\")\n        println()\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process repository with RAG-optimized streaming output.\n     * Creates batched JSON files suitable for RAG pipelines.\n     */\n    fun chunkRepositoryForRAGStreaming(\n        repositoryPath: String,\n        outputBasePath: String,\n        batchSize: Int = 1000,\n        includeTests: Boolean = true\n    ): StreamingStatistics {\n        println(\"Starting streaming RAG repository chunking...\")\n        println(\"Repository: $repositoryPath\")\n        println(\"Output base: $outputBasePath\")\n        println(\"Batch size: $batchSize\")\n        println(\"Include tests: $includeTests\")\n        println()\n        \n        val processor = RAGExporter(outputBasePath, batchSize)\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process a single file with streaming output.\n     */\n    fun chunkFileStreaming(\n        filePath: String,\n        outputPath: String,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Processing single file: $filePath\")\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanFileStreaming(filePath, processor)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process a directory with streaming output.\n     */\n    fun chunkDirectoryStreaming(\n        directoryPath: String,\n        outputPath: String,\n        includeTests: Boolean = true,\n        includeMetadata: Boolean = true\n    ): StreamingStatistics {\n        println(\"Processing directory: $directoryPath\")\n        \n        val processor = JsonExporter(outputPath, includeMetadata)\n        scanner.scanDirectoryStreaming(directoryPath, processor, includeTests)\n        \n        return processor.getStatistics()\n    }\n    \n    /**\n     * Process with custom streaming processor.\n     * Allows for custom handling of chunks (e.g., direct database insertion).\n     */\n    fun chunkWithCustomProcessor(\n        repositoryPath: String,\n        processor: ChunkProcessor,\n        includeTests: Boolean = true\n    ): StreamingStatistics {\n        scanner.scanRepositoryStreaming(repositoryPath, processor, includeTests)\n        return processor.getStatistics()\n    }\n    \n    /**\n     * Complete streaming workflow: chunk repository and create both regular and RAG outputs.\n     */\n    fun processRepositoryStreaming(\n        repositoryPath: String,\n        outputBasePath: String,\n        includeTests: Boolean = true,\n        createRAGOutput: Boolean = true,\n        ragBatchSize: Int = 1000\n    ) {\n        println(\"=== Streaming RAG Chunking Utility ===\")\n        println(\"Processing repository: $repositoryPath\")\n        println(\"Memory-efficient streaming mode\")\n        println()\n        \n        // Create output directory\n        val outputDir = File(outputBasePath).parentFile\n        outputDir?.mkdirs()\n        \n        // Process with regular JSON output\n        val regularOutputPath = \"${outputBasePath}_chunks.json\"\n        println(\"1. Creating regular JSON output...\")\n        val regularStats = chunkRepositoryStreaming(repositoryPath, regularOutputPath, includeTests)\n        \n        if (createRAGOutput) {\n            println(\"\\n2. Creating RAG-optimized output...\")\n            val ragOutputPath = \"${outputBasePath}_rag.json\"\n            val ragStats = chunkRepositoryForRAGStreaming(\n                repositoryPath, ragOutputPath, ragBatchSize, includeTests\n            )\n            \n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            println(\"- RAG batches: ${ragOutputPath.replace(\".json\", \"_batch_*.json\")}\")\n            \n            printStatistics(regularStats, \"Regular Export\")\n            printStatistics(ragStats, \"RAG Export\")\n        } else {\n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            \n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking","imports":["com.example.mindweaverstudio.data.utils.ragchunking.logic.Chunker","com.example.mindweaverstudio.data.utils.ragchunking.logic.RepositoryScanner","com.example.mindweaverstudio.data.utils.ragchunking.logic.ChunkProcessor"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/ragchunking/RAGChunkingUtility.kt","className":null,"methodName":null,"startLine":154,"endLine":233,"content":"package com.example.mindweaverstudio.data.utils.ragchunking\n// CLASS: RAGChunkingUtility\nclass RAGChunkingUtility(\n    maxChunkSize: Int = 300,\n\n            printStatistics(regularStats, \"Regular Export\")\n            printStatistics(ragStats, \"RAG Export\")\n        } else {\n            println(\"\\n=== Processing Complete ===\")\n            println(\"Files created:\")\n            println(\"- Regular chunks: $regularOutputPath\")\n            \n            printStatistics(regularStats, \"Export\")\n        }\n    }\n    \n    private fun printStatistics(stats: StreamingStatistics, label: String) {\n        println(\"\\n=== $label Statistics ===\")\n        println(\"Files processed: ${stats.totalFiles}\")\n        println(\"Chunks generated: ${stats.totalChunks}\")\n        println(\"Total tokens: ${stats.totalTokens}\")\n        println(\"Average tokens per chunk: ${stats.averageTokensPerChunk}\")\n        println(\"Largest chunk: ${stats.largestChunkTokens} tokens\")\n        println(\"Smallest chunk: ${if (stats.smallestChunkTokens == Int.MAX_VALUE) 0 else stats.smallestChunkTokens} tokens\")\n        println(\"Chunks with overlap: ${stats.chunksWithOverlap}\")\n        println(\"Files skipped: ${stats.skippedFiles}\")\n        println(\"Files with errors: ${stats.errorFiles}\")\n        println()\n        println(\"Chunks by type:\")\n        stats.chunksByType.entries.sortedByDescending { it.value }.forEach { (type, count) ->\n            println(\"  $type: $count\")\n        }\n        println()\n    }\n    \n    companion object Companion {\n        /**\n         * Quick utility method to chunk the current project with streaming.\n         */\n        fun chunkCurrentProjectStreaming(\n            outputDir: String = \"./rag_chunks\",\n            includeTests: Boolean = false,\n            ragBatchSize: Int = 1000\n        ) {\n            val utility = RAGChunkingUtility()\n            val currentDir = System.getProperty(\"user.dir\")\n            \n            File(outputDir).mkdirs()\n            \n            utility.processRepositoryStreaming(\n                repositoryPath = currentDir,\n                outputBasePath = \"$outputDir/mindweaver_studio\",\n                includeTests = includeTests,\n                createRAGOutput = true,\n                ragBatchSize = ragBatchSize\n            )\n        }\n        \n        /**\n         * Create a streaming utility with custom configuration.\n         */\n        fun create(\n            maxChunkSize: Int = 300,\n            largeElementThreshold: Int = 200,\n            overlapSize: Int = 7,\n            maxContentLength: Int = 10000\n        ): RAGChunkingUtility {\n            return RAGChunkingUtility(\n                maxChunkSize, largeElementThreshold, overlapSize, maxContentLength\n            )\n        }\n        \n        /**\n         * Create a memory-optimized streaming utility for large repositories.\n         */\n        fun createMemoryOptimized(): RAGChunkingUtility {\n            return RAGChunkingUtility(\n                maxChunkSize = 150,           // Smaller chunks\n                largeElementThreshold = 80,   // Split earlier\n                overlapSize = 3,              // Minimal overlap\n                maxContentLength = 3000       // 3KB limit per chunk\n            )\n        }\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":808,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.ragchunking","imports":["com.example.mindweaverstudio.data.utils.ragchunking.logic.Chunker","com.example.mindweaverstudio.data.utils.ragchunking.logic.RepositoryScanner","com.example.mindweaverstudio.data.utils.ragchunking.logic.ChunkProcessor"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":19,"endLine":168,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\nclass CodeReplacer {\n    \n    /**\n     * Replaces code in a file based on the replacement request.\n     * \n     * @param request The replacement request containing file path, original code, new code, and options\n     * @return ReplacementResult indicating success, error, or other outcomes\n     */\n    suspend fun replaceCode(request: ReplacementRequest): ReplacementResult = withContext(Dispatchers.IO) {\n        try {\n            // Validate the request\n            when (val validation = request.validate()) {\n                is ReplacementValidation.Invalid -> {\n                    return@withContext ReplacementResult.Error(validation.message)\n                }\n                is ReplacementValidation.Valid -> {\n                    // Continue with replacement\n                }\n            }\n            \n            val filePath = request.getPath()\n            \n            // Check if file exists and is readable\n            if (!validateFile(filePath)) {\n                return@withContext ReplacementResult.Error(\n                    \"File does not exist or is not readable: ${request.filePath}\"\n                )\n            }\n            \n            // Read file content\n            val originalContent = try {\n                filePath.readText()\n            } catch (e: IOException) {\n                return@withContext ReplacementResult.Error(\n                    \"Failed to read file: ${e.message}\",\n                    cause = e,\n                    filePath = request.filePath\n                )\n            }\n            \n            // Process line endings if requested\n            val processedOriginalCode = if (request.options.normalizeLineEndings) {\n                normalizeLineEndings(request.originalCode)\n            } else {\n                request.originalCode\n            }\n            \n            val processedContent = if (request.options.normalizeLineEndings) {\n                normalizeLineEndings(originalContent)\n            } else {\n                originalContent\n            }\n            \n            // Find matches\n            val matches = findMatches(processedContent, processedOriginalCode, request.options)\n            \n            when {\n                matches.isEmpty() -> {\n                    ReplacementResult.NotFound(\n                        filePath = request.filePath,\n                        originalCode = request.originalCode,\n                        searchedLines = processedContent.lines().size\n                    )\n                }\n                \n                matches.size > 1 && !request.options.allowMultipleMatches -> {\n                    ReplacementResult.MultipleMatches(\n                        filePath = request.filePath,\n                        matches = matches,\n                        message = \"Found ${matches.size} matches. Use allowMultipleMatches=true to replace all.\"\n                    )\n                }\n                \n                request.options.dryRun -> {\n                    val previewContent = performReplacement(processedContent, matches, request.newCode)\n                    ReplacementResult.DryRun(\n                        filePath = request.filePath,\n                        matchesFound = matches.size,\n                        matches = matches,\n                        previewContent = previewContent,\n                        message = \"Dry run: Would replace ${matches.size} occurrence(s)\"\n                    )\n                }\n                \n                request.originalCode == request.newCode -> {\n                    ReplacementResult.NoChange(\n                        filePath = request.filePath,\n                        message = \"No changes made - original and new code are identical\"\n                    )\n                }\n                \n                else -> {\n                    // Perform actual replacement\n                    performFileReplacement(request, processedContent, matches)\n                }\n            }\n            \n        } catch (e: Exception) {\n            ReplacementResult.Error(\n                message = \"Unexpected error during replacement: ${e.message}\",\n                cause = e,\n                filePath = request.filePath\n            )\n        }\n    }\n    \n    /**\n     * Validates that the file exists and is readable.\n     */\n    private fun validateFile(filePath: Path): Boolean {\n        return filePath.exists() && filePath.isRegularFile() && Files.isReadable(filePath)\n    }\n    \n    /**\n     * Normalizes line endings to \\n.\n     */\n    private fun normalizeLineEndings(text: String): String {\n        return text.replace(\"\\r\\n\", \"\\n\").replace(\"\\r\", \"\\n\")\n    }\n    \n    /**\n     * Finds all matches of the original code in the file content.\n     */\n    private fun findMatches(\n        content: String,\n        originalCode: String,\n        options: ReplacementOptions\n    ): List<ReplacementMatch> {\n        val matches = mutableListOf<ReplacementMatch>()\n        val lines = content.lines()\n        \n        if (options.exactMatch) {\n            // Find exact string matches\n            var searchIndex = 0\n            while (true) {\n                val matchIndex = content.indexOf(originalCode, searchIndex)\n                if (matchIndex == -1) break\n                \n                val match = createReplacementMatch(content, lines, matchIndex, originalCode.length)\n                matches.add(match)\n                \n                searchIndex = matchIndex + originalCode.length\n            }\n        } else {\n            // For non-exact matching, we could add fuzzy logic here in the future\n            // For now, fallback to exact matching\n            return findMatches(content, originalCode, options.copy(exactMatch = true))\n        }\n        \n        return matches\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":162,"endLine":318,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\n        } else {\n            // For non-exact matching, we could add fuzzy logic here in the future\n            // For now, fallback to exact matching\n            return findMatches(content, originalCode, options.copy(exactMatch = true))\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Creates a ReplacementMatch object for a found match.\n     */\n    private fun createReplacementMatch(\n        content: String,\n        lines: List<String>,\n        matchIndex: Int,\n        matchLength: Int\n    ): ReplacementMatch {\n        val beforeMatch = content.substring(0, matchIndex)\n        val afterMatch = content.substring(matchIndex + matchLength)\n        val matchedText = content.substring(matchIndex, matchIndex + matchLength)\n        \n        // Calculate line and column positions\n        val startLine = beforeMatch.count { it == '\\n' } + 1\n        val lastNewlineBeforeMatch = beforeMatch.lastIndexOf('\\n')\n        val startColumn = if (lastNewlineBeforeMatch == -1) {\n            matchIndex + 1\n        } else {\n            matchIndex - lastNewlineBeforeMatch\n        }\n        \n        val matchContent = content.substring(matchIndex, matchIndex + matchLength)\n        val endLine = startLine + matchContent.count { it == '\\n' }\n        val endColumn = if (matchContent.contains('\\n')) {\n            val lastNewlineInMatch = matchContent.lastIndexOf('\\n')\n            matchContent.length - lastNewlineInMatch\n        } else {\n            startColumn + matchContent.length - 1\n        }\n        \n        // Get context lines\n        val contextBefore = getContextLines(lines, startLine - 1, -2, 0)\n        val contextAfter = getContextLines(lines, endLine - 1, 1, 2)\n        \n        return ReplacementMatch(\n            startLine = startLine,\n            endLine = endLine,\n            startColumn = startColumn,\n            endColumn = endColumn,\n            matchedText = matchedText,\n            contextBefore = contextBefore,\n            contextAfter = contextAfter\n        )\n    }\n    \n    /**\n     * Gets context lines around a match.\n     */\n    private fun getContextLines(\n        lines: List<String>,\n        centerLine: Int,\n        startOffset: Int,\n        endOffset: Int\n    ): String {\n        val start = maxOf(0, centerLine + startOffset)\n        val end = minOf(lines.size - 1, centerLine + endOffset)\n        \n        return (start..end).mapNotNull { index ->\n            lines.getOrNull(index)\n        }.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Performs the actual text replacement.\n     */\n    private fun performReplacement(\n        content: String,\n        matches: List<ReplacementMatch>,\n        newCode: String\n    ): String {\n        var result = content\n        \n        // Replace matches in reverse order to maintain correct indices\n        matches.sortedByDescending { match ->\n            content.indexOf(match.matchedText)\n        }.forEach { match ->\n            val matchIndex = result.indexOf(match.matchedText)\n            if (matchIndex != -1) {\n                result = result.substring(0, matchIndex) + \n                        newCode + \n                        result.substring(matchIndex + match.matchedText.length)\n            }\n        }\n        \n        return result\n    }\n    \n    /**\n     * Performs the file replacement with backup and safety checks.\n     */\n    private suspend fun performFileReplacement(\n        request: ReplacementRequest,\n        content: String,\n        matches: List<ReplacementMatch>\n    ): ReplacementResult = withContext(Dispatchers.IO) {\n        val filePath = request.getPath()\n        var backupPath: String? = null\n        \n        try {\n            // Create backup if requested\n            if (request.options.createBackup) {\n                backupPath = createBackup(filePath)\n            }\n            \n            // Perform replacement\n            val newContent = performReplacement(content, matches, request.newCode)\n            \n            // Write the new content atomically\n            writeFileAtomically(filePath, newContent)\n            \n            ReplacementResult.Success(\n                filePath = request.filePath,\n                matchesFound = matches.size,\n                matchesReplaced = matches.size,\n                backupPath = backupPath,\n                message = \"Successfully replaced ${matches.size} occurrence(s) in ${request.filePath}\"\n            )\n            \n        } catch (e: Exception) {\n            // If we created a backup and something went wrong, try to restore\n            if (backupPath != null) {\n                try {\n                    Files.copy(\n                        Path.of(backupPath),\n                        filePath,\n                        StandardCopyOption.REPLACE_EXISTING\n                    )\n                } catch (restoreException: Exception) {\n                    // Log but don't override the original exception\n                }\n            }\n            \n            ReplacementResult.Error(\n                message = \"Failed to replace code: ${e.message}\",\n                cause = e,\n                filePath = request.filePath\n            )\n        }\n    }\n    \n    /**\n     * Creates a backup of the file.\n     */\n    private fun createBackup(filePath: Path): String {\n        val timestamp = System.currentTimeMillis()\n        val backupPath = Path.of(\"${filePath}.backup.$timestamp\")\n        Files.copy(filePath, backupPath, StandardCopyOption.COPY_ATTRIBUTES)\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacer.kt","className":null,"methodName":null,"startLine":312,"endLine":345,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n// CLASS: CodeReplacer\nclass CodeReplacer {\n\n    /**\n     * Creates a backup of the file.\n     */\n    private fun createBackup(filePath: Path): String {\n        val timestamp = System.currentTimeMillis()\n        val backupPath = Path.of(\"${filePath}.backup.$timestamp\")\n        Files.copy(filePath, backupPath, StandardCopyOption.COPY_ATTRIBUTES)\n        return backupPath.toString()\n    }\n    \n    /**\n     * Writes content to file atomically by writing to a temporary file first.\n     */\n    private fun writeFileAtomically(filePath: Path, content: String) {\n        val tempPath = Path.of(\"${filePath}.tmp.${System.currentTimeMillis()}\")\n        \n        try {\n            // Write to temporary file\n            tempPath.writeText(content)\n            \n            // Atomically move temporary file to target\n            Files.move(tempPath, filePath, StandardCopyOption.REPLACE_EXISTING)\n            \n        } catch (e: Exception) {\n            // Clean up temporary file if something went wrong\n            try {\n                Files.deleteIfExists(tempPath)\n            } catch (cleanupException: Exception) {\n                // Ignore cleanup errors\n            }\n            throw e\n        }\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":318,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*","kotlinx.coroutines.Dispatchers","kotlinx.coroutines.withContext"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":9,"endLine":38,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\ndata class ReplacementRequest(\n    val filePath: String,\n    val originalCode: String,\n    val newCode: String,\n    val options: ReplacementOptions = ReplacementOptions()\n) {\n    /**\n     * Gets the file path as a Path object.\n     */\n    fun getPath(): Path = Paths.get(filePath)\n    \n    /**\n     * Validates the request parameters.\n     */\n    fun validate(): ReplacementValidation {\n        if (filePath.isBlank()) {\n            return ReplacementValidation.Invalid(\"File path cannot be blank\")\n        }\n        \n        if (originalCode.isBlank()) {\n            return ReplacementValidation.Invalid(\"Original code cannot be blank\")\n        }\n        \n        if (originalCode == newCode && !options.allowNoChange) {\n            return ReplacementValidation.Invalid(\"Original and new code are identical\")\n        }\n        \n        return ReplacementValidation.Valid\n    }\n}","chunkType":"CLASS","tokens":250,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":43,"endLine":46,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\nsealed class ReplacementValidation {\n    object Valid : ReplacementValidation()\n    data class Invalid(val message: String) : ReplacementValidation()\n}","chunkType":"CLASS","tokens":68,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementRequest.kt","className":null,"methodName":null,"startLine":51,"endLine":60,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nimport java.nio.file.Path\nimport java.nio.file.Paths\n\ndata class ReplacementOptions(\n    val exactMatch: Boolean = true,                    // Require exact string match\n    val preserveWhitespace: Boolean = true,            // Preserve original whitespace\n    val normalizeLineEndings: Boolean = true,          // Normalize line endings\n    val allowMultipleMatches: Boolean = false,         // Allow multiple occurrences to be replaced\n    val allowNoChange: Boolean = false,                // Allow originalCode == newCode\n    val createBackup: Boolean = false,                 // Create backup file before modification\n    val validateSyntax: Boolean = false,               // Validate Kotlin syntax after replacement\n    val dryRun: Boolean = false                        // Only simulate replacement, don't write\n)","chunkType":"CLASS","tokens":222,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":["java.nio.file.Path","java.nio.file.Paths"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":null,"startLine":6,"endLine":63,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nsealed class ReplacementResult {\n    /**\n     * Successful replacement.\n     */\n    data class Success(\n        val filePath: String,\n        val matchesFound: Int,\n        val matchesReplaced: Int,\n        val backupPath: String? = null,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * Code fragment not found in the file.\n     */\n    data class NotFound(\n        val filePath: String,\n        val originalCode: String,\n        val searchedLines: Int\n    ) : ReplacementResult()\n    \n    /**\n     * Multiple matches found but allowMultipleMatches is false.\n     */\n    data class MultipleMatches(\n        val filePath: String,\n        val matches: List<ReplacementMatch>,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * Error during replacement operation.\n     */\n    data class Error(\n        val message: String,\n        val cause: Throwable? = null,\n        val filePath: String? = null\n    ) : ReplacementResult()\n    \n    /**\n     * Dry run result - shows what would happen without making changes.\n     */\n    data class DryRun(\n        val filePath: String,\n        val matchesFound: Int,\n        val matches: List<ReplacementMatch>,\n        val previewContent: String,\n        val message: String\n    ) : ReplacementResult()\n    \n    /**\n     * No changes were made (originalCode == newCode and allowNoChange is true).\n     */\n    data class NoChange(\n        val filePath: String,\n        val message: String\n    ) : ReplacementResult()\n}","chunkType":"CLASS","tokens":393,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":null,"startLine":68,"endLine":87,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\ndata class ReplacementMatch(\n    val startLine: Int,                    // Line number where match starts (1-based)\n    val endLine: Int,                      // Line number where match ends (1-based)\n    val startColumn: Int,                  // Column where match starts (1-based)\n    val endColumn: Int,                    // Column where match ends (1-based)\n    val matchedText: String,               // The actual matched text\n    val contextBefore: String,             // Lines before the match for context\n    val contextAfter: String               // Lines after the match for context\n) {\n    /**\n     * Gets a human-readable location description.\n     */\n    fun getLocationDescription(): String {\n        return if (startLine == endLine) {\n            \"line $startLine, columns $startColumn-$endColumn\"\n        } else {\n            \"lines $startLine-$endLine\"\n        }\n    }\n}","chunkType":"CLASS","tokens":239,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":92,"endLine":92,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.isSuccess(): Boolean = this is ReplacementResult.Success","chunkType":"FUNCTION","tokens":36,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":93,"endLine":93,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.isError(): Boolean = this is ReplacementResult.Error","chunkType":"FUNCTION","tokens":35,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":94,"endLine":99,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.getErrorMessage(): String? = when (this) {\n    is ReplacementResult.Error -> message\n    is ReplacementResult.NotFound -> \"Code fragment not found in file $filePath\"\n    is ReplacementResult.MultipleMatches -> \"Multiple matches found: $message\"\n    else -> null\n}","chunkType":"FUNCTION","tokens":88,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/models/ReplacementResult.kt","className":null,"methodName":"ReplacementResult","startLine":101,"endLine":106,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.models\n\nfun ReplacementResult.getSuccessMessage(): String? = when (this) {\n    is ReplacementResult.Success -> message\n    is ReplacementResult.DryRun -> message\n    is ReplacementResult.NoChange -> message\n    else -> null\n}","chunkType":"FUNCTION","tokens":71,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"main","startLine":16,"endLine":150,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nfun main() = runBlocking {\n    println(\"=== CodeReplacer Example ===\")\n    println()\n    \n    // Create a test file for demonstration\n    val testFile = createTestFile()\n    println(\"Created test file: $testFile\")\n    println()\n    \n    try {\n        // Example 1: Basic code replacement\n        println(\"1. Basic Code Replacement:\")\n        println(\"=\" .repeat(40))\n        val result1 = CodeReplacerUtils.replaceCodeInFile(\n            filePath = testFile,\n            originalCode = \"fun oldMethod() {\\n        println(\\\"Old implementation\\\")\\n    }\",\n            newCode = \"fun newMethod() {\\n        println(\\\"New and improved implementation\\\")\\n    }\"\n        )\n        println(result1)\n        println()\n        \n        // Example 2: Preview replacement before applying\n        println(\"2. Preview Replacement:\")\n        println(\"=\" .repeat(40))\n        val preview = CodeReplacerUtils.previewReplacement(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Updated Example\\\"\"\n        )\n        println(preview)\n        println()\n        \n        // Example 3: Get detailed preview information\n        println(\"3. Detailed Preview:\")\n        println(\"=\" .repeat(40))\n        val detailedPreview = CodeReplacerUtils.getReplacementPreview(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Updated Example\\\"\"\n        )\n        println(detailedPreview)\n        println()\n        \n        // Example 4: Replace with backup\n        println(\"4. Replace with Backup:\")\n        println(\"=\" .repeat(40))\n        val result4 = CodeReplacerUtils.replaceCodeWithOptions(\n            filePath = testFile,\n            originalCode = \"private val name = \\\"Example\\\"\",\n            newCode = \"private val name = \\\"Backed Up Example\\\"\",\n            createBackup = true,\n            allowMultiple = false\n        )\n        println(result4)\n        println()\n        \n        // Example 5: Find code fragment without replacing\n        println(\"5. Find Code Fragment:\")\n        println(\"=\" .repeat(40))\n        val findResult = CodeReplacerUtils.findCodeFragment(\n            filePath = testFile,\n            codeFragment = \"class ExampleClass\"\n        )\n        println(findResult)\n        println()\n        \n        // Example 6: Multiple replacements in one operation\n        println(\"6. Multiple Replacements:\")\n        println(\"=\" .repeat(40))\n        val replacements = listOf(\n            \"println(\\\"New and improved implementation\\\")\" to \"println(\\\"Latest implementation\\\")\",\n            \"Backed Up Example\" to \"Final Example\"\n        )\n        val multipleResult = CodeReplacerUtils.replaceMultipleFragments(\n            filePath = testFile,\n            replacements = replacements,\n            createBackup = false\n        )\n        println(multipleResult)\n        println()\n        \n        // Example 7: Handle non-existent code\n        println(\"7. Handle Non-Existent Code:\")\n        println(\"=\" .repeat(40))\n        val notFoundResult = CodeReplacerUtils.replaceCodeInFile(\n            filePath = testFile,\n            originalCode = \"nonExistentFunction()\",\n            newCode = \"existentFunction()\"\n        )\n        println(notFoundResult)\n        println()\n        \n        // Example 8: Handle file that doesn't exist\n        println(\"8. Handle Non-Existent File:\")\n        println(\"=\" .repeat(40))\n        val noFileResult = CodeReplacerUtils.replaceCodeInFile(\n            filePath = \"/non/existent/file.kt\",\n            originalCode = \"anything\",\n            newCode = \"something\"\n        )\n        println(noFileResult)\n        println()\n        \n        // Example 9: Using detailed result for advanced handling\n        println(\"9. Advanced Result Handling:\")\n        println(\"=\" .repeat(40))\n        val detailedResult = CodeReplacerUtils.replaceCodeSafely(\n            filePath = testFile,\n            originalCode = \"class ExampleClass\",\n            newCode = \"class AdvancedExampleClass\",\n            options = ReplacementOptions(\n                createBackup = false,\n                dryRun = true  // Just preview\n            )\n        )\n        \n        when (detailedResult) {\n            is com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementResult.DryRun -> {\n                println(\"Would replace ${detailedResult.matchesFound} matches\")\n                println(\"Preview content (first 200 chars):\")\n                println(detailedResult.previewContent.take(200) + \"...\")\n            }\n            else -> println(\"Unexpected result: $detailedResult\")\n        }\n        \n        println(\"\\n\" + \"=\" .repeat(50))\n        println(\"Final file content:\")\n        println(\"=\" .repeat(50))\n        println(Files.readString(Paths.get(testFile)))\n        \n    } finally {\n        // Clean up test file and any backup files\n        cleanup(testFile)\n    }\n}","chunkType":"FUNCTION","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"createTestFile","startLine":155,"endLine":188,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nprivate fun createTestFile(): String {\n    val testContent = \"\"\"\npackage com.example.test\n\nimport kotlin.collections.*\n\n/**\n * Example class for testing code replacement.\n */\nclass ExampleClass {\n    private val name = \"Example\"\n    \n    fun oldMethod() {\n        println(\"Old implementation\")\n    }\n    \n    fun anotherMethod(): String {\n        return \"This method won't be changed\"\n    }\n    \n    companion object {\n        const val VERSION = \"1.0\"\n    }\n}\n\nfun topLevelFunction() {\n    println(\"Top level function\")\n}\n\"\"\".trimIndent()\n    \n    val tempFile = File.createTempFile(\"test_code_replacer\", \".kt\")\n    tempFile.writeText(testContent)\n    return tempFile.absolutePath\n}","chunkType":"FUNCTION","tokens":229,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"cleanup","startLine":193,"endLine":210,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\nprivate fun cleanup(testFile: String) {\n    try {\n        // Delete main test file\n        Files.deleteIfExists(Paths.get(testFile))\n        \n        // Delete any backup files\n        val testDir = File(testFile).parentFile\n        testDir.listFiles { file ->\n            file.name.contains(\"test_code_replacer\") && file.name.contains(\"backup\")\n        }?.forEach { backupFile ->\n            backupFile.delete()\n        }\n        \n        println(\"Cleaned up test files\")\n    } catch (e: Exception) {\n        println(\"Note: Could not clean up all test files: ${e.message}\")\n    }\n}","chunkType":"FUNCTION","tokens":204,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"testEdgeCases","startLine":217,"endLine":252,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\n    suspend fun testEdgeCases() {\n        println(\"Testing edge cases:\")\n        println(\"-\" .repeat(30))\n        \n        val testFile = createTestFile()\n        \n        try {\n            // Test with empty original code\n            val emptyOriginalResult = CodeReplacerUtils.replaceCodeInFile(\n                filePath = testFile,\n                originalCode = \"\",\n                newCode = \"something\"\n            )\n            println(\"Empty original code: $emptyOriginalResult\")\n            \n            // Test with identical codes\n            val identicalResult = CodeReplacerUtils.replaceCodeSafely(\n                filePath = testFile,\n                originalCode = \"val name = \\\"Example\\\"\",\n                newCode = \"val name = \\\"Example\\\"\",\n                options = ReplacementOptions(allowNoChange = true)\n            )\n            println(\"Identical codes: ${identicalResult::class.simpleName}\")\n            \n            // Test with multiline replacement\n            val multilineResult = CodeReplacerUtils.replaceCodeInFile(\n                filePath = testFile,\n                originalCode = \"fun oldMethod() {\\n        println(\\\"Old implementation\\\")\\n    }\",\n                newCode = \"fun newMethod() {\\n        println(\\\"Line 1\\\")\\n        println(\\\"Line 2\\\")\\n        println(\\\"Line 3\\\")\\n    }\"\n            )\n            println(\"Multiline replacement: $multilineResult\")\n            \n        } finally {\n            cleanup(testFile)\n        }\n    }","chunkType":"FUNCTION","tokens":428,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/examples/CodeReplacerExample.kt","className":null,"methodName":"performanceTest","startLine":254,"endLine":289,"content":"package com.example.mindweaverstudio.data.utils.codereplacer.examples\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions\n\n    suspend fun performanceTest() {\n        println(\"Performance test:\")\n        println(\"-\" .repeat(20))\n        \n        // Create a larger test file\n        val largeContent = buildString {\n            repeat(1000) { i ->\n                appendLine(\"class TestClass$i {\")\n                appendLine(\"    fun method$i() {\")\n                appendLine(\"        println(\\\"Method $i\\\")\")\n                appendLine(\"    }\")\n                appendLine(\"}\")\n                appendLine()\n            }\n        }\n        \n        val tempFile = File.createTempFile(\"large_test\", \".kt\")\n        tempFile.writeText(largeContent)\n        \n        try {\n            val startTime = System.currentTimeMillis()\n            \n            val result = CodeReplacerUtils.replaceCodeInFile(\n                filePath = tempFile.absolutePath,\n                originalCode = \"println(\\\"Method 500\\\")\",\n                newCode = \"println(\\\"Modified Method 500\\\")\"\n            )\n            \n            val endTime = System.currentTimeMillis()\n            println(\"Result: $result\")\n            println(\"Time taken: ${endTime - startTime}ms\")\n            \n        } finally {\n            tempFile.delete()\n        }\n    }","chunkType":"FUNCTION","tokens":359,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer.examples","imports":["com.example.mindweaverstudio.data.utils.codereplacer.CodeReplacerUtils","com.example.mindweaverstudio.data.utils.codereplacer.models.ReplacementOptions","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeInFile","startLine":21,"endLine":21,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeInFile(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":26,"endLine":26,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode)","chunkType":"PROPERTY","tokens":51,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeWithOptions","startLine":41,"endLine":41,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeWithOptions(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":52,"endLine":52,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"previewReplacement","startLine":65,"endLine":65,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun previewReplacement(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":71,"endLine":71,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceCodeSafely","startLine":85,"endLine":85,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceCodeSafely(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":91,"endLine":91,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"findCodeFragment","startLine":102,"endLine":102,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun findCodeFragment(","chunkType":"FUNCTION","tokens":41,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":106,"endLine":106,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val options = ReplacementOptions(dryRun = true, allowNoChange = true)","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":107,"endLine":107,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, codeFragment, codeFragment, options)","chunkType":"PROPERTY","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"replaceMultipleFragments","startLine":132,"endLine":132,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun replaceMultipleFragments(","chunkType":"FUNCTION","tokens":43,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":154,"endLine":154,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n            val currentOptions = if (index == 0) options else options.copy(createBackup = false)","chunkType":"PROPERTY","tokens":57,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":155,"endLine":155,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n            val request = ReplacementRequest(filePath, originalCode, newCode, currentOptions)","chunkType":"PROPERTY","tokens":56,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":173,"endLine":173,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val summary = \"\\nSummary: $successCount successful, $errorCount failed out of ${replacements.size} replacements\"","chunkType":"PROPERTY","tokens":63,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"formatResult","startLine":180,"endLine":217,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    private fun formatResult(result: ReplacementResult): String {\n        return when (result) {\n            is ReplacementResult.Success -> {\n                val backupInfo = if (result.backupPath != null) \" (backup created: ${result.backupPath})\" else \"\"\n                \"✅ ${result.message}$backupInfo\"\n            }\n            \n            is ReplacementResult.NotFound -> {\n                \"❌ Code fragment not found in ${result.filePath} (searched ${result.searchedLines} lines)\"\n            }\n            \n            is ReplacementResult.MultipleMatches -> {\n                val locations = result.matches.joinToString(\", \") { \n                    \"line ${it.startLine}\" \n                }\n                \"⚠️ Multiple matches found at: $locations. ${result.message}\"\n            }\n            \n            is ReplacementResult.Error -> {\n                \"❌ Error: ${result.message}\"\n            }\n            \n            is ReplacementResult.DryRun -> {\n                if (result.matchesFound > 0) {\n                    val locations = result.matches.joinToString(\", \") { match ->\n                        match.getLocationDescription()\n                    }\n                    \"📋 Dry run: Found ${result.matchesFound} match(es) at $locations\"\n                } else {\n                    \"📋 Dry run: No matches found\"\n                }\n            }\n            \n            is ReplacementResult.NoChange -> {\n                \"ℹ️ ${result.message}\"\n            }\n        }\n    }","chunkType":"FUNCTION","tokens":406,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":"getReplacementPreview","startLine":227,"endLine":227,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n    suspend fun getReplacementPreview(","chunkType":"FUNCTION","tokens":42,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/codereplacer/CodeReplacerUtils.kt","className":null,"methodName":null,"startLine":233,"endLine":233,"content":"package com.example.mindweaverstudio.data.utils.codereplacer\n\nimport com.example.mindweaverstudio.data.utils.codereplacer.models.*\n\n        val request = ReplacementRequest(filePath, originalCode, newCode, options)","chunkType":"PROPERTY","tokens":53,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.codereplacer","imports":["com.example.mindweaverstudio.data.utils.codereplacer.models.*"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":14,"endLine":163,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\nclass SourceCodeFinder {\n    \n    /**\n     * Finds the source code of a class or function by name in a Kotlin project.\n     * \n     * @param projectRoot Path to the root of the project\n     * @param targetName Name of the class or function to find\n     * @param exactMatch If true, searches for exact name match only\n     * @return SearchResult containing found matches or error information\n     */\n    suspend fun findSourceCode(\n        projectRoot: String,\n        targetName: String,\n        exactMatch: Boolean = true\n    ): SearchResult = withContext(Dispatchers.IO) {\n        try {\n            val rootPath = Paths.get(projectRoot)\n            if (!Files.exists(rootPath) || !Files.isDirectory(rootPath)) {\n                return@withContext SearchResult.Error(\"Project root directory does not exist: $projectRoot\")\n            }\n            \n            val kotlinFiles = findKotlinFiles(rootPath)\n            if (kotlinFiles.isEmpty()) {\n                return@withContext SearchResult.Error(\"No Kotlin files found in project: $projectRoot\")\n            }\n            \n            val matches = mutableListOf<SourceCodeMatch>()\n            var searchedFiles = 0\n            \n            for (file in kotlinFiles) {\n                try {\n                    val fileMatches = searchInFile(file, targetName, exactMatch)\n                    matches.addAll(fileMatches)\n                    searchedFiles++\n                } catch (e: Exception) {\n                    // Continue searching in other files, but log the error\n                    continue\n                }\n            }\n            \n            return@withContext when {\n                matches.isEmpty() -> SearchResult.NotFound(targetName, searchedFiles)\n                matches.size == 1 -> SearchResult.Success(matches)\n                else -> SearchResult.MultipleMatches(matches)\n            }\n            \n        } catch (e: Exception) {\n            SearchResult.Error(\"Error during search: ${e.message}\", e)\n        }\n    }\n    \n    /**\n     * Finds all Kotlin files in the project directory recursively.\n     */\n    private fun findKotlinFiles(rootPath: Path): List<Path> {\n        val kotlinFiles = mutableListOf<Path>()\n        \n        try {\n            Files.walk(rootPath)\n                .filter { it.isRegularFile() }\n                .filter { it.extension == \"kt\" }\n                .forEach { kotlinFiles.add(it) }\n        } catch (e: Exception) {\n            // Return what we have so far\n        }\n        \n        return kotlinFiles\n    }\n    \n    /**\n     * Searches for the target entity in a single Kotlin file.\n     */\n    private fun searchInFile(filePath: Path, targetName: String, exactMatch: Boolean): List<SourceCodeMatch> {\n        val content = Files.readString(filePath)\n        val lines = content.lines()\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val packageName = extractPackageName(content)\n        val imports = extractImports(content)\n        \n        // Search for different types of entities\n        matches.addAll(findClasses(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        matches.addAll(findFunctions(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        matches.addAll(findConstants(lines, targetName, exactMatch, filePath.toString(), packageName, imports))\n        \n        return matches\n    }\n    \n    /**\n     * Extracts package name from Kotlin file content.\n     */\n    private fun extractPackageName(content: String): String? {\n        val packageRegex = Regex(\"\"\"^package\\s+([a-zA-Z][a-zA-Z0-9._]*)\"\"\", RegexOption.MULTILINE)\n        return packageRegex.find(content)?.groupValues?.get(1)\n    }\n    \n    /**\n     * Extracts import statements from Kotlin file content.\n     */\n    private fun extractImports(content: String): List<String> {\n        val importRegex = Regex(\"\"\"^import\\s+([a-zA-Z][a-zA-Z0-9._*]*)\"\"\", RegexOption.MULTILINE)\n        return importRegex.findAll(content).map { it.groupValues[1] }.toList()\n    }\n    \n    /**\n     * Finds class, interface, object declarations in the file.\n     */\n    private fun findClasses(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val classPatterns = mapOf(\n            EntityType.CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(abstract\\s+|open\\s+|final\\s+)?class\\s+(\\w+)\"\"\"),\n            EntityType.INTERFACE to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?interface\\s+(\\w+)\"\"\"),\n            EntityType.OBJECT to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?object\\s+(\\w+)\"\"\"),\n            EntityType.DATA_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?data\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.SEALED_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?sealed\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.ENUM_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?enum\\s+class\\s+(\\w+)\"\"\"),\n            EntityType.ANNOTATION_CLASS to Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?annotation\\s+class\\s+(\\w+)\"\"\")\n        )\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            for ((entityType, pattern) in classPatterns) {\n                val matchResult = pattern.find(line)\n                if (matchResult != null) {\n                    val extractedName = matchResult.groupValues.last()\n                    if (isNameMatch(extractedName, targetName, exactMatch)) {\n                        val sourceCode = extractEntitySourceCode(lines, lineIndex, entityType)\n                        matches.add(\n                            SourceCodeMatch(\n                                entityName = extractedName,\n                                entityType = entityType,\n                                sourceCode = sourceCode,\n                                filePath = filePath,\n                                packageName = packageName,\n                                lineNumber = lineIndex + 1,\n                                imports = imports\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        \n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":157,"endLine":313,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\n                            )\n                        )\n                    }\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Finds function declarations in the file.\n     */\n    private fun findFunctions(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val functionPattern = Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(suspend\\s+|inline\\s+|infix\\s+|operator\\s+)*fun\\s+(\\w+)\"\"\")\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            val matchResult = functionPattern.find(line)\n            if (matchResult != null) {\n                val extractedName = matchResult.groupValues.last()\n                if (isNameMatch(extractedName, targetName, exactMatch)) {\n                    val sourceCode = extractFunctionSourceCode(lines, lineIndex)\n                    matches.add(\n                        SourceCodeMatch(\n                            entityName = extractedName,\n                            entityType = EntityType.FUNCTION,\n                            sourceCode = sourceCode,\n                            filePath = filePath,\n                            packageName = packageName,\n                            lineNumber = lineIndex + 1,\n                            imports = imports\n                        )\n                    )\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Finds constant and property declarations in the file.\n     */\n    private fun findConstants(\n        lines: List<String>,\n        targetName: String,\n        exactMatch: Boolean,\n        filePath: String,\n        packageName: String?,\n        imports: List<String>\n    ): List<SourceCodeMatch> {\n        val matches = mutableListOf<SourceCodeMatch>()\n        \n        val constantPattern = Regex(\"\"\"^\\s*(public\\s+|private\\s+|internal\\s+|protected\\s+)?(const\\s+)?val\\s+(\\w+)\"\"\")\n        \n        for ((lineIndex, line) in lines.withIndex()) {\n            val matchResult = constantPattern.find(line)\n            if (matchResult != null) {\n                val extractedName = matchResult.groupValues.last()\n                if (isNameMatch(extractedName, targetName, exactMatch)) {\n                    val entityType = if (line.contains(\"const\")) EntityType.CONSTANT else EntityType.PROPERTY\n                    val sourceCode = extractPropertySourceCode(lines, lineIndex)\n                    matches.add(\n                        SourceCodeMatch(\n                            entityName = extractedName,\n                            entityType = entityType,\n                            sourceCode = sourceCode,\n                            filePath = filePath,\n                            packageName = packageName,\n                            lineNumber = lineIndex + 1,\n                            imports = imports\n                        )\n                    )\n                }\n            }\n        }\n        \n        return matches\n    }\n    \n    /**\n     * Checks if the extracted name matches the target name.\n     */\n    private fun isNameMatch(extractedName: String, targetName: String, exactMatch: Boolean): Boolean {\n        return if (exactMatch) {\n            extractedName == targetName\n        } else {\n            extractedName.contains(targetName, ignoreCase = true)\n        }\n    }\n    \n    /**\n     * Extracts the complete source code for a class/interface/object entity.\n     */\n    private fun extractEntitySourceCode(lines: List<String>, startIndex: Int, entityType: EntityType): String {\n        val sourceLines = mutableListOf<String>()\n        var braceCount = 0\n        var started = false\n        \n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            sourceLines.add(line)\n            \n            // Count braces to determine the end of the entity\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        started = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (started && braceCount == 0) {\n                            return sourceLines.joinToString(\"\\n\")\n                        }\n                    }\n                }\n            }\n        }\n        \n        return sourceLines.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Extracts the complete source code for a function.\n     */\n    private fun extractFunctionSourceCode(lines: List<String>, startIndex: Int): String {\n        val sourceLines = mutableListOf<String>()\n        var braceCount = 0\n        var started = false\n        var hasBody = false\n        \n        for (i in startIndex until lines.size) {\n            val line = lines[i]\n            sourceLines.add(line)\n            \n            // Check if function has a body (contains '{') or is a single expression (contains '=')\n            if (!hasBody && (line.contains('{') || line.contains('='))) {\n                hasBody = true\n            }\n            \n            // If function is a single expression function, look for the end\n            if (line.contains('=') && !line.contains('{')) {\n                // Single expression function - continue until we find the complete expression\n                if (line.trim().endsWith('}') || line.trim().endsWith(')')) {\n                    return sourceLines.joinToString(\"\\n\")\n                }\n                continue\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFinder.kt","className":null,"methodName":null,"startLine":307,"endLine":355,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n// CLASS: SourceCodeFinder\nclass SourceCodeFinder {\n\n            // If function is a single expression function, look for the end\n            if (line.contains('=') && !line.contains('{')) {\n                // Single expression function - continue until we find the complete expression\n                if (line.trim().endsWith('}') || line.trim().endsWith(')')) {\n                    return sourceLines.joinToString(\"\\n\")\n                }\n                continue\n            }\n            \n            // Count braces for functions with body\n            for (char in line) {\n                when (char) {\n                    '{' -> {\n                        braceCount++\n                        started = true\n                    }\n                    '}' -> {\n                        braceCount--\n                        if (started && braceCount == 0) {\n                            return sourceLines.joinToString(\"\\n\")\n                        }\n                    }\n                }\n            }\n            \n            // If we haven't found a body after a reasonable number of lines, assume it's abstract\n            if (!hasBody && i - startIndex > 3) {\n                return sourceLines.joinToString(\"\\n\")\n            }\n        }\n        \n        return sourceLines.joinToString(\"\\n\")\n    }\n    \n    /**\n     * Extracts the complete source code for a property/constant.\n     */\n    private fun extractPropertySourceCode(lines: List<String>, startIndex: Int): String {\n        val line = lines[startIndex]\n        \n        // Simple property/constant declarations are typically single line\n        if (!line.contains('{')) {\n            return line\n        }\n        \n        // Property with getter/setter - extract the complete block\n        return extractEntitySourceCode(lines, startIndex, EntityType.PROPERTY)\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":473,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.EntityType"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SearchResult.kt","className":null,"methodName":null,"startLine":3,"endLine":8,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\nsealed class SearchResult {\n    data class Success(val matches: List<SourceCodeMatch>) : SearchResult()\n    data class NotFound(val targetName: String, val searchedFiles: Int) : SearchResult()\n    data class Error(val message: String, val cause: Throwable? = null) : SearchResult()\n    data class MultipleMatches(val matches: List<SourceCodeMatch>) : SearchResult()\n}","chunkType":"CLASS","tokens":108,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SearchResult.kt","className":null,"methodName":"SearchResult","startLine":10,"endLine":14,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\nfun SearchResult.getFirstMatch(): SourceCodeMatch? = when (this) {\n    is SearchResult.Success -> matches.firstOrNull()\n    is SearchResult.MultipleMatches -> matches.firstOrNull()\n    else -> null\n}","chunkType":"FUNCTION","tokens":66,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/models/SourceCodeMatch.kt","className":null,"methodName":null,"startLine":3,"endLine":24,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.models\n\ndata class SourceCodeMatch(\n    val entityName: String,\n    val entityType: EntityType,\n    val sourceCode: String,\n    val filePath: String,\n    val packageName: String?,\n    val lineNumber: Int,\n    val imports: List<String>\n)\n\nenum class EntityType {\n    CLASS,\n    INTERFACE,\n    OBJECT,\n    DATA_CLASS,\n    SEALED_CLASS,\n    ENUM_CLASS,\n    FUNCTION,\n    CONSTANT,\n    PROPERTY,\n    ANNOTATION_CLASS\n}","chunkType":"CLASS","tokens":118,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.models","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"main","startLine":12,"endLine":87,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\nfun main() = runBlocking {\n    val projectRoot = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio\"\n    \n    println(\"=== SourceCodeFinder Example ===\")\n    println()\n    \n    // Test 1: Find an interface\n    println(\"1. Finding interface 'Agent':\")\n    println(\"=\" .repeat(50))\n    val agentResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"Agent\")\n    println(agentResult)\n    println()\n    \n    // Test 2: Find a function\n    println(\"2. Finding function 'scanDirectoryToFileNode':\")\n    println(\"=\" .repeat(50))\n    val functionResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"scanDirectoryToFileNode\")\n    println(functionResult)\n    println()\n    \n    // Test 3: Find a class that might have multiple matches\n    println(\"3. Finding class 'AiClient' (might have multiple matches):\")\n    println(\"=\" .repeat(50))\n    val classResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"AiClient\")\n    println(classResult)\n    println()\n    \n    // Test 4: Test non-existent entity\n    println(\"4. Finding non-existent entity 'NonExistentClass':\")\n    println(\"=\" .repeat(50))\n    val notFoundResult = SourceCodeUtils.findAndFormatSourceCode(projectRoot, \"NonExistentClass\")\n    println(notFoundResult)\n    println()\n    \n    // Test 5: Find with package disambiguation\n    println(\"5. Finding 'ChatMessage' with package disambiguation:\")\n    println(\"=\" .repeat(50))\n    val packageResult = SourceCodeUtils.findInPackage(\n        projectRoot, \n        \"ChatMessage\", \n        packageName = \"codeeditor.models\"\n    )\n    println(packageResult)\n    println()\n    \n    // Test 6: Get clean source code (without metadata)\n    println(\"6. Getting clean source code for 'Agent':\")\n    println(\"=\" .repeat(50))\n    val cleanSource = SourceCodeUtils.findCleanSourceCode(projectRoot, \"Agent\")\n    if (cleanSource != null) {\n        println(cleanSource)\n    } else {\n        println(\"Not found or error occurred\")\n    }\n    println()\n    \n    // Test 7: Check if entity exists\n    println(\"7. Checking if entities exist:\")\n    println(\"=\" .repeat(30))\n    val agentExists = SourceCodeUtils.exists(projectRoot, \"Agent\")\n    val fakeExists = SourceCodeUtils.exists(projectRoot, \"FakeClass\")\n    println(\"Agent exists: $agentExists\")\n    println(\"FakeClass exists: $fakeExists\")\n    println()\n    \n    // Test 8: Find all matches for a common name\n    println(\"8. Finding all matches for 'ChatMessage':\")\n    println(\"=\" .repeat(50))\n    val allMatches = SourceCodeUtils.findAllMatches(projectRoot, \"ChatMessage\")\n    println(\"Found ${allMatches.size} matches:\")\n    allMatches.forEachIndexed { index, match ->\n        println(\"${index + 1}. ${match.entityType} in ${match.packageName ?: \"default package\"}\")\n        println(\"   File: ${match.filePath}\")\n        println(\"   Line: ${match.lineNumber}\")\n    }\n}","chunkType":"FUNCTION","tokens":754,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"testSpecificEntities","startLine":94,"endLine":121,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\n    suspend fun testSpecificEntities(projectRoot: String) {\n        val testCases = listOf(\n            \"Agent\" to \"interface\",\n            \"scanDirectoryToFileNode\" to \"function\",\n            \"AiClient\" to \"interface\",\n            \"CODE_TESTER_AGENT\" to \"constant\",\n            \"DefaultRootComponent\" to \"class\",\n            \"EntityType\" to \"enum class\"\n        )\n        \n        println(\"Testing specific entities:\")\n        println(\"=\" .repeat(50))\n        \n        testCases.forEach { (entityName, expectedType) ->\n            println(\"Testing: $entityName (expected: $expectedType)\")\n            val result = SourceCodeUtils.findCleanSourceCode(projectRoot, entityName)\n            if (result != null) {\n                println(\"✅ Found\")\n                println(\"First few lines:\")\n                result.lines().take(5).forEach { line ->\n                    if (line.isNotBlank()) println(\"  $line\")\n                }\n            } else {\n                println(\"❌ Not found\")\n            }\n            println()\n        }\n    }","chunkType":"FUNCTION","tokens":304,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/examples/SourceCodeFinderExample.kt","className":null,"methodName":"performanceTest","startLine":123,"endLine":136,"content":"package com.example.mindweaverstudio.data.utils.sourcecode.examples\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils\nimport kotlinx.coroutines.runBlocking\n\n    suspend fun performanceTest(projectRoot: String) {\n        println(\"Performance test:\")\n        println(\"=\" .repeat(30))\n        \n        val startTime = System.currentTimeMillis()\n        \n        val testEntities = listOf(\"Agent\", \"AiClient\", \"scanDirectoryToFileNode\", \"NonExistent\")\n        testEntities.forEach { entityName ->\n            SourceCodeUtils.exists(projectRoot, entityName)\n        }\n        \n        val endTime = System.currentTimeMillis()\n        println(\"Time taken for ${testEntities.size} searches: ${endTime - startTime}ms\")\n    }","chunkType":"FUNCTION","tokens":185,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode.examples","imports":["com.example.mindweaverstudio.data.utils.sourcecode.SourceCodeUtils","kotlinx.coroutines.runBlocking"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeFormatter.kt","className":null,"methodName":null,"startLine":6,"endLine":112,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\nclass SourceCodeFormatter {\n    \n    /**\n     * Formats the search result into a human-readable string.\n     */\n    fun formatResult(result: SearchResult): String {\n        return when (result) {\n            is SearchResult.Success -> formatSingleMatch(result.matches.first())\n            is SearchResult.MultipleMatches -> formatMultipleMatches(result.matches)\n            is SearchResult.NotFound -> formatNotFound(result.targetName, result.searchedFiles)\n            is SearchResult.Error -> formatError(result.message, result.cause)\n        }\n    }\n    \n    /**\n     * Formats a single source code match with imports.\n     */\n    private fun formatSingleMatch(match: SourceCodeMatch): String {\n        val imports = if (match.imports.isNotEmpty()) {\n            match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n        } else \"\"\n        \n        val packageDeclaration = if (match.packageName != null) {\n            \"package ${match.packageName}\\n\\n\"\n        } else \"\"\n        \n        return buildString {\n            appendLine(\"// Found: ${match.entityName} (${match.entityType.name.lowercase()})\")\n            appendLine(\"// File: ${match.filePath}\")\n            appendLine(\"// Line: ${match.lineNumber}\")\n            if (match.packageName != null) {\n                appendLine(\"// Package: ${match.packageName}\")\n            }\n            appendLine()\n            append(packageDeclaration)\n            append(imports)\n            append(match.sourceCode)\n        }\n    }\n    \n    /**\n     * Formats multiple matches with disambiguation information.\n     */\n    private fun formatMultipleMatches(matches: List<SourceCodeMatch>): String {\n        return buildString {\n            appendLine(\"Multiple matches found for '${matches.first().entityName}':\")\n            appendLine()\n            \n            matches.forEachIndexed { index, match ->\n                appendLine(\"--- Match ${index + 1} ---\")\n                appendLine(\"Type: ${match.entityType.name.lowercase()}\")\n                appendLine(\"Package: ${match.packageName ?: \"default\"}\")\n                appendLine(\"File: ${match.filePath}\")\n                appendLine(\"Line: ${match.lineNumber}\")\n                appendLine()\n                \n                val imports = if (match.imports.isNotEmpty()) {\n                    match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n                } else \"\"\n                \n                val packageDeclaration = if (match.packageName != null) {\n                    \"package ${match.packageName}\\n\\n\"\n                } else \"\"\n                \n                append(packageDeclaration)\n                append(imports)\n                append(match.sourceCode)\n                appendLine()\n                appendLine()\n            }\n        }\n    }\n    \n    /**\n     * Formats not found result.\n     */\n    private fun formatNotFound(targetName: String, searchedFiles: Int): String {\n        return \"Entity '$targetName' not found in $searchedFiles Kotlin files.\"\n    }\n    \n    /**\n     * Formats error result.\n     */\n    private fun formatError(message: String, cause: Throwable?): String {\n        return buildString {\n            appendLine(\"Error during search: $message\")\n            if (cause != null) {\n                appendLine(\"Cause: ${cause.message}\")\n            }\n        }\n    }\n    \n    /**\n     * Gets source code with imports only (no metadata comments).\n     */\n    fun getCleanSourceCode(match: SourceCodeMatch): String {\n        val imports = if (match.imports.isNotEmpty()) {\n            match.imports.joinToString(\"\\n\") { \"import $it\" } + \"\\n\\n\"\n        } else \"\"\n        \n        val packageDeclaration = if (match.packageName != null) {\n            \"package ${match.packageName}\\n\\n\"\n        } else \"\"\n        \n        return packageDeclaration + imports + match.sourceCode\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findAndFormatSourceCode","startLine":23,"endLine":23,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findAndFormatSourceCode(","chunkType":"FUNCTION","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":28,"endLine":28,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findCleanSourceCode","startLine":40,"endLine":40,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findCleanSourceCode(","chunkType":"FUNCTION","tokens":64,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":45,"endLine":45,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findSourceCodeDetailed","startLine":58,"endLine":58,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findSourceCodeDetailed(","chunkType":"FUNCTION","tokens":64,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findAllMatches","startLine":74,"endLine":74,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findAllMatches(","chunkType":"FUNCTION","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":79,"endLine":79,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"exists","startLine":95,"endLine":95,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun exists(","chunkType":"FUNCTION","tokens":60,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":100,"endLine":100,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":"findInPackage","startLine":113,"endLine":113,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n    suspend fun findInPackage(","chunkType":"FUNCTION","tokens":62,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":119,"endLine":119,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n        val result = finder.findSourceCode(projectRoot, targetName, exactMatch)","chunkType":"PROPERTY","tokens":74,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":126,"endLine":128,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n                    val filteredMatches = result.matches.filter { \n                        it.packageName?.contains(packageName) == true \n                    }","chunkType":"PROPERTY","tokens":94,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/utils/sourcecode/SourceCodeUtils.kt","className":null,"methodName":null,"startLine":140,"endLine":142,"content":"package com.example.mindweaverstudio.data.utils.sourcecode\n\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult\nimport com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch\n\n                    val filteredMatches = result.matches.filter { \n                        it.packageName?.contains(packageName) == true \n                    }","chunkType":"PROPERTY","tokens":94,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.utils.sourcecode","imports":["com.example.mindweaverstudio.data.utils.sourcecode.models.SearchResult","com.example.mindweaverstudio.data.utils.sourcecode.models.SourceCodeMatch","com.example.mindweaverstudio.data.utils.sourcecode.models.getFirstMatch"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":52,"endLine":201,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n    private val clientOut = PipedOutputStream()\n    private val serverIn = PipedInputStream(clientOut)\n    private val serverOut = PipedOutputStream()\n    private val clientIn = PipedInputStream(serverOut)\n    private val clientTransport = StdioClientTransport(\n        input = clientIn.asSource().buffered(),\n        output = clientOut.asSink().buffered()\n    )\n    private val serverTransport = StdioServerTransport(\n        inputStream = serverIn.asSource().buffered(),\n        outputStream = serverOut.asSink().buffered()\n    )\n    val httpClient = createHttpClient()\n\n    private val server = Server(\n        serverInfo = Implementation(\n            name = \"example-server\",\n            version = \"1.0.0\"\n        ),\n        options = ServerOptions(\n            capabilities = ServerCapabilities(\n                resources = ServerCapabilities.Resources(\n                    subscribe = true,\n                    listChanged = true\n                ),\n                tools = ServerCapabilities.Tools(true),\n            )\n        )\n    )\n    private val client = Client(\n        clientInfo = Implementation(\n            name = \"example-client\",\n            version = \"1.0.0\"\n        )\n    )\n    private var tools: List<Tool> = emptyList()\n\n    init {\n        initTools()\n    }\n\n    suspend fun init() {\n        server.connect(serverTransport)\n        client.connect(clientTransport)\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n    }\n\n    suspend fun release(): List<TextContent>? {\n        // if server is active\n        val owner = \"NikitaFrankov\"\n        val repo = \"MindWeaverStudio\"\n        val version = \"v0.0.1\"\n        val changelog = \"Simple changelog\"\n\n        val arguments = buildJsonObject {\n            put(\"owner\", owner)\n            put(\"repo\", repo)\n            put(\"version\", version)\n            put(\"changelog\", changelog)\n        }\n\n        val request = CallToolRequest(\n            name = \"create_release\",\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        return result?.content as List<TextContent>?\n    }\n\n    suspend fun generateReleaseInfo(): List<TextContent>? {\n        val request = CallToolRequest(\n            name = \"generate_release_info\",\n        )\n\n        val result = client.callTool(request)\n\n        return result?.content as List<TextContent>?\n    }\n\n    suspend fun getTools(): List<Tool> {\n        if (tools.isNotEmpty()) return tools\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n        return tools\n    }\n\n    suspend fun callTool(call: ToolCall): List<TextContent>? {\n        logReceiver.emitNewValue(\"Agent call tool:\\n$call\".createInfoLogEntry())\n\n        val arguments = buildJsonObject {\n            call.params.forEach {\n                put(it.key, it.value)\n            }\n        }\n\n        val request = CallToolRequest(\n            name = call.tool,\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        logReceiver.emitNewValue(\"result from tool ${call.tool} - ${result?.content}\".createInfoLogEntry())\n\n        return result?.content as List<TextContent>?\n    }\n\n    private fun createHttpClient() = HttpClient(CIO) {\n        install(ContentNegotiation) {\n            json(\n                Json {\n                    ignoreUnknownKeys = true\n                    prettyPrint = true\n                }\n            )\n        }\n\n        install(Logging) {\n            level = LogLevel.INFO\n        }\n\n        defaultRequest {\n            url {\n                protocol = URLProtocol.HTTPS\n                host = \"api.github.com\"\n            }\n\n            val token = apiConfig.githubApiKey\n            if (token.isNotEmpty()) {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            header(\"Accept\", \"application/vnd.github+json\")\n        }\n    }\n\n    private fun initTools() {\n        server.addTool(\n            name = \"get_commits\",\n            description = \"Get list of commits for a GitHub repository. Input is owner (username or organization) and repo name (e.g. octocat, Hello-World)\",\n            inputSchema = Tool.Input(\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":195,"endLine":351,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n    }\n\n    private fun initTools() {\n        server.addTool(\n            name = \"get_commits\",\n            description = \"Get list of commits for a GitHub repository. Input is owner (username or organization) and repo name (e.g. octocat, Hello-World)\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"owner\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"GitHub username or organization (e.g. octocat)\")\n                    }\n                    putJsonObject(\"repo\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Repository name (e.g. Hello-World)\")\n                    }\n                },\n                required = listOf(\"owner\", \"repo\")\n            )\n        ) { request ->\n            val owner = request.arguments[\"owner\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'owner' parameter is required.\"))\n            )\n            val repo = request.arguments[\"repo\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'repo' parameter is required.\"))\n            )\n            val commits = httpClient.getCommits(owner, repo)\n            CallToolResult(content = commits.map { TextContent(it) })\n        }\n\n        server.addTool(\n            name = \"generate_release_info\",\n            description = \"Generate next release version and changelog based on commits since last release.\",\n            inputSchema = Tool.Input()\n        ) { request ->\n            val owner = \"NikitaFrankov\" // Добавить потом извлечение из конфигурационного файла\n            val repo = \"MindWeaverStudio\" // Добавить потом извлечение из конфигурационного файла\n\n            try {\n                val (version, changelog) = generateReleaseInfo(owner, repo, apiConfig.githubApiKey)\n\n                CallToolResult(\n                    content = listOf(\n                        TextContent(\"version: $version,\\nchangelog:$changelog\"),\n                    )\n                )\n            } catch (e: Exception) {\n                CallToolResult(content = listOf(TextContent(\"Failed to generate release info: ${e.message}\")))\n            }\n        }\n\n        server.addTool(\n            name = \"create_release\",\n            description = \"Create a new GitHub release. Input includes version (tag), and  changelog.\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"version\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Release version or tag (e.g. v1.2.0)\")\n                    }\n                    putJsonObject(\"changelog\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"Release description or changelog (Markdown supported)\")\n                    }\n                },\n                required = listOf(\"version\", \"changelog\")\n            )\n        ) { request ->\n            try {\n                val version = request.arguments[\"version\"]?.jsonPrimitive?.content\n                    ?: return@addTool CallToolResult(\n                        content = listOf(TextContent(\"The 'version' parameter is required.\"))\n                    )\n                val changelog = request.arguments[\"changelog\"]?.jsonPrimitive?.content\n                    ?: return@addTool CallToolResult(\n                        content = listOf(TextContent(\"The 'changelog' parameter is required.\"))\n                    )\n\n                val result = triggerReleaseWorkflow(\n                    owner = \"NikitaFrankov\",\n                    repo = \"MindWeaverStudio\",\n                    version = version,\n                    changelog = changelog,\n                    token = apiConfig.githubApiKey,\n                    client = httpClient\n                )\n\n                if (result.success) {\n                    CallToolResult(\n                        content = listOf(TextContent(\"Release $version created successfully! URL: ${result.url}\"))\n                    )\n                } else {\n                    CallToolResult(\n                        content = listOf(TextContent(\"Failed to create release: ${result.errorMessage}\"))\n                    )\n                }\n            } catch (e: Exception) {\n                e.printStackTrace()\n                CallToolResult(content = listOf(TextContent(\"Exception in create_release: ${e.message}\")))\n            }\n        }\n    }\n\n    suspend fun generateReleaseInfo(\n        owner: String,\n        repo: String,\n        token: String\n    ): Pair<String, String> { // (newVersion, changelog)\n        // 1. Узнаем последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer $token\")\n        }\n\n        val lastTag = if (lastReleaseResp.status.isSuccess()) {\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n        } else {\n            \"v0.0.0\"\n        }\n\n        // 2. Сравнение изменений с main\n        val commitMessages = getCommitsSinceLastRelease(\n            owner = owner,\n            repo = repo,\n            token = apiConfig.githubApiKey,\n        )\n\n        // 3. Генерация версии (patch bump)\n        val versionParts = lastTag.removePrefix(\"v\").split(\".\").map { it.toInt() }.toMutableList()\n        versionParts[2] += 1 // patch bump\n        val newVersion = \"v${versionParts.joinToString(\".\")}\"\n\n        // 4. Генерация changelog\n        val changelog = commitMessages.joinToString(\"\\n\") { \"- $it\" }\n\n        return newVersion to changelog\n    }\n\n    suspend fun getCommitsSinceLastRelease(\n        owner: String,\n        repo: String,\n        token: String\n    ): List<String> {\n        // 1. Пытаемся найти последний релиз\n        val lastReleaseResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/releases/latest\") {\n            header(\"Authorization\", \"Bearer $token\")\n        }\n\n        return if (lastReleaseResp.status.isSuccess()) {\n            // Есть релиз → берём diff по тегу\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            val lastTag = json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n\n            val compareResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/compare/$lastTag...main\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(compareResp.bodyAsText()).jsonObject\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/GithubMCPClient.kt","className":null,"methodName":null,"startLine":345,"endLine":426,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: GithubMCPClient\nclass GithubMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n    private val apiConfig: ApiConfiguration,\n) {\n\n            val json = Json.parseToJsonElement(lastReleaseResp.bodyAsText()).jsonObject\n            val lastTag = json[\"tag_name\"]?.jsonPrimitive?.content ?: \"v0.0.0\"\n\n            val compareResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/compare/$lastTag...main\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(compareResp.bodyAsText()).jsonObject\n            val commits = commitsJson[\"commits\"]?.jsonArray ?: JsonArray(emptyList())\n\n            commits.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        } else {\n            // Релизов нет → берём ВСЕ коммиты в main\n            val commitsResp = httpClient.get(\"https://api.github.com/repos/$owner/$repo/commits\") {\n                header(\"Authorization\", \"Bearer $token\")\n            }\n            val commitsJson = Json.parseToJsonElement(commitsResp.bodyAsText()).jsonArray\n            commitsJson.map {\n                it.jsonObject[\"commit\"]!!\n                    .jsonObject[\"message\"]!!\n                    .jsonPrimitive.content\n            }\n        }\n    }\n\n    private suspend fun triggerReleaseWorkflow(\n        owner: String,\n        repo: String,\n        version: String,\n        changelog: String,\n        token: String,\n        client: HttpClient,\n    ): CreateReleaseResult {\n        return try {\n            val response = client.post(\"https://api.github.com/repos/$owner/$repo/actions/workflows/release.yml/dispatches\") {\n                header(\"Authorization\", \"Bearer $token\")\n                header(\"Accept\", \"application/vnd.github+json\")\n                contentType(ContentType.Application.Json)\n                setBody(\n                    buildJsonObject {\n                        put(\"ref\", \"main\")\n                        putJsonObject(\"inputs\") {\n                            put(\"version\", version)\n                            put(\"changelog\", changelog)\n                        }\n                    }\n                )\n            }\n\n            if (response.status.value == 204) {\n                CreateReleaseResult(\n                    success = true,\n                    url = \"Release version $version successfully registered, .dmg file is currently being created.\"\n                )\n            } else {\n                CreateReleaseResult(\n                    success = false,\n                    errorMessage = \"GitHub API returned status ${response.status.value}: ${response.bodyAsText()}\"\n                )\n            }\n        } catch (e: Exception) {\n            CreateReleaseResult(success = false, errorMessage = e.message)\n        }\n    }\n\n    private suspend fun HttpClient.getCommits(owner: String, repo: String): List<String> {\n        val uri = \"/repos/$owner/$repo/commits\"\n        val commits = get(uri).body<List<Commit>>()\n        return commits.map { commit ->\n            \"\"\"\n            SHA: ${commit.sha}\n            Message: ${commit.commit.message}\n            Author: ${commit.commit.author.name} (${commit.commit.author.email})\n            Date: ${commit.commit.author.date}\n        \"\"\".trimIndent()\n        }\n    }\n\n}\n","chunkType":"SUB_CHUNK","tokens":859,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.mcp.github.Commit"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/ProcessResult.kt","className":null,"methodName":"runCommand","startLine":4,"endLine":23,"content":"package com.example.mindweaverstudio.data.mcp\n\n    fun runCommand(command: List<String>, head: Int = 10, tail: Int = 10): String {\n        return try {\n            val process = ProcessBuilder(command)\n                .redirectErrorStream(true)\n                .start()\n\n            val lines = process.inputStream.bufferedReader().use { it.readLines() }\n            process.waitFor()\n\n            if (lines.size <= head + tail) {\n                lines.joinToString(\"\\n\")\n            } else {\n                val headLines = lines.take(head)\n                val tailLines = lines.takeLast(tail)\n                headLines.joinToString(\"\\n\") + \"\\n... [${lines.size - head - tail} lines skipped] ...\\n\" + tailLines.joinToString(\"\\n\")\n            }\n        } catch (e: Exception) {\n            \"Error while executing command: ${e.message}\"\n        }\n    }","chunkType":"FUNCTION","tokens":212,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/DockerMCPClient.kt","className":null,"methodName":null,"startLine":32,"endLine":181,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: DockerMCPClient\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n    private val clientOut = PipedOutputStream()\n    private val serverIn = PipedInputStream(clientOut)\n    private val serverOut = PipedOutputStream()\n    private val clientIn = PipedInputStream(serverOut)\n    private val clientTransport = StdioClientTransport(\n        input = clientIn.asSource().buffered(),\n        output = clientOut.asSink().buffered()\n    )\n    private val serverTransport = StdioServerTransport(\n        inputStream = serverIn.asSource().buffered(),\n        outputStream = serverOut.asSink().buffered()\n    )\n\n    private val server = Server(\n        serverInfo = Implementation(\n            name = \"example-server\",\n            version = \"1.0.0\"\n        ),\n        options = ServerOptions(\n            capabilities = ServerCapabilities(\n                resources = ServerCapabilities.Resources(\n                    subscribe = true,\n                    listChanged = true\n                ),\n                tools = ServerCapabilities.Tools(true),\n            )\n        )\n    )\n    private val client = Client(\n        clientInfo = Implementation(\n            name = \"example-client\",\n            version = \"1.0.0\"\n        )\n    )\n    private var tools: List<Tool> = emptyList()\n\n    init {\n        server.addTool(\n            name = \"run_junit_tests\",\n            description = \"Run JUnit tests on a given Kotlin source code file using provided test code in a isolated Docker container. The tool creates a full Java/Kotlin environment with Gradle and JUnit dependencies, compiles the code, and executes the tests. If tests succeed, saves the test code as a file in the same directory as the source file, named after the test class (e.g., MyTest.kt). Input is the file path to the source code and the test code as a string.\",\n            inputSchema = Tool.Input(\n                properties = buildJsonObject {\n                    putJsonObject(\"file_path\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"The file system path to the Kotlin source code file to be tested (e.g., /path/to/MyClass.kt)\")\n                    }\n                    putJsonObject(\"test_code\") {\n                        put(\"type\", \"string\")\n                        put(\"description\", \"The Kotlin test code using JUnit (e.g., a class with @Test annotations). Included all necessary imports.\")\n                    }\n                },\n                required = listOf(\"file_path\", \"test_code\")\n            )\n        ) { request ->\n            val filePath = request.arguments[\"file_path\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'file_path' parameter is required.\"))\n            )\n            val testCode = request.arguments[\"test_code\"]?.jsonPrimitive?.content ?: return@addTool CallToolResult(\n                content = listOf(TextContent(\"The 'test_code' parameter is required.\"))\n            )\n\n            // Step 1: Validate and read the source file\n            val sourceFile = File(filePath)\n            if (!sourceFile.exists() || !sourceFile.isFile) {\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"The provided file_path does not point to a valid file.\"))\n                )\n            }\n            val sourceCode = try {\n                sourceFile.readText()\n            } catch (e: Exception) {\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error reading the source file: ${e.message}\"))\n                )\n            }\n\n            // Step 2: Create a temporary directory for the project\n            val tempDir = Files.createTempDirectory(\"junit_test_project_\").toFile()\n            tempDir.deleteOnExit()\n\n            // Step 3: Set up project structure\n            // Create src/main/kotlin/Source.kt (assuming the source is a single file; adjust if needed)\n            val mainSrcDir = File(tempDir, \"src/main/kotlin\")\n            mainSrcDir.mkdirs()\n            val sourceFileName = sourceFile.name // Preserve original file name\n            File(mainSrcDir, sourceFileName).writeText(sourceCode)\n\n            // Create src/test/kotlin/Test.kt\n            val testSrcDir = File(tempDir, \"src/test/kotlin\")\n            testSrcDir.mkdirs()\n            val testFileName = \"Test.kt\" // Temporary name inside container\n            File(testSrcDir, testFileName).writeText(testCode)\n\n            // Create build.gradle for Kotlin + JUnit setup\n            val buildGradleContent = \"\"\"\n        plugins {\n            id 'org.jetbrains.kotlin.jvm' version '1.9.0'\n            id 'application'\n        }\n\n        group = 'com.example'\n        version = '1.0-SNAPSHOT'\n\n        repositories {\n            mavenCentral()\n        }\n\n        dependencies {\n            implementation 'org.jetbrains.kotlin:kotlin-stdlib'\n            testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'\n            testImplementation 'org.jetbrains.kotlin:kotlin-test'\n        }\n\n        test {\n            useJUnitPlatform()\n        }\n    \"\"\".trimIndent()\n            File(tempDir, \"build.gradle\").writeText(buildGradleContent)\n\n            // Create settings.gradle (required for Gradle)\n            File(tempDir, \"settings.gradle\").writeText(\"rootProject.name = 'junit_test_project'\")\n\n            // Pre-pull Docker image quietly to avoid verbose pull output in main run\n            val pullCommand = listOf(\"docker\", \"pull\", \"--quiet\", \"gradle:8.0-jdk17\")\n            val pullProcessBuilder = ProcessBuilder(pullCommand)\n            val pullProcess = try {\n                pullProcessBuilder.start()\n            } catch (e: Exception) {\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error pulling Docker image: ${e.message}. Ensure Docker is installed and running.\"))\n                )\n            }\n            pullProcess.waitFor()\n            if (pullProcess.exitValue() != 0) {\n                val pullError = BufferedReader(InputStreamReader(pullProcess.errorStream)).use { it.readText() }\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Failed to pull Docker image: $pullError\"))\n                )\n            }\n\n            // Step 4: Run Docker container with Gradle image\n            // Add --info for detailed test logging\n            val dockerCommand = listOf(\n                \"docker\", \"run\", \"--rm\",\n                \"-v\", \"${tempDir.absolutePath}:/project\",\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.models.mcp.base.ToolCall","com.example.mindweaverstudio.data.receivers.CodeEditorLogReceiver"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/DockerMCPClient.kt","className":null,"methodName":null,"startLine":175,"endLine":283,"content":"package com.example.mindweaverstudio.data.mcp\n// CLASS: DockerMCPClient\nclass DockerMCPClient(\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n\n            }\n\n            // Step 4: Run Docker container with Gradle image\n            // Add --info for detailed test logging\n            val dockerCommand = listOf(\n                \"docker\", \"run\", \"--rm\",\n                \"-v\", \"${tempDir.absolutePath}:/project\",\n                \"-w\", \"/project\",\n                // Используем gradle + jdk17 образ с полноценным Debian\n                \"gradle:8.5-jdk17\",\n                \"gradle\", \"clean\", \"test\", \"--no-daemon\", \"--console=plain\", \"--info\"\n            )\n\n            val processBuilder = ProcessBuilder(dockerCommand)\n            processBuilder.redirectErrorStream(true) // Merge stderr into stdout\n            val process = try {\n                processBuilder.start()\n            } catch (e: Exception) {\n                tempDir.deleteRecursively()\n                return@addTool CallToolResult(\n                    content = listOf(TextContent(\"Error starting Docker process: ${e.message}. Ensure Docker is installed and running.\"))\n                )\n            }\n\n            // Capture output\n            val output = StringBuilder()\n            val reader = BufferedReader(InputStreamReader(process.inputStream))\n            var line: String?\n            while (reader.readLine().also { line = it } != null) {\n                output.append(line).append(\"\\n\")\n            }\n            process.waitFor()\n\n            // Filter output to minimal useful info: start from first task line\n            val lines = output.toString().lines()\n            val startIndex = lines.indexOfFirst { it.startsWith(\">\") }\n            val filteredOutput = if (startIndex >= 0) {\n                lines.subList(startIndex, lines.size).joinToString(\"\\n\")\n            } else {\n                output.toString() // Fallback if no tasks found (e.g., early error)\n            }\n\n            // Clean up temp dir\n            tempDir.deleteRecursively()\n\n            // Step 5: Check if tests succeeded and save test code if yes\n            val exitValue = process.exitValue()\n            var resultContent = if (exitValue == 0) {\n                // Extract test class name from test_code using regex\n                val classNameRegex = Regex(\"\"\"class\\s+(\\w+)\\s*(?:\\{|:)\"\"\")\n                val match = classNameRegex.find(testCode)\n                val testClassName = match?.groupValues?.get(1) ?: \"GeneratedTest\" // Fallback if not found\n\n                // Save test code to file in source directory\n                val sourceDir = sourceFile.parentFile\n                println(\"info bout source file,  parentFile = ${sourceFile.parentFile}, absoluteFile = ${sourceFile.absoluteFile}, absolutePath = ${sourceFile.absolutePath}\")\n                val testOutputFile = File(sourceDir, \"$testClassName.kt\")\n                try {\n                    testOutputFile.writeText(testCode)\n                    \"Tests executed successfully. Test code saved to ${testOutputFile.absolutePath}.\\nOutput:\\n$filteredOutput\"\n                } catch (e: Exception) {\n                    \"Tests executed successfully, but error saving test file: ${e.message}.\\\\nOutput:\\\\n$filteredOutput\"\n                }\n            } else {\n                \"Tests failed with exit code $exitValue.\\nOutput:\\n$filteredOutput\"\n            }\n\n            CallToolResult(content = listOf(TextContent(resultContent)))\n        }\n    }\n\n    suspend fun init() {\n        server.connect(serverTransport)\n        client.connect(clientTransport)\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n    }\n\n    suspend fun getTools(): List<Tool> {\n        if (tools.isNotEmpty()) return tools\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n        return tools\n    }\n\n    suspend fun callTool(call: ToolCall): List<TextContent>? {\n        logReceiver.emitNewValue(\"Agent call tool:\\n$call\".createInfoLogEntry())\n\n        val arguments = buildJsonObject {\n            call.params.forEach {\n                put(it.key, it.value)\n            }\n        }\n\n        // Вызов tool\n        val request = CallToolRequest(\n            name = call.tool,\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        logReceiver.emitNewValue(\"result from tool ${call.tool} - ${result?.content}\".createInfoLogEntry())\n\n        return result?.content as List<TextContent>?\n    }\n}\n","chunkType":"SUB_CHUNK","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.models.mcp.base.ToolCall","com.example.mindweaverstudio.data.receivers.CodeEditorLogReceiver"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/mcp/ThinkMcpClient.kt","className":null,"methodName":null,"startLine":26,"endLine":119,"content":"package com.example.mindweaverstudio.data.mcp\n\nimport com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry\nimport com.example.mindweaverstudio.data.models.mcp.base.ToolCall\n\nclass ThinkMcpClient(\n    private val apiConfiguration: ApiConfiguration,\n    private val logReceiver: CodeEditorLogReceiver,\n) {\n    private var tools: List<Tool> = emptyList()\n    private val httpClient = HttpClient(CIO) {\n        install(SSE)\n        install(ContentNegotiation) {\n            json()\n        }\n    }\n    private val sseUrl = \"http://77.105.144.152:8080/sse\"\n    private val client = Client(\n        clientInfo = Implementation(\n            name = \"example-sse-client\",\n            version = \"1.0.0\"\n        )\n    )\n    private var isInit = false\n\n    val transport = SseClientTransport(\n        client = httpClient,\n        urlString = sseUrl,\n        requestBuilder = {\n            headers.append(\"KEY\", apiConfiguration.thinkApiKey)\n        }\n    )\n\n    init {\n        transport.onMessage {\n            when (it) {\n                is JSONRPCResponse -> {\n                    println(\"New response from server: ${it.jsonrpc}\")\n                    when (val r = it.result) {\n                        is InitializeResult -> {\n                            println(\"Protocol version: ${r.protocolVersion}\")\n                            println(\"Server: ${r.serverInfo.name} v${r.serverInfo.version}\")\n                        }\n                        is ListToolsResult -> {\n                            println(\"Tools available: ${r.tools}\")\n                        }\n                        is CallToolResult -> {\n                            println(\"Tool call result: ${r.content}\")\n                        }\n                        else -> {\n                            println(\"Unknown result type: $r\")\n                        }\n                    }\n                }\n                else -> println(\"Other message: $it\")\n            }\n        }\n    }\n\n    suspend fun init() {\n        if (isInit) return\n        client.connect(transport)\n        isInit = true\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n    }\n\n    suspend fun getTools(): List<Tool> {\n        if (tools.isNotEmpty()) return tools\n\n        val toolsResult = client.listTools(request = ListToolsRequest())\n        tools = toolsResult?.tools.orEmpty()\n        return tools\n    }\n\n    suspend fun callTool(call: ToolCall): List<TextContent>? {\n        logReceiver.emitNewValue(\"Agent call tool:\\n$call\".createInfoLogEntry())\n\n\n        val arguments = buildJsonObject {\n            call.params.forEach {\n                put(it.key, it.value)\n            }\n        }\n\n        // Вызов tool\n        val request = CallToolRequest(\n            name = call.tool,\n            arguments = arguments\n        )\n\n        val result = client.callTool(request)\n\n        logReceiver.emitNewValue(\"result from tool ${call.tool} - ${result?.content}\".createInfoLogEntry())\n\n        return result?.content as List<TextContent>?\n    }\n}","chunkType":"CLASS","tokens":768,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.mcp","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.models.mcp.base.ToolCall","com.example.mindweaverstudio.data.receivers.CodeEditorLogReceiver"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/pipeline/CodeOrchestratorCommand.kt","className":null,"methodName":null,"startLine":6,"endLine":8,"content":"package com.example.mindweaverstudio.data.models.pipeline\n\nimport kotlinx.serialization.Serializable\n\nclass CodeOrchestratorCommand(\n    val pipeline: String,\n)","chunkType":"CLASS","tokens":40,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.pipeline","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/pipeline/PipelineResult.kt","className":null,"methodName":null,"startLine":3,"endLine":31,"content":"package com.example.mindweaverstudio.data.models.pipeline\n\nclass PipelineResult(\n    val message: String,\n    val isError: Boolean,\n) {\n\n    companion object Companion {\n        fun successPipelineResult(message: String) =\n            PipelineResult(\n                message = message,\n                isError = false,\n            )\n        fun errorPipelineResult(error: Throwable): PipelineResult {\n            val errorMessage = \"Error during agent work, throwable = $error, message = ${error.message.orEmpty().ifEmpty { \"Unknown error\" }}\"\n\n            return PipelineResult(\n                message = errorMessage,\n                isError = true,\n            )\n        }\n        fun errorPipelineResult(message: String): PipelineResult {\n            val errorMessage = \"Error during agent work, message = ${message.ifEmpty { \"Unknown error\" }}\"\n\n            return PipelineResult(\n                message = errorMessage,\n                isError = true,\n            )\n        }\n    }\n}","chunkType":"CLASS","tokens":247,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.pipeline","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/pipeline/PipelineStep.kt","className":null,"methodName":null,"startLine":3,"endLine":8,"content":"package com.example.mindweaverstudio.data.models.pipeline\n\ndata class PipelineStep(\n    val id: Int,\n    val name: String,\n    val agentName: String,\n    val action: suspend (String) -> PipelineResult\n)","chunkType":"CLASS","tokens":50,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.pipeline","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/pipeline/PipelineOptions.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.data.models.pipeline\n\ndata class PipelineOptions(\n    val resumeFromLast: Boolean = false\n)","chunkType":"CLASS","tokens":32,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.pipeline","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/pipeline/PipelineCommand.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.data.models.pipeline\n\nclass PipelineCommand(\n    val message: String,\n)","chunkType":"CLASS","tokens":27,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.pipeline","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/chat/local/LocalChatMessage.kt","className":null,"methodName":null,"startLine":9,"endLine":39,"content":"package com.example.mindweaverstudio.data.models.chat.local\n\nimport com.example.mindweaverstudio.data.models.chat.remote.ChatMessage\nimport kotlinx.serialization.SerialName\n\ndata class LocalChatRequest(\n    val model: String,\n    val messages: List<ChatMessage>,\n    val stream: Boolean = false,\n    val options: Options? = null\n)\n\n// Дополнительные параметры (temperature, top_p, top_k и т.д.)\n@Serializable\ndata class Options(\n    @SerialName(\"temperature\")\n    var localTemperature: Double?,\n    @SerialName(\"num_ctx\")\n    var numContext: Int?,\n    @SerialName(\"top_p\")\n    var topP: Double?,\n    @SerialName(\"top_k\")\n    var topK: Int?,\n    @SerialName(\"repeat_penalty\")\n    var repeatPenalty: Double? = 1.1\n)\n\nfun Options(block: Options.() -> Unit): Options {\n    return Options(\n        localTemperature = null,\n        numContext = null,\n        topP = null,\n        topK = null,\n        repeatPenalty = 1.1\n    ).apply(block)\n}","chunkType":"CLASS","tokens":233,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.chat.local","imports":["com.example.mindweaverstudio.data.models.chat.remote.ChatMessage","kotlinx.serialization.SerialName","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/chat/local/LocalChatMessage.kt","className":null,"methodName":null,"startLine":42,"endLine":55,"content":"package com.example.mindweaverstudio.data.models.chat.local\n\nimport com.example.mindweaverstudio.data.models.chat.remote.ChatMessage\nimport kotlinx.serialization.SerialName\n\ndata class LocalChatResponse(\n    val model: String?,\n    @SerialName(\"created_at\") val createdAt: String?,\n    val message: ChatMessage?,\n    val done: Boolean?,\n    val error: OllamaError?\n)\n\n@Serializable\ndata class OllamaError(\n    val message: String?,\n    val type: String?,\n    val code: String?,\n)","chunkType":"CLASS","tokens":119,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.chat.local","imports":["com.example.mindweaverstudio.data.models.chat.remote.ChatMessage","kotlinx.serialization.SerialName","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/chat/remote/ChatMessage.kt","className":null,"methodName":null,"startLine":6,"endLine":15,"content":"package com.example.mindweaverstudio.data.models.chat.remote\n\nimport kotlinx.serialization.Serializable\n\ndata class ChatMessage(\n    val role: String,\n    val content: String\n) {\n    companion object {\n        const val ROLE_USER = \"user\"\n        const val ROLE_ASSISTANT = \"assistant\"\n        const val ROLE_SYSTEM = \"system\"\n    }\n}","chunkType":"CLASS","tokens":83,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.chat.remote","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/chat/remote/ChatRequest.kt","className":null,"methodName":null,"startLine":7,"endLine":14,"content":"package com.example.mindweaverstudio.data.models.chat.remote\n\nimport kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\n\ndata class ChatRequest(\n    val model: String,\n    val messages: List<ChatMessage>,\n    val temperature: Double = 0.7,\n    @SerialName(\"max_tokens\")\n    val maxTokens: Int? = 1000,\n    val stream: Boolean = false\n)","chunkType":"CLASS","tokens":89,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.chat.remote","imports":["kotlinx.serialization.SerialName","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/chat/remote/ChatResponse.kt","className":null,"methodName":null,"startLine":7,"endLine":41,"content":"package com.example.mindweaverstudio.data.models.chat.remote\n\nimport kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\n\ndata class ChatResponse(\n    val id: String? = null,\n    @SerialName(\"object\")\n    val chatObject: String? = null,\n    val created: Long? = null,\n    val model: String? = null,\n    val choices: List<Choice>? = null,\n    val usage: Usage? = null,\n    val error: ErrorDetail? = null\n)\n\n@Serializable\ndata class Choice(\n    val index: Int? = null,\n    val message: ChatMessage? = null,\n    @SerialName(\"finish_reason\")\n    val finishReason: String? = null\n)\n\n@Serializable\ndata class Usage(\n    @SerialName(\"prompt_tokens\")\n    val promptTokens: Int? = null,\n    @SerialName(\"completion_tokens\")\n    val completionTokens: Int? = null,\n    @SerialName(\"total_tokens\")\n    val totalTokens: Int? = null\n)\n\n@Serializable\ndata class ErrorDetail(\n    val message: String,\n    val type: String? = null,\n    val code: String? = null\n)","chunkType":"CLASS","tokens":242,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.chat.remote","imports":["kotlinx.serialization.SerialName","kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/github/CreateReleaseResult.kt","className":null,"methodName":null,"startLine":3,"endLine":7,"content":"package com.example.mindweaverstudio.data.models.mcp.github\n\nclass CreateReleaseResult(\n    val success: Boolean,\n    val url: String? = null,\n    val errorMessage: String? = null\n)","chunkType":"CLASS","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.github","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/github/CommitData.kt","className":null,"methodName":null,"startLine":6,"endLine":22,"content":"package com.example.mindweaverstudio.data.models.mcp.github\n\nimport kotlinx.serialization.Serializable\n\ndata class Commit(\n    val sha: String,\n    val commit: CommitDetails\n)\n\n@Serializable\ndata class CommitDetails(\n    val author: Author,\n    val message: String\n)\n\n@Serializable\ndata class Author(\n    val name: String,\n    val email: String,\n    val date: String\n)","chunkType":"CLASS","tokens":92,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.github","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/base/ToolType.kt","className":null,"methodName":null,"startLine":3,"endLine":15,"content":"package com.example.mindweaverstudio.data.models.mcp.base\n\nenum class ToolType(val value: String) {\n    UNKNOWN(\"unknown\"),\n    FETCH_COMMITS(\"fetch_commits\"),\n    RUN_PROJECT_CONTAINER(\"run_project_container\");\n\n    companion object {\n        fun valueeOf(name: String): ToolType = when(name) {\n            FETCH_COMMITS.value -> FETCH_COMMITS\n            RUN_PROJECT_CONTAINER.value -> RUN_PROJECT_CONTAINER\n            else -> UNKNOWN\n        }\n    }\n}","chunkType":"CLASS","tokens":113,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.base","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/mcp/base/ToolCall.kt","className":null,"methodName":null,"startLine":6,"endLine":12,"content":"package com.example.mindweaverstudio.data.models.mcp.base\n\nimport kotlinx.serialization.Serializable\n\ndata class ToolCall(\n    val action: String,\n    val tool: String,\n    val params: Map<String, String> = emptyMap(),\n    val isError: Boolean = false,\n    val errorMessage: String? = null,\n)","chunkType":"CLASS","tokens":73,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.mcp.base","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":6,"endLine":28,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\ndata class UserPersonalization(\n    val name: String = \"User\",\n    val role: WorkRole = WorkRole.DEVELOPER,\n    val preferredLanguage: String = \"Kotlin\",\n    val responseFormat: ResponseFormat = ResponseFormat.MARKDOWN,\n    val experienceLevel: ExperienceLevel = ExperienceLevel.INTERMEDIATE,\n    val timeZone: String = \"UTC\",\n    val habits: List<String> = emptyList(),\n    val preferences: Map<String, String> = emptyMap(),\n    val history: List<String> = emptyList()\n)\n\n@Serializable\nenum class WorkRole(val displayName: String) {\n    DEVELOPER(\"Developer\"),\n    MANAGER(\"Manager\"),\n    DESIGNER(\"Designer\"),\n    QA_ENGINEER(\"QA Engineer\"),\n    DEVOPS(\"DevOps Engineer\"),\n    ARCHITECT(\"Architect\"),\n    STUDENT(\"Student\"),\n    OTHER(\"Other\")\n}","chunkType":"CLASS","tokens":212,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":31,"endLine":34,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\nenum class ResponseFormat(val displayName: String) {\n    MARKDOWN(\"Markdown\"),\n    PLAIN_TEXT(\"Plain Text\")\n}","chunkType":"CLASS","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/profile/UserPersonalization.kt","className":null,"methodName":null,"startLine":37,"endLine":42,"content":"package com.example.mindweaverstudio.data.models.profile\n\nimport kotlinx.serialization.Serializable\n\nenum class ExperienceLevel(val displayName: String) {\n    BEGINNER(\"Beginner\"),\n    INTERMEDIATE(\"Intermediate\"),\n    ADVANCED(\"Advanced\"),\n    EXPERT(\"Expert\")\n}","chunkType":"CLASS","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.profile","imports":["kotlinx.serialization.Serializable"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/ai/AiResponse.kt","className":null,"methodName":null,"startLine":3,"endLine":11,"content":"package com.example.mindweaverstudio.data.models.ai\n\nclass AiResponse(\n    val message: String\n) {\n\n    companion object {\n        fun createTextResponse(text: String) =\n            AiResponse(message = text)\n    }\n}","chunkType":"CLASS","tokens":54,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.ai","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/models/ai/Role.kt","className":null,"methodName":null,"startLine":3,"endLine":5,"content":"package com.example.mindweaverstudio.data.models.ai\n\nenum class Role {\n    ADMIN, USER, GUEST\n}","chunkType":"CLASS","tokens":23,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.models.ai","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/receivers/CodeEditorLogReceiver.kt","className":null,"methodName":null,"startLine":8,"endLine":15,"content":"package com.example.mindweaverstudio.data.receivers\n\nimport com.example.mindweaverstudio.components.codeeditor.models.LogEntry\nimport kotlinx.coroutines.flow.MutableSharedFlow\n\nclass CodeEditorLogReceiver {\n    private var _logFlow: MutableSharedFlow<LogEntry> = MutableSharedFlow()\n    val logFlow: SharedFlow<LogEntry> = _logFlow.asSharedFlow()\n\n    suspend fun emitNewValue(value: LogEntry) {\n        _logFlow.emit(value)\n    }\n}","chunkType":"CLASS","tokens":108,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.receivers","imports":["com.example.mindweaverstudio.components.codeeditor.models.LogEntry","kotlinx.coroutines.flow.MutableSharedFlow","kotlinx.coroutines.flow.SharedFlow"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":null,"startLine":8,"endLine":12,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    private val json = Json {\n        prettyPrint = true\n        ignoreUnknownKeys = true\n        encodeDefaults = true\n    }","chunkType":"PROPERTY","tokens":73,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":null,"startLine":13,"endLine":16,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    private val configFile = File(System.getProperty(\"user.home\") + \"/MindWeaverStudio/user_config.json\").apply {\n        parentFile.mkdirs()  // Создаём директорию, если нет\n        if (!exists()) createNewFile()  // Создаём пустой файл\n    }","chunkType":"PROPERTY","tokens":102,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"load","startLine":18,"endLine":25,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun load(): UserPersonalization {\n        val content = configFile.readText()\n        return if (content.isNotBlank()) {\n            json.decodeFromString(UserPersonalization.serializer(), content)\n        } else {\n            UserPersonalization()  // Дефолтные значения\n        }\n    }","chunkType":"FUNCTION","tokens":114,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"loadJsonConfig","startLine":27,"endLine":27,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun loadJsonConfig(): String = json.encodeToString(UserPersonalization.serializer(), load())","chunkType":"FUNCTION","tokens":65,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/profile/PersonalizationConfig.kt","className":null,"methodName":"save","startLine":29,"endLine":31,"content":"package com.example.mindweaverstudio.data.profile\n\nimport com.example.mindweaverstudio.data.models.profile.UserPersonalization\nimport kotlinx.serialization.json.Json\n\n    fun save(config: UserPersonalization) {\n        configFile.writeText(json.encodeToString(UserPersonalization.serializer(), config))\n    }","chunkType":"FUNCTION","tokens":77,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.profile","imports":["com.example.mindweaverstudio.data.models.profile.UserPersonalization","kotlinx.serialization.json.Json","java.io.File"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/memory/RedisMemoryStore.kt","className":null,"methodName":null,"startLine":24,"endLine":160,"content":"package com.example.mindweaverstudio.data.ai.memory\n\nimport kotlinx.coroutines.withContext\nimport kotlinx.coroutines.Dispatchers\n\nclass RedisMemoryStore(\n    private val jedis: Jedis,\n) : MemoryStore {\n\n    private val keyPrefix: String = \"\"\n    private val json = Json { encodeDefaults = true; prettyPrint = false }\n\n    private val timelineKey = prefix(\"memories:timeline\")\n    private val checkpointPrefix = prefix(\"checkpoint\")\n    private val memoryPrefix = prefix(\"memory\")\n\n    private fun prefix(k: String): String =\n        if (keyPrefix.isBlank()) k else \"$keyPrefix:$k\"\n\n    private fun memoryKey(id: String) = \"$memoryPrefix:$id\"\n    private fun checkpointKey(id: String) = \"$checkpointPrefix:$id\"\n\n    override suspend fun saveMemory(item: MemoryItem, ttl: Duration?) = withContext(Dispatchers.IO) {\n        jedis.use { j ->\n            val p: Pipeline = j.pipelined()\n            val map = mapOf(\n                \"id\" to item.id,\n                \"type\" to item.type,\n                \"content\" to item.content,\n                \"metadata\" to json.encodeToString(item.metadata),\n                \"createdAt\" to item.createdAt.toString()\n            )\n            p.hmset(memoryKey(item.id), map)\n            p.zadd(timelineKey, item.createdAt.toDouble(), item.id)\n            if (ttl != null) {\n                val seconds = ttl.toDouble(DurationUnit.SECONDS).toLong()\n                if (seconds > 0) p.expire(memoryKey(item.id), seconds)\n            }\n            p.sync()\n        }\n    }\n\n    override suspend fun getMemory(id: String): MemoryItem? = withContext(Dispatchers.IO) {\n        val map = jedis.hgetAll(memoryKey(id))\n        if (map == null || map.isEmpty()) return@withContext null\n        MemoryItem(\n            id = map[\"id\"] ?: id,\n            type = map[\"type\"] ?: \"unknown\",\n            content = map[\"content\"] ?: \"\",\n            metadata = map[\"metadata\"]?.let { json.decodeFromString(it) } ?: emptyMap(),\n            createdAt = map[\"createdAt\"]?.toLongOrNull() ?: System.currentTimeMillis()\n        )\n    }\n\n    override suspend fun deleteMemory(id: String) = withContext(Dispatchers.IO) {\n        jedis.use { j ->\n            val p = j.pipelined()\n            p.del(memoryKey(id))\n            p.zrem(timelineKey, id)\n            p.sync()\n        }\n    }\n\n    override suspend fun queryRecent(limit: Int): List<MemoryItem> = withContext(Dispatchers.IO) {\n        val ids = jedis.zrevrange(timelineKey, 0, (limit - 1).toLong())\n        if (ids.isEmpty()) return@withContext emptyList()\n\n        jedis.use { j ->\n            val p = j.pipelined()\n            val responses = ids.map { id -> p.hgetAll(memoryKey(id)) }\n            p.sync()\n\n            ids.mapIndexedNotNull { i, id ->\n                val map = responses[i].get()\n                if (map != null && map.isNotEmpty()) {\n                    MemoryItem(\n                        id = map[\"id\"] ?: id,\n                        type = map[\"type\"] ?: \"unknown\",\n                        content = map[\"content\"] ?: \"\",\n                        metadata = map[\"metadata\"]?.let { json.decodeFromString(it) } ?: emptyMap(),\n                        createdAt = map[\"createdAt\"]?.toLongOrNull() ?: 0L\n                    )\n                } else null\n            }\n        }\n    }\n\n    override suspend fun saveCheckpoint(id: String, snapshot: AgentSnapshot): Unit = withContext(Dispatchers.IO) {\n        val key = checkpointKey(id)\n        val map = mapOf(\n            \"snapshot\" to json.encodeToString(snapshot),\n            \"createdAt\" to snapshot.createdAt.toString(),\n            \"agentVersion\" to snapshot.agentVersion\n        )\n        jedis.hmset(key, map)\n    }\n\n    override suspend fun loadCheckpoint(id: String): AgentSnapshot? = withContext(Dispatchers.IO) {\n        val key = checkpointKey(id)\n        val map = jedis.hgetAll(key)\n        if (map == null || map.isEmpty()) return@withContext null\n        map[\"snapshot\"]?.let { json.decodeFromString<AgentSnapshot>(it) }\n    }\n\n    override suspend fun listCheckpoints(prefix: String): List<String> = withContext(Dispatchers.IO) {\n        val keyPattern = if (prefix.isBlank()) \"$checkpointPrefix:*\" else \"$checkpointPrefix:$prefix*\"\n        val results = mutableListOf<String>()\n        var cursor = \"0\"\n        val params = ScanParams().match(keyPattern).count(100)\n        do {\n            val scanResult: ScanResult<String> = jedis.scan(cursor, params)\n            cursor = scanResult.cursor\n            for (k in scanResult.result) {\n                results += k.removePrefix(\"$checkpointPrefix:\")\n            }\n        } while (cursor != \"0\")\n        results\n    }\n\n    override suspend fun acquireLock(lockKey: String, ttl: Duration, ownerId: String): Boolean = withContext(Dispatchers.IO) {\n        val fullKey = prefix(\"lock:$lockKey\")\n        val setParams = SetParams.setParams().nx().px(ttl.toDouble(DurationUnit.MILLISECONDS).toLong())\n        jedis.set(fullKey, ownerId, setParams) == \"OK\"\n    }\n\n    override suspend fun releaseLock(lockKey: String, ownerId: String): Boolean = withContext(Dispatchers.IO) {\n        val fullKey = prefix(\"lock:$lockKey\")\n        val lua = \"\"\"\n            if redis.call(\"get\", KEYS[1]) == ARGV[1] then\n                return redis.call(\"del\", KEYS[1])\n            else\n                return 0\n            end\n        \"\"\".trimIndent()\n        val r = jedis.eval(lua, listOf(fullKey), listOf(ownerId))\n        (r as Long) == 1L\n    }\n\n    override suspend fun close() = withContext(Dispatchers.IO) {\n        jedis.close()\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.memory","imports":["kotlinx.coroutines.withContext","kotlinx.coroutines.Dispatchers","redis.clients.jedis.Jedis"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/memory/MemoryStore.kt","className":null,"methodName":null,"startLine":8,"endLine":40,"content":"package com.example.mindweaverstudio.data.ai.memory\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\nimport kotlinx.serialization.Serializable\n\ndata class MemoryItem(\n    val id: String = UUID.randomUUID().toString(),\n    val type: String,\n    val content: String,\n    val metadata: Map<String, String> = emptyMap(),\n    val createdAt: Long = System.currentTimeMillis()\n)\n\n@Serializable\ndata class AgentSnapshot(\n    val checkpointId: String,\n    val conversationWindow: List<MemoryItem> = emptyList(),\n    val pendingTasks: List<String> = emptyList(),\n    val variables: Map<String, String> = emptyMap(),\n    val agentVersion: String = \"v1\",\n    val createdAt: Long = System.currentTimeMillis()\n)\n\ninterface MemoryStore {\n    suspend fun saveMemory(item: MemoryItem, ttl: Duration? = null)\n    suspend fun getMemory(id: String): MemoryItem?\n    suspend fun deleteMemory(id: String)\n    suspend fun queryRecent(limit: Int = 50): List<MemoryItem>\n\n    suspend fun saveCheckpoint(id: String, snapshot: AgentSnapshot)\n    suspend fun loadCheckpoint(id: String): AgentSnapshot?\n    suspend fun listCheckpoints(prefix: String = \"\"): List<String>\n\n    suspend fun acquireLock(lockKey: String, ttl: Duration, ownerId: String = UUID.randomUUID().toString()): Boolean\n    suspend fun releaseLock(lockKey: String, ownerId: String): Boolean\n\n    suspend fun close()\n}","chunkType":"CLASS","tokens":345,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.memory","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult","kotlinx.serialization.Serializable","java.util.UUID"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/memory/MemoryStore.kt","className":null,"methodName":"MemoryStore","startLine":42,"endLine":46,"content":"package com.example.mindweaverstudio.data.ai.memory\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\nimport kotlinx.serialization.Serializable\n\nsuspend fun MemoryStore.getLastCompletedStep(pipelineName: String): Int? {\n    return queryRecent(limit = 1)\n        .firstOrNull { it.metadata[\"pipeline\"] == pipelineName && it.metadata[\"status\"] == \"success\" }\n        ?.metadata?.get(\"step\")?.toInt()\n}","chunkType":"FUNCTION","tokens":105,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.memory","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult","kotlinx.serialization.Serializable","java.util.UUID"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/memory/MemoryStore.kt","className":null,"methodName":"MemoryStore","startLine":48,"endLine":52,"content":"package com.example.mindweaverstudio.data.ai.memory\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\nimport kotlinx.serialization.Serializable\n\nsuspend fun MemoryStore.getStepOutput(pipelineName: String, stepId: Int): String? {\n    return queryRecent(limit = 10)\n        .find { it.metadata[\"pipeline\"] == pipelineName && it.metadata[\"step\"] == stepId.toString() }\n        ?.content\n}","chunkType":"FUNCTION","tokens":102,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.memory","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult","kotlinx.serialization.Serializable","java.util.UUID"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/memory/MemoryStore.kt","className":null,"methodName":"MemoryStore","startLine":54,"endLine":54,"content":"package com.example.mindweaverstudio.data.ai.memory\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\nimport kotlinx.serialization.Serializable\n\nsuspend fun MemoryStore.saveStepResult(","chunkType":"FUNCTION","tokens":51,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.memory","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult","kotlinx.serialization.Serializable","java.util.UUID"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/aiClients/GeminiApiClient.kt","className":null,"methodName":null,"startLine":18,"endLine":76,"content":"package com.example.mindweaverstudio.data.ai.aiClients\n\nimport com.example.mindweaverstudio.data.utils.config.ApiConfiguration\nimport com.example.mindweaverstudio.data.models.ai.AiResponse\n\nclass GeminiApiClient(\n    private val configuration: ApiConfiguration,\n) : AiClient {\n\n    private val baseUrl: String = \"https://generativelanguage.googleapis.com/v1beta/openai\"\n    private val json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n    \n    private val client = HttpClient {\n        install(ContentNegotiation) {\n            json(this@GeminiApiClient.json)\n        }\n        install(Logging) {\n            logger = Logger.DEFAULT\n            level = LogLevel.INFO\n        }\n    }\n\n    override suspend fun createChatCompletion(\n        messages: List<ChatMessage>,\n        temperature: Double,\n        maxTokens: Int,\n    ): Result<AiResponse> {\n        val request = ChatRequest(\n            model = \"gemini-2.5-flash\",\n            messages = messages,\n            temperature = temperature,\n            maxTokens = maxTokens,\n        )\n\n        return try {\n            val response = client.post(\"$baseUrl/chat/completions\") {\n                contentType(ContentType.Application.Json)\n                headers {\n                    append(HttpHeaders.Authorization, \"Bearer ${configuration.geminiApiKey}\")\n                    append(\"Content-Type\", \"application/json\")\n                }\n                setBody(request)\n            }\n            \n            val rawResponse = response.bodyAsText()\n            val jsonResponse = json.decodeFromString<ChatResponse>(rawResponse)\n            val content = jsonResponse.choices?.firstOrNull()?.message?.content\n                ?: return Result.failure(Exception(\"No response content available\"))\n\n            Result.success(createTextResponse(content))\n        } catch (e: Exception) {\n            println(\"Gemini API Error: ${e.message}\")\n            e.printStackTrace()\n            Result.failure(e)\n        }\n    }\n\n    fun close() {\n        client.close()\n    }\n}","chunkType":"CLASS","tokens":512,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.aiClients","imports":["com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.ai.AiResponse","com.example.mindweaverstudio.data.models.ai.AiResponse.Companion.createTextResponse"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/aiClients/ChatGPTApiClient.kt","className":null,"methodName":null,"startLine":19,"endLine":84,"content":"package com.example.mindweaverstudio.data.ai.aiClients\n\nimport com.example.mindweaverstudio.data.utils.config.ApiConfiguration\nimport com.example.mindweaverstudio.data.models.ai.AiResponse\n\nclass ChatGPTApiClient(\n    private val configuration: ApiConfiguration\n) : AiClient {\n    private val baseUrl: String = \"https://openrouter.ai/api/v1\"\n    private val json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n\n    private val client = HttpClient {\n        install(ContentNegotiation) {\n            json(this@ChatGPTApiClient.json)\n        }\n        install(Logging) {\n            logger = Logger.DEFAULT\n            level = LogLevel.INFO\n        }\n        install(HttpTimeout) {\n            requestTimeoutMillis = 1500000\n            connectTimeoutMillis = 500000\n            socketTimeoutMillis = 1000000\n        }\n    }\n\n    override suspend fun createChatCompletion(\n        messages: List<ChatMessage>,\n        temperature: Double,\n        maxTokens: Int,\n    ): Result<AiResponse> {\n        val request = ChatRequest(\n            model = \"qwen/qwen2.5-vl-72b-instruct:free\",\n            messages = messages,\n            temperature = temperature,\n            maxTokens = 3000,\n        )\n\n        return try {\n            println(\"Request for ai - ${request.messages}\")\n            val response = client.post(\"$baseUrl/chat/completions\") {\n                contentType(ContentType.Application.Json)\n                headers {\n                    append(HttpHeaders.Authorization, \"Bearer ${configuration.openAiApiKey}\")\n                    append(\"Content-Type\", \"application/json\")\n                }\n                setBody(request)\n            }\n\n            val rawResponse = response.bodyAsText()\n            val jsonResponse = json.decodeFromString<ChatResponse>(rawResponse)\n            val error = jsonResponse.error\n            if (error != null) {\n                println(\"Error in ai response ${error.message + \"\\n\\nError code: ${error.code}\"}\")\n                return Result.failure(Exception(error.message + \"\\n\\nError code: ${error.code}\"))\n            }\n            val content = jsonResponse.choices?.firstOrNull()?.message?.content\n                ?: return Result.failure(Exception(\"No response content available\"))\n\n            println(\"Api response $content\")\n            Result.success(createTextResponse(content))\n        } catch (e: Exception) {\n            println(\"ChatGPT API Error: ${e.message}\")\n            e.printStackTrace()\n            Result.failure(e)\n        }\n    }\n}","chunkType":"CLASS","tokens":632,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.aiClients","imports":["com.example.mindweaverstudio.data.utils.config.ApiConfiguration","com.example.mindweaverstudio.data.models.ai.AiResponse","com.example.mindweaverstudio.data.models.ai.AiResponse.Companion.createTextResponse"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/aiClients/AiClient.kt","className":null,"methodName":null,"startLine":6,"endLine":12,"content":"package com.example.mindweaverstudio.data.ai.aiClients\n\nimport com.example.mindweaverstudio.data.models.ai.AiResponse\nimport com.example.mindweaverstudio.data.models.chat.remote.ChatMessage\n\ninterface AiClient {\n    suspend fun createChatCompletion(\n        messages: List<ChatMessage>,\n        temperature: Double = 0.7,\n        maxTokens: Int = 1000,\n    ): Result<AiResponse>\n}","chunkType":"INTERFACE","tokens":95,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.aiClients","imports":["com.example.mindweaverstudio.data.models.ai.AiResponse","com.example.mindweaverstudio.data.models.chat.remote.ChatMessage"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/aiClients/LocalDeepSeekApiClient.kt","className":null,"methodName":null,"startLine":20,"endLine":90,"content":"package com.example.mindweaverstudio.data.ai.aiClients\n\nimport com.example.mindweaverstudio.data.models.ai.AiResponse\nimport com.example.mindweaverstudio.data.models.ai.AiResponse.Companion.createTextResponse\n\nclass LocalDeepSeekApiClient() : AiClient {\n    private val baseUrl: String = \"http://localhost:11434/api/chat\"\n    private val json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n        explicitNulls = false\n    }\n\n    private val client = HttpClient {\n        install(ContentNegotiation) {\n            json(this@LocalDeepSeekApiClient.json)\n        }\n        install(HttpTimeout) {\n            requestTimeoutMillis = 120_000 // 2 минуты\n            connectTimeoutMillis = 60_000\n            socketTimeoutMillis = 120_000\n        }\n        install(Logging) {\n            logger = Logger.DEFAULT\n            level = LogLevel.INFO\n        }\n    }\n\n    override suspend fun createChatCompletion(\n        messages: List<ChatMessage>,\n        temperature: Double,\n        maxTokens: Int,\n    ): Result<AiResponse> {\n        val request = LocalChatRequest(\n            model = \"qwen2.5-coder:7b\",\n            messages = messages,\n            stream = false,\n            options = Options {\n                localTemperature = temperature\n                numContext = maxTokens\n            }\n        )\n\n        return try {\n            println(\"Request messages = ${request}\")\n            val response = client.post(baseUrl) {\n                contentType(ContentType.Application.Json)\n                setBody(request)\n            }\n\n            val responseText = response.bodyAsChannel().toInputStream().readBytes().decodeToString()\n            println(\"responseText = $responseText\")\n            val jsonChunks = responseText.split(Regex(\"(?<=})\\\\s*(?=\\\\{)\"))\n            println(\"chunks = $jsonChunks\")\n\n            val sb = StringBuilder()\n            for (chunk in jsonChunks) {\n                if (chunk.isBlank()) continue\n                try {\n                    val parsed = json.decodeFromString<LocalChatResponse>(chunk)\n                    sb.append(parsed.message?.content ?: \"\")\n                    if (parsed.done == true) break  // остановка на последнем чанке\n                } catch (_: Exception) {\n                    // игнорируем невалидные чанки\n                }\n            }\n\n            val fullAnswer = sb.toString().trim()\n            Result.success(createTextResponse(fullAnswer))\n        } catch (e: Exception) {\n            println(\"DeepSeek API Error: ${e.message}\")\n            e.printStackTrace()\n            Result.failure(e)\n        }\n    }\n}","chunkType":"CLASS","tokens":651,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.aiClients","imports":["com.example.mindweaverstudio.data.models.ai.AiResponse","com.example.mindweaverstudio.data.models.ai.AiResponse.Companion.createTextResponse","com.example.mindweaverstudio.data.models.chat.local.LocalChatRequest"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":5,"endLine":5,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val ARCHITECT_VALIDATOR_OPTIMIZER_AGENT = \"architect_validator_optimizer_agent\"","chunkType":"PROPERTY","tokens":52,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":6,"endLine":6,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val DETAILED_ARCHITECT_DESIGNER_AGENT = \"detailed_architect_designer_agent\"","chunkType":"PROPERTY","tokens":51,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":7,"endLine":7,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val RELEASE_NOTES_GENERATION_AGENT = \"release_notes_generation_agent\"","chunkType":"PROPERTY","tokens":50,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":8,"endLine":8,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val REQUIREMENTS_ANALYST_AGENT = \"requirements_analyst_agent\"","chunkType":"PROPERTY","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":9,"endLine":9,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val HIGH_LEVEL_ARCHITECT_AGENT = \"high_level_architect_agent\"","chunkType":"PROPERTY","tokens":48,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":10,"endLine":10,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val GITHUB_RELEASE_AGENT = \"github_release_agent\"","chunkType":"PROPERTY","tokens":45,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":11,"endLine":11,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val CODE_REVIEWER_AGENT = \"code_reviewer_agent\"","chunkType":"PROPERTY","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":12,"endLine":12,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val TEST_CREATOR_AGENT = \"test_creator_agent\"","chunkType":"PROPERTY","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":13,"endLine":13,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\nconst val CODE_CREATOR_AGENT = \"code_creator_agent\"","chunkType":"PROPERTY","tokens":44,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/Agent.kt","className":null,"methodName":null,"startLine":20,"endLine":24,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineResult\n\ninterface Agent {\n    val name: String\n    val description: String\n    suspend fun run(input: String): PipelineResult\n}","chunkType":"INTERFACE","tokens":61,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/AgentsOrchestratorFactory.kt","className":null,"methodName":null,"startLine":13,"endLine":26,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nimport com.example.mindweaverstudio.data.ai.orchestrator.CodeOrchestrator\nimport com.example.mindweaverstudio.data.ai.pipelines.ARCHITECTURE_PIPELINE\n\nclass AgentsOrchestratorFactory {\n    val editorOrchestrator: CodeOrchestrator by KoinJavaComponent.inject(CodeOrchestrator::class.java) {\n        parametersOf(\n            listOf(\n                CODE_FIX_PIPELINE,\n                CHAT_PIPELINE,\n                CODE_CREATOR_PIPELINE,\n                GITHUB_RELEASE_PIPELINE,\n                CODE_REVIEW_PIPELINE,\n                ARCHITECTURE_PIPELINE\n            )\n        )\n    }\n}","chunkType":"CLASS","tokens":159,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":["com.example.mindweaverstudio.data.ai.orchestrator.CodeOrchestrator","com.example.mindweaverstudio.data.ai.pipelines.ARCHITECTURE_PIPELINE","com.example.mindweaverstudio.data.ai.pipelines.CHAT_PIPELINE"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/AgentsRegistry.kt","className":null,"methodName":null,"startLine":3,"endLine":11,"content":"package com.example.mindweaverstudio.data.ai.agents\n\nclass AgentsRegistry {\n    private val agents = mutableMapOf<String, Agent>()\n\n    fun register(name: String, agent: Agent) {\n        agents[name] = agent\n    }\n\n    fun get(name: String): Agent? = agents[name]\n}","chunkType":"CLASS","tokens":66,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/ChatAgent.kt","className":null,"methodName":null,"startLine":15,"endLine":38,"content":"package com.example.mindweaverstudio.data.ai.agents.workers\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.aiClients.AiClient\n\nclass ChatAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = CHAT_AGENT\n    override val description: String = \"Агент для обычного общения\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val messages = listOf(ChatMessage(role = ROLE_USER, content = input))\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.4,\n            maxTokens = 2000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n}","chunkType":"CLASS","tokens":226,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.aiClients.AiClient","com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/ReasoningAgent.kt","className":null,"methodName":null,"startLine":18,"endLine":106,"content":"package com.example.mindweaverstudio.data.ai.agents.workers\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.REASONING_AGENT\n\nclass ReasoningAgent(\n    private val aiClient: AiClient,\n    private val authManager: AuthManager,\n    private val limitManager: LimitManager,\n) : Agent {\n    override val name: String = REASONING_AGENT\n    override val description: String = \"Агент, который реализует цепочку размышлений: мысль → проверка → ответ\"\n    private val allowedRoles = setOf(Role.ADMIN)\n\n    override suspend fun run(input: String): PipelineResult {\n        val token = authManager.getToken() ?: return errorPipelineResult(\"No token\")\n        val claims = authManager.validateToken(token) ?: return errorPipelineResult(\"Invalid token\")\n        val role = Role.valueOf(claims[\"role\"] as String)\n        val username = claims[\"username\"] as String\n\n        if (role !in allowedRoles) return errorPipelineResult(\"Insufficient permissions to perform the task. Your role is \\\"${role.name}\\\", minimum role required to perform the task - \\\"${allowedRoles.first().name}\\\"\")\n        if (!limitManager.checkAndConsume(username, \"daily_queries\", role)) return errorPipelineResult(\"Limit exceeded\")\n\n        val thoughtSystemPrompt = generateThoughtSystemPrompt()\n        val thoughtMessages = listOf(thoughtSystemPrompt, ChatMessage(content = input, role = ROLE_USER))\n        val thoughtResult = aiClient.createChatCompletion(\n            messages = thoughtMessages,\n            temperature = 0.1,\n            maxTokens = 1500,\n        )\n        if (thoughtResult.isFailure) {\n            return errorPipelineResult(thoughtResult.exceptionOrNull() ?: Throwable(\"Thought generation failed\"))\n        }\n        val thought = thoughtResult.getOrNull()?.message ?: return errorPipelineResult(Throwable(\"No thought generated\"))\n\n        val verificationSystemPrompt = generateVerificationSystemPrompt()\n        val verificationMessages = listOf(\n            verificationSystemPrompt,\n            ChatMessage(content = thought, role = ROLE_ASSISTANT),\n            ChatMessage(content = input, role = ROLE_USER)\n        )\n        val verificationResult = aiClient.createChatCompletion(\n            messages = verificationMessages,\n            temperature = 0.1,\n            maxTokens = 1500,\n        )\n        if (verificationResult.isFailure) {\n            return errorPipelineResult(verificationResult.exceptionOrNull() ?: Throwable(\"Verification failed\"))\n        }\n        val verifiedThought = verificationResult.getOrNull()?.message ?: return errorPipelineResult(Throwable(\"No verification result\"))\n\n        // Шаг 3: Генерация финального ответа (на основе verified thoughts и originalQuery)\n        val responseSystemPrompt = generateResponseSystemPrompt()\n        val responseMessages = listOf(\n            responseSystemPrompt,\n            ChatMessage(content = verifiedThought, role = ROLE_ASSISTANT),\n            ChatMessage(content = input, role = ROLE_USER)\n        )\n        val responseResult = aiClient.createChatCompletion(\n            messages = responseMessages,\n            temperature = 0.1,\n            maxTokens = 1500,\n        )\n        return responseResult.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateThoughtSystemPrompt(): ChatMessage {\n        val prompt = \"\"\"\nYou are an expert reasoner. For the user's query, generate step-by-step thoughts. Break down the problem logically: identify key elements, consider options, potential risks, and outline insights. Use \"Let's think step by step\" to structure your reasoning. Output only the thoughts, no final answer.\n            \"\"\".trimIndent()\n        return ChatMessage(role = ROLE_SYSTEM, content = prompt)\n    }\n\n    private fun generateVerificationSystemPrompt(): ChatMessage {\n        val prompt = \"\"\"\nYou are a critical verifier. Review the thoughts for factual errors, logical inconsistencies, missing details, or improvements. If accurate, confirm and enhance with additional insights if needed. If flawed, correct them step-by-step. Output only the verified or corrected thoughts, keeping the step-by-step structure.\n            \"\"\".trimIndent()\n        return ChatMessage(role = ROLE_SYSTEM, content = prompt)\n    }\n\n    private fun generateResponseSystemPrompt(): ChatMessage {\n        val prompt = \"\"\"\nYou are a concise responder. Based solely on the verified thoughts, provide a clear, accurate, and complete final answer to the user's query. Structure it logically (e.g., numbered steps if applicable), keep it brief but comprehensive. Directly address the question without unnecessary repetition.\n            \"\"\".trimIndent()\n        return ChatMessage(role = ROLE_SYSTEM, content = prompt)\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.REASONING_AGENT","com.example.mindweaverstudio.data.ai.aiClients.AiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/ReleaseNotesGeneratorAgent.kt","className":null,"methodName":null,"startLine":16,"endLine":81,"content":"package com.example.mindweaverstudio.data.ai.agents.workers\n\nimport com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry\nimport com.example.mindweaverstudio.data.ai.agents.Agent\n\nclass ReleaseNotesGeneratorAgent(\n    private val aiClient: AiClient,\n    private val mcpClient: GithubMCPClient,\n    private val receiver: CodeEditorLogReceiver\n) : Agent {\n    override val name: String = RELEASE_NOTES_GENERATION_AGENT\n    override val description: String = \"Agent responsible for release notes generation\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val systemPrompt = generateSystemPrompt()\n        val releaseInfo = generateReleaseInfo()\n        val messages = listOf(systemPrompt, ChatMessage(content = releaseInfo, role = ROLE_USER))\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.5,\n            maxTokens = 1000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private suspend fun generateReleaseInfo(): String {\n        val result = mcpClient.generateReleaseInfo()?.firstOrNull()?.text.orEmpty()\n        val toolLogEntry = \"Tool for generating release information has completed his work. result:\\n$result\".createInfoLogEntry()\n\n        receiver.emitNewValue(toolLogEntry)\n        return result\n    }\n\n    private fun generateSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n        You are a release notes assistant.  \n        You will receive:  \n        - Release version number (e.g., v1.4.0)  \n        - List of commits (commit messages).  \n        \n        Your task:  \n        1. Read all commits.  \n        2. Aggregate them into a clear and user-friendly changelog.  \n        3. Keep all important details from the commits, but make the text concise and well-presented.  \n        4. Output all changes as a bullet-point list.  \n        \n        *Do not use non-existent changes. Only use the list of commits for your response.*\n        \n        Answer format:  \n        \n        Release Notes — {version number}  \n        \n        - {change 1}  \n        - {change 2}  \n        - {change 3}  \n            \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":621,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.RELEASE_NOTES_GENERATION_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/code/CodeReviewerAgent.kt","className":null,"methodName":null,"startLine":10,"endLine":108,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.code\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.CODE_REVIEWER_AGENT\n\nclass CodeReviewerAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = CODE_REVIEWER_AGENT\n    override val description: String = \"Agent, responsible for review of the whole project\"\n\n    override suspend fun run(input: String): PipelineResult {\n        var ragChunksText = \"\"\n        val file = File(\"truly_streaming_output_chunks.json\")\n        if (file.exists()) {\n            ragChunksText = file.readText()\n        } else {\n            println(\"Файл не найден: ${file.absolutePath}\")\n        }\n\n        val userMessage = ragChunksText\n        val messages = listOf(generateTestSystemPrompt(),\n            ChatMessage(role = ChatMessage.Companion.ROLE_USER, content = userMessage)\n        )\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.0,\n            maxTokens = 2000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                PipelineResult.Companion.successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                PipelineResult.Companion.errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n       You are a senior Android developer with expertise in Kotlin, code review, and software architecture. Your task is to analyze an Android Kotlin codebase provided as an array of RAGDocument objects in JSON format, where each RAGDocument contains:\n\n- **id**: Unique identifier for the code chunk.\n- **content**: The Kotlin code (e.g., classes, methods, properties).\n- **metadata**: Includes filePath, className, methodName, chunkType (CLASS, METHOD, PROPERTY, IMPORT), startLine, endLine, tokens, overlapsWithPrevious.\n\n### Task\n1. **Reconstruct the Project**:\n   - Extract Kotlin code from the `content` field of each RAGDocument.\n   - Use metadata (filePath, className, chunkType) to organize the code into a cohesive project structure, mapping out packages, classes, and relationships.\n   - Infer the project's purpose (e.g., restaurant ordering app) from code content and class/method names.\n   - Note any incomplete code due to chunk boundaries and make reasonable assumptions.\n\n2. **Analyze Code Quality**:\n   - Identify code smells (e.g., long methods, duplication), bugs, performance issues, or security risks.\n   - Check Kotlin/Android best practices (null safety, ViewModel usage, Jetpack components).\n   - Assess readability, maintainability, and naming conventions.\n\n3. **Evaluate Architecture**:\n   - Analyze package structure, separation of concerns, and patterns (e.g., MVVM).\n   - Assess use of Jetpack components (LiveData, Navigation, ViewModel).\n   - Identify missing components (e.g., dependency injection, tests).\n\n4. **Prioritize Issues**:\n   - Categorize issues as Critical, High, Medium, or Low based on impact.\n   - Justify prioritization by impact on functionality, performance, or maintainability.\n\n5. **Provide Recommendations**:\n   - Offer specific, actionable solutions with concise Kotlin code examples.\n   - Suggest design patterns (e.g., Repository) and modern Android tools (e.g., Hilt, Coroutines).\n   - Tailor feedback to the project's context and domain.\n\n### Output Format\n```markdown\n# Code Review Report\n\n## Project Overview\n[Summary of the project's purpose, architecture (e.g., MVVM), strengths, and key improvement areas.]\n\n## Identified Issues\n### [Category: e.g., Code Quality, Architecture]\n- **Issue**: [Describe issue, referencing filePath, className, or line numbers]\n- **Severity**: [Critical/High/Medium/Low]\n- **Impact**: [Why it matters]\n- **Recommendation**: [Specific solution, e.g., Kotlin code, pattern, or tool]\n\n## Prioritization\n[Ordered list of issues to address first, with justification.]\n\n## Architectural Recommendations\n[Suggestions for package structure, dependency injection, testing, or modern Android practices.]\n\n## Additional Notes\n[Testing strategies, documentation, or other observations.]\n           \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.code","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.CODE_REVIEWER_AGENT","com.example.mindweaverstudio.data.ai.aiClients.AiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/code/CodeFixerAgent.kt","className":null,"methodName":null,"startLine":19,"endLine":113,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.code\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.aiClients.AiClient\n\nclass CodeFixerResult(\n    val sourceCode: String,\n    val filepath: String,\n    val newCode: String\n)\n\nclass CodeFixerAgent(\n    private val aiClient: AiClient,\n) : Agent {\n\n    override val name = CODE_FIXER_AGENT\n    override val description: String = \"Агент, который фиксит баги.\"\n\n    private val json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n\n    override suspend fun run(input: String): PipelineResult {\n        val className = findClassName(input).orEmpty()\n        val codeSearch = findSourcesByQuery(className)\n        val userMessageString = input.replace(className, codeSearch.getFirstMatch()?.sourceCode.orEmpty())\n        val userMessage = ChatMessage(content = userMessageString, role = ROLE_USER)\n\n        val systemPrompt = generateTestSystemPrompt()\n        val messages = listOf(systemPrompt, userMessage)\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.1,\n            maxTokens = 2000,\n        )\n\n        return result.fold(\n            onSuccess = { response ->\n                codeSearch as SearchResult.Success\n                val searchResult = codeSearch.matches.first()\n\n                val result = CodeFixerResult(\n                    sourceCode = searchResult.sourceCode,\n                    filepath = searchResult.filePath,\n                    newCode = response.message\n                )\n                val resultString = json.encodeToString(CodeFixerResult.serializer(), result)\n\n                successPipelineResult(message = resultString)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private suspend fun findSourcesByQuery(className: String): SearchResult {\n        return SourceCodeFinder().findSourceCode(\n            projectRoot = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio\",\n            targetName = className,\n        )\n    }\n\n    fun findClassName(query: String): String? {\n        // Ищем слово, которое начинается с большой буквы и состоит из букв, цифр или _\n        val regex = Regex(\"\"\"\\b[A-Z][A-Za-z0-9_]*\\b\"\"\")\n        return regex.find(query)?.value\n    }\n\n    private suspend fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n        Ты — старший разработчик и автоматический инструмент для исправления багов в коде.\n        Твоя единственная цель — получить код с конкретной проблемой и исправить эту проблему, ни шагу дальше.\n        На вход ты получаешь код и описание конкретного бага или проблемы.\n        Ты возвращаешь только исправленный код, без объяснений, без комментариев, без MARKDOWN и без других предложений по улучшению или оптимизации.\n        Если входной код уже исправлен, возвращай его без изменений.\n        Не добавляй никакой дополнительной функциональности, импортов, библиотек или комментариев.\n        Формат вывода — чистый исправленный код в исходном стиле и языке, без оберток, без блочного форматирования БЕЗ ФОРМАТИРОВАНИЯ MARKDOWN, КОД НУЖНО ВОЗВРАЩАТЬ В ФОРМАТЕ ТЕКСТА\n        \n        Пример работы. Вход:\n            fun sum(a: Int, b: Int): Int {\n                return a + b\n            }\n        Проблема: метод возвращает неверный результат для отрицательных чисел\n        \n        Выход:\n            fun sum(a: Int, b: Int): Int {\n                return a + b\n            }\n        \n        Запомни, твоя задача только исправить конкретную проблему. Больше ничего.\n            \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":948,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.code","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.aiClients.AiClient","com.example.mindweaverstudio.data.models.pipeline.PipelineResult"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/code/CodeCreatorAgent.kt","className":null,"methodName":null,"startLine":11,"endLine":61,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.code\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT\n\nclass CodeCreatorAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name: String = CODE_CREATOR_AGENT\n    override val description: String = \"Агент, который отвечает за генерацию кода по запросу\"\n    val json = Json {\n        ignoreUnknownKeys = true\n        isLenient = true\n    }\n\n    override suspend fun run(input: String): PipelineResult {\n        val systemPrompt = generateTestSystemPrompt()\n        val messages = listOf(systemPrompt, ChatMessage(content = input, role = ChatMessage.Companion.ROLE_USER))\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.1,\n            maxTokens = 3000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                PipelineResult.Companion.successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                PipelineResult.Companion.errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val config = PersonalizationConfig.loadJsonConfig()\n\n        val prompt =  \"\"\"\n            You are a senior developer. \n            You must respond only with complete, working code.\n            Absolutely no explanations, no comments, no Markdown, no formatting symbols, no text before or after the code. \n            Only raw code. Your output must compile and be self-sufficient, including imports if needed. \n            Any deviation is forbidden. Always produce code as short and correct as possible. \n            Example: if asked to create a factorial function, your output must be only the code for that function, nothing else.\n            \n            Study the user configuration and tailor your response to the requirements described there\n            User configuration: $config\n\n            \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":552,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.code","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT","com.example.mindweaverstudio.data.ai.aiClients.AiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/GithubReleaseAgent.kt","className":null,"methodName":null,"startLine":18,"endLine":108,"content":"package com.example.mindweaverstudio.data.ai.agents.workers\n\nimport com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry\nimport com.example.mindweaverstudio.data.ai.agents.Agent\n\nclass GithubReleaseAgent(\n    private val aiClient: AiClient,\n    private val mcpClient: GithubMCPClient,\n    private val receiver: CodeEditorLogReceiver\n) : Agent {\n    override val name: String = GITHUB_RELEASE_AGENT\n    override val description: String = \"Agent responsible for create release on github.com\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val systemPrompt = generateSystemPrompt()\n        val messages = listOf(systemPrompt, ChatMessage(content = input, role = ROLE_USER))\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.2,\n            maxTokens = 1500,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                handleToolCall(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private suspend fun handleToolCall(message: String): PipelineResult {\n        val json = Json {\n            ignoreUnknownKeys = true\n            isLenient = true\n        }\n\n        try {\n            val toolCall = json.decodeFromString(ToolCall.serializer(), message)\n            val result = mcpClient.callTool(toolCall)?.firstOrNull()?.text.orEmpty()\n            val toolLogEntry = \"Tool for creating github release has completed his work. result:\\n$result\".createInfoLogEntry()\n\n            receiver.emitNewValue(toolLogEntry)\n\n            return successPipelineResult(result)\n        } catch (e: Exception) {\n            return errorPipelineResult(e)\n        }\n    }\n\n    private suspend fun generateSystemPrompt(): ChatMessage {\n        val tools = mcpClient.getTools()\n        val prompt =  \"\"\"\n            You are an AI agent integrated with a mcp server\n            You use only **ONE** tool - for create github release.  \n            You must follow these rules strictly:\n            \n            1. You are given a list of tools, but You use only **ONE** tool - for create github release. :\n                $tools\n            \n            2. When the user makes a request related to generating information about the next release,\n                you must respond only with a JSON object of the following form:\n            \n               {\n                 \"action\": \"call_tool\",\n                 \"tool\": \"<tool_name>\",\n                 \"params\": { <key-value pairs> }\n               }\n            \n            3. Never include explanations, natural language, comments, or any additional text.  \n               Your output must always be a **valid JSON object only**, parsable by standard JSON parsers.  \n            \n            4. If the request cannot be mapped to any available tool, respond with:\n            \n               {\n                 \"action\": \"no_tool\",\n                 \"reason\": \"<short machine-readable reason>\"\n               }\n            \n            5. Do not invent tools, parameters, or functionality.  \n               Only use the provided tool list.  \n            \n            6. Preserve the integrity of code and text passed as parameters (do not escape or reformat unnecessarily).  \n            \n            This system prompt establishes a strict contract:  \n            You are a JSON-only tool invocation layer.  \n            No additional conversation, no reasoning, no markdown formatting.  \n            \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":925,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers","imports":["com.example.mindweaverstudio.components.codeeditor.models.createInfoLogEntry","com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.GITHUB_RELEASE_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/architecture/RequirementsAnalystAgent.kt","className":null,"methodName":null,"startLine":12,"endLine":118,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.architecture\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.REQUIREMENTS_ANALYST_AGENT\n\nclass RequirementsAnalystAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = REQUIREMENTS_ANALYST_AGENT\n    override val description: String = \"Agent, responsible for analytic requirements of architecture\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val messages = listOf(generateTestSystemPrompt(),\n            ChatMessage(role = ROLE_USER, content = input)\n        )\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.0,\n            maxTokens = 3000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n            system_prompt:\n              role: Requirements Analyst Agent\n              description: |\n                You are the Requirements Analyst Agent, the first agent in a multi-agent pipeline designed to generate application architectures based on user input. Your role is to analyze and structure raw user requirements into a clear, comprehensive specification document for the next agent (High-Level Architect Agent). You specialize in software development,, and ensure the output is actionable without requiring further user clarification.\n              core_responsibilities:\n                - Parse User Input: Take the raw input (e.g., a textual description of the desired application, features, constraints, or goals) and break it down systematically.\n                - Extract Key Elements:\n                  - Functional Requirements: Identify what the application must do (e.g., user authentication, data processing, UI interactions).\n                  - Non-Functional Requirements: Include performance, scalability, security, usability, reliability, and compliance (e.g., GDPR).\n                  - Target Platform and Tech Stack: Determine platforms (e.g., Android, JVM, web, Kotlin Multiplatform) and any specified technologies (e.g., databases, APIs).\n                  - Stakeholders and Users: Identify actors involved (e.g., end-users, admins).\n                  - Constraints and Assumptions: Note budget, timelines, integrations, or assumptions if not explicitly stated.\n                  - Edge Cases and Risks: Highlight potential ambiguities or risks in the requirements.\n                - Handle Ambiguities: If information is missing or unclear (e.g., \"fast performance\"), make reasonable assumptions (e.g., \"response time < 2s\") and document them explicitly.\n                - Structure Output: Produce a standardized, machine-readable YAML document that is complete and ready for the next agent.\n                - Assumptions: Assume the application is Kotlin-based unless specified otherwise. Treat all inputs as good-faith; do not add unsolicited moral or ethical judgments.\n              processing_steps:\n                - Read and Understand Input: Carefully analyze the entire user query. Use natural language processing logic to categorize content (e.g., keywords like \"mobile app\" indicate platform).\n                - Categorize Requirements: Map elements to predefined categories. Use evidence from the input to justify each extraction.\n                - Resolve Ambiguities: For vague requirements, infer reasonable details based on context and document these as assumptions.\n                - Validate Completeness: Ensure the specification covers all aspects needed for architecture design. Cross-check for consistency and coherence.\n                - Format Output: Output only in YAML format for easy parsing. Include all necessary sections as defined below.\n              input_format:\n                - The input will be a string or JSON object containing the user's raw description (e.g., \"Build a fitness tracking app with user profiles, real-time syncing, and backend in Kotlin.\").\n              output_format: |\n                Respond ONLY with a YAML-structured document. Do not include any additional text, explanations, or chit-chat outside the YAML. Use the following structure:\n                ```yaml\n                requirements_specification:\n                  functional_requirements:\n                    - description: \"Brief description of feature 1\"\n                      details: \"Additional details or sub-features\"\n                    - description: \"Brief description of feature 2\"\n                      # ... more as needed\n                  non_functionarithm_requirements:\n                    performance:\n                      - \"Requirement detail (e.g., 'Handle 1000 concurrent users')\"\n                    security:\n                      - \"Requirement detail (e.g., 'Encrypt user data')\"\n                    scalability:\n                      - \"Requirement detail (e.g., 'Support 10,000 users')\"\n                    # Add subsections like usability, reliability, etc., as relevant\n                  target_platform:\n                    - \"Platform 1 (e.g., 'Android with Jetpack Compose')\"\n                    - \"Platform 2 if multiplatform\"\n                  tech_stack_suggestions:\n                    - \"Kotlin Coroutines for async\"\n                    - \"Room for database\"\n                  stakeholders:\n                    - \"End-user: Description\"\n                    - \"Admin: Description\"\n                  constraints:\n                    - \"Budget limit: If mentioned\"\n                    - \"Timeline: If mentioned\"\n                  assumptions:\n                    - \"Assumption 1 (e.g., 'Assumes cloud hosting')\"\n                  risks:\n                    - \"Potential risk 1 (e.g., 'Ambiguity in performance requirements')\"\n                ```\n                - If a section is irrelevant or empty, omit it or use an empty list [].\n                - Keep descriptions concise yet detailed; aim for clarity and brevity.\n                - Ensure YAML is valid and indented properly.\n              guidelines:\n                - Objectivity: Stick to facts from the input. Do not invent requirements beyond reasonable assumptions.\n                - Completeness: Cover all implied aspects (e.g., if \"mobile app\" is mentioned, infer UI/UX needs).\n                - Error Handling: If input is invalid or empty, output a YAML with an \"error\" section explaining briefly.\n                - No External Tools: Process based on input alone; no web searches or code execution.\n                - No Clarifications: Do not generate clarifying questions. Instead, make and document reasonable assumptions to fill gaps.\n                - Iterative Mindset: Your output feeds the next agent, so make it robust, complete, and extensible.\n                - Professional Tone: Ensure output is neutral and technical.\n              notes:\n                - Your response must be purely the YAML output. Do not include any requests for clarification or additional text outside the YAML.\n           \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.architecture","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.REQUIREMENTS_ANALYST_AGENT","com.example.mindweaverstudio.data.ai.aiClients.AiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/architecture/HighLevelArchitectAgent.kt","className":null,"methodName":null,"startLine":11,"endLine":149,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.architecture\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.HIGH_LEVEL_ARCHITECT_AGENT\n\nclass HighLevelArchitectAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = HIGH_LEVEL_ARCHITECT_AGENT\n    override val description: String = \"Agent, responsible for high-level architect\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val messages = listOf(generateTestSystemPrompt(),\n            ChatMessage(role = ChatMessage.Companion.ROLE_USER, content = input)\n        )\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.0,\n            maxTokens = 4000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n            system_prompt:\n              role: High-Level Architect Agent\n              description: |\n                You are the High-Level Architect Agent, the second agent in a multi-agent pipeline designed to generate application architectures based on a structured requirements specification. Your role is to create a high-level architectural design for a Kotlin-based application, based on the input from the Requirements Analyst Agent. You focus on defining the overall structure, key modules, architectural patterns, and high-level interactions, ensuring the design is robust, scalable, and aligned with Kotlin best practices. Your output is a machine-readable document that serves as input for the Detailed Designer Agent.\n            \n              core_responsibilities:\n                - Analyze Input: Process the structured YAML specification from the Requirements Analyst Agent, containing functional and non-functional requirements, target platforms, tech stack suggestions, stakeholders, constraints, assumptions, and risks.\n                - Define Architecture:\n                  - Identify major modules (e.g., UI, Business Logic, Data Layer, Networking).\n                  - Select appropriate architectural patterns (e.g., MVVM, Clean Architecture, Hexagonal Architecture) based on requirements and Kotlin idioms.\n                  - Define high-level components (e.g., services, repositories, controllers) and their interactions.\n                  - Specify integration points (e.g., APIs, databases, external services).\n                - Ensure Kotlin Alignment: Incorporate Kotlin-specific features like coroutines for asynchronous operations, sealed classes for state modeling, and extension functions for modularity.\n                - Address Non-Functional Requirements: Design for performance, scalability, security, and maintainability as specified (e.g., horizontal scaling for high user load).\n                - Generate Diagrams: Produce a high-level diagram (in PlantUML or Mermaid syntax) to visualize module interactions and architecture.\n                - Handle Assumptions: Build on assumptions from the input, ensuring they are reflected in the design or flagged as risks if problematic.\n                - Structure Output: Create a standardized, machine-readable YAML document that is complete and ready for the Detailed Designer Agent.\n            \n              processing_steps:\n                - Parse Input: Read and validate the YAML specification from the Requirements Analyst Agent.\n                - Map Requirements to Architecture: Translate functional requirements into modules and non-functional requirements into design constraints (e.g., caching for performance).\n                - Select Patterns and Technologies: Choose patterns and Kotlin-specific technologies (e.g., Ktor for backend, Jetpack Compose for Android UI) based on requirements and platform.\n                - Design Module Interactions: Define how modules communicate (e.g., via interfaces, events, or Kotlin Flow).\n                - Create Diagram: Generate a PlantUML or Mermaid diagram representing the architecture.\n                - Validate Design: Ensure the design meets all requirements, is consistent, and addresses risks/assumptions.\n                - Format Output: Output only in YAML format with a clear structure, including the diagram as a string.\n            \n              input_format:\n                - A YAML document from the Requirements Analyst Agent with the following structure:\n                  ```yaml\n                  requirements_specification:\n                    functional_requirements:\n                      - description: \"Brief description of feature 1\"\n                        details: \"Additional details or sub-features\"\n                      # ... more as needed\n                    non_functional_requirements:\n                      performance: []\n                      security: []\n                      scalability: []\n                      # ... other categories\n                    target_platform: []\n                    tech_stack_suggestions: []\n                    stakeholders: []\n                    constraints: []\n                    assumptions: []\n                    risks: []\n                  ```\n            \n              output_format: |\n                Respond ONLY with a YAML-structured document. Do not include any additional text, explanations, or chit-chat outside the YAML. Use the following structure:\n            \n                ```yaml\n                high_level_architecture:\n                  architecture_pattern: \"Selected pattern (e.g., 'Clean Architecture')\"\n                  modules:\n                    - name: \"Module name (e.g., 'UI Layer')\"\n                      description: \"Purpose and responsibilities\"\n                      components:\n                        - \"Component 1 (e.g., 'MainActivity')\"\n                        - \"Component 2\"\n                    - name: \"Module name (e.g., 'Data Layer')\"\n                      description: \"Purpose and responsibilities\"\n                      components: []\n                  interactions:\n                    - description: \"Interaction between modules (e.g., 'UI Layer calls Business Logic via ViewModel')\"\n                      source: \"Module name\"\n                      target: \"Module name\"\n                  tech_stack:\n                    - \"Technology 1 (e.g., 'Kotlin Coroutines for async')\"\n                    - \"Technology 2 (e.g., 'Room for persistence')\"\n                  diagram:\n                    type: \"PlantUML\" # or \"Mermaid\"\n                    content: |\n                      @startuml\n                      [Module 1] --> [Module 2]\n                      [Module 2] --> [Module 3]\n                      @enduml\n                  constraints_addressed:\n                    - \"Constraint 1 (e.g., 'Budget: Use open-source libraries')\"\n                  assumptions:\n                    - \"Assumption 1 (e.g., 'Cloud-based backend')\"\n                  risks:\n                    - \"Risk 1 (e.g., 'Scalability may be limited by chosen DB')\"\n                ```\n            \n                - If a section is irrelevant or empty, omit it or use an empty list [].\n                - Keep descriptions concise yet detailed; aim for clarity and brevity.\n                - Ensure YAML is valid and indented properly.\n                - Include a diagram in PlantUML or Mermaid syntax as a string under `diagram.content`.\n            \n              guidelines:\n                - Objectivity: Base the design strictly on the input YAML. Do not invent requirements or deviate from the specification.\n                - Completeness: Ensure the architecture covers all functional and non-functional requirements.\n                - Kotlin Best Practices: Prioritize idiomatic Kotlin (e.g., use Flow for reactive data, avoid nulls with Elvis operator, leverage sealed interfaces).\n                - Modularity: Design for loose coupling and high cohesion between modules.\n                - Error Handling: If input is invalid or incomplete, output a YAML with an \"error\" section explaining briefly.\n                - No External Tools: Process based on input alone; no web searches or code execution.\n                - No Clarifications: Do not generate clarifying questions. Use assumptions from the input or make reasonable ones, documenting them explicitly.\n                - Iterative Mindset: Your output feeds the Detailed Designer Agent, so ensure it is robust, complete, and extensible.\n                - Professional Tone: Ensure output is neutral and technical.\n            \n              notes:\n                - Your response must be purely the YAML output. Do not include any requests for clarification or additional text outside the YAML.\n           \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.architecture","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.HIGH_LEVEL_ARCHITECT_AGENT","com.example.mindweaverstudio.data.ai.aiClients.AiClient"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/architecture/ArchitectValidatorOptimizerAgent.kt","className":null,"methodName":null,"startLine":13,"endLine":81,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.architecture\n\nimport com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT\nimport com.example.mindweaverstudio.data.ai.agents.Agent\n\nclass ArchitectValidatorOptimizerAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = ARCHITECT_VALIDATOR_OPTIMIZER_AGENT\n    override val description: String = \"Agent, responsible for optimize and validate architecture plan\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val messages = listOf(generateTestSystemPrompt(),\n            ChatMessage(role = ChatMessage.Companion.ROLE_USER, content = input)\n        )\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.0,\n            maxTokens = 5000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\nRole: Validator & Optimizer Agent\n\nDescription: You are the Validator & Optimizer Agent, the final agent in a multi-agent pipeline designed to generate application architectures for Kotlin-based applications. Your role is to validate the detailed design provided by the Detailed Designer Agent, ensuring it is consistent, complete, and aligned with the original requirements and high-level architecture. You also optimize the design by identifying improvements, addressing risks, and suggesting alternatives. Your output is a comprehensive, human-readable text report that serves as the final architectural specification, ready to be presented to the user for implementation.\n\nCore Responsibilities: Analyze Input: Process the YAML detailed design document, including architecture patterns, modules, components, API endpoints, interactions, tech stack, constraints, assumptions, and risks. Validate Design: Check consistency with the high-level architecture and original requirements. Ensure all functional and non-functional requirements (e.g., performance, security, scalability) are addressed. Verify Kotlin best practices (e.g., use of coroutines, type safety, null safety). Identify logical errors, missing components, or potential bottlenecks. Optimize Design: Suggest improvements (e.g., replace blocking calls with suspend functions, optimize data flows with Kotlin Flow). Propose alternative technologies or approaches if they better meet requirements (e.g., GraphQL instead of REST for complex queries). Mitigate identified risks (e.g., add caching to address performance risks). Simulate Scenarios: Mentally evaluate the design against common scenarios (e.g., high load, failure cases) to ensure robustness. Structure Output: Create a human-readable text report that clearly summarizes validation results, optimized design, and recommendations, formatted for easy understanding by the user.\n\nProcessing Steps: Parse Input: Read and validate the YAML detailed design document from the Detailed Designer Agent. Cross-Check Requirements: Ensure the design aligns with the original requirements (functional, non-functional, constraints) and high-level architecture. Validate Components: Check each module, component, and interaction for correctness, completeness, and adherence to Kotlin idioms. Identify Issues: Flag inconsistencies, potential bottlenecks, or unaddressed risks. Optimize Design: Propose specific changes (e.g., adjust coroutine scopes, simplify data models) and document alternatives. Simulate Scenarios: Evaluate the design against high-load, failure, or edge-case scenarios, noting potential issues and mitigations. Format Output: Output a human-readable text report with clear sections, including validation results, optimized design, and recommendations.\n\nInput Format: The input is a YAML document from the Detailed Designer Agent with the following structure: detailed_design: architecture_pattern: Selected pattern (e.g., Clean Architecture) modules: name: Module name description: Purpose and responsibilities components: name: Component name type: Class or Interface description: Purpose and responsibilities code_snippet: Kotlin pseudo-code api_endpoints: path: /endpoint/path method: GET or POST request: Request structure response: Response structure interactions: [] tech_stack: [] constraints_addressed: [] assumptions: [] risks: []\n\nOutput Format: Respond only with a human-readable text report. Do not include any YAML, additional explanations, or chit-chat outside the report. Use the following structure for the text report:\n\nFinal Architecture Report\n\nValidation Results Status: Valid or Invalid Issues: Issue 1 description, e.g., Missing error handling in Repository. Severity: Low/Medium/High. Recommendation: Proposed fix. Additional issues as needed. Compliance: Requirement 1, e.g., Functional: User authentication. Status: Met or Not Met. Details: Explanation. Requirement 2, e.g., Non-functional: Scalability for 10k users. Status: Met or Not Met. Details: Explanation.\n\nOptimized Architecture Architecture Pattern: e.g., Clean Architecture Modules: Module Name, e.g., UI Layer. Description: Purpose and responsibilities. Components: Component Name, e.g., MainViewModel: Type, e.g., Class. Description: Purpose. Pseudo-Code: class MainViewModel : ViewModel() { // Example implementation }. Additional components as needed. Additional modules as needed: Description: Purpose. Components: List components. API Endpoints: Path, e.g., /endpoint/path (Method, e.g., GET). Request: Request structure. Response: Response structure. Interactions: Description, e.g., ViewModel fetches data from Repository. Source: Component name. Target: Component name. Tech Stack: Technology 1, e.g., Kotlin Coroutines for async. Additional technologies. Diagram: @startuml [Module 1] --> [Module 2] @enduml\n\nOptimizations Optimization 1, e.g., Use Flow instead of LiveData. Rationale: Reason for optimization. Alternative, e.g., Consider GraphQL. Rationale: Reason for alternative.\n\nConstraints Addressed Constraint 1, e.g., Use open-source libraries. Additional constraints.\n\nAssumptions Assumption 1, e.g., Assumes cloud-based backend. Additional assumptions.\n\nRisks Mitigated Risk 1, e.g., Performance bottleneck. Mitigation: Proposed solution, e.g., Add caching layer. Additional risks and mitigations.\n\nNext Steps Recommended next steps for implementation, e.g., Begin with Data Layer setup using Room. Additional steps as needed.\n\nKeep the report concise yet detailed, ensuring clarity for the user. Format the report with clear sections for readability, avoiding any formatting syntax like Markdown, bullet points, or lists with hyphens or other symbols. Include the diagram as a text block in PlantUML or Mermaid syntax. Ensure the report is complete, professional, and ready for user review.\n\nGuidelines: Objectivity: Base validation and optimization strictly on the input YAML and previous pipeline stages. Completeness: Ensure all requirements, constraints, and risks are addressed in the validation and optimization process. Kotlin Best Practices: Verify and enforce idiomatic Kotlin (e.g., suspend functions, Flow for reactive data, null safety with Elvis operator). Robustness: Simulate edge cases (e.g., high load, failures) to ensure the design is resilient. Error Handling: If input is invalid or incomplete, include a section in the report explaining issues under Validation Results. No External Tools: Process based on input alone; no web searches or code execution. No Clarifications: Do not generate clarifying questions. Use assumptions from the input or make reasonable ones, documenting them explicitly. Iterative Mindset: Your output is the final architecture report for the user, so ensure it is robust, complete, and ready for implementation. Professional Tone: Ensure the report is neutral, technical, and user-friendly.\n\nNotes: Your response must be purely the text report. Do not include any requests for clarification or additional text outside the report structure.\n           \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.architecture","imports":["com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT","com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.DETAILED_ARCHITECT_DESIGNER_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/agents/workers/architecture/DetailedArchitectDesignerAgent.kt","className":null,"methodName":null,"startLine":12,"endLine":160,"content":"package com.example.mindweaverstudio.data.ai.agents.workers.architecture\n\nimport com.example.mindweaverstudio.data.ai.agents.Agent\nimport com.example.mindweaverstudio.data.ai.agents.DETAILED_ARCHITECT_DESIGNER_AGENT\n\nclass DetailedArchitectDesignerAgent(\n    private val aiClient: AiClient,\n) : Agent {\n    override val name = DETAILED_ARCHITECT_DESIGNER_AGENT\n    override val description: String = \"Agent, responsible for detailed architecture design\"\n\n    override suspend fun run(input: String): PipelineResult {\n        val messages = listOf(generateTestSystemPrompt(),\n            ChatMessage(role = ChatMessage.Companion.ROLE_USER, content = input)\n        )\n\n        val result = aiClient.createChatCompletion(\n            messages = messages,\n            temperature = 0.0,\n            maxTokens = 5000,\n        )\n        return result.fold(\n            onSuccess = { response ->\n                successPipelineResult(message = response.message)\n            },\n            onFailure = { error ->\n                errorPipelineResult(error)\n            }\n        )\n    }\n\n    private fun generateTestSystemPrompt(): ChatMessage {\n        val prompt =  \"\"\"\n           system_prompt:\n              role: Detailed Designer Agent\n              description: |\n                You are the Detailed Designer Agent, the third agent in a multi-agent pipeline designed to generate application architectures for Kotlin-based applications. Your role is to take the high-level architectural design from the High-Level Architect Agent and produce a detailed design, including specific classes, interfaces, data models, API endpoints, and pseudo-code snippets. Your output is a comprehensive, machine-readable document that is ready for the Validator & Optimizer Agent. You ensure the design is idiomatic to Kotlin, technically feasible, and aligned with the provided requirements and architecture.\n            \n              core_responsibilities:\n                - Analyze Input: Process the YAML high-level architecture document, including architecture patterns, modules, interactions, tech stack, constraints, assumptions, and risks.\n                - Detail Modules: For each module (e.g., UI, Business Logic, Data Layer), define:\n                  - Classes and interfaces (e.g., ViewModels, Repositories, Services).\n                  - Data models (e.g., data classes for entities).\n                  - API endpoints (if applicable, e.g., REST or GraphQL endpoints with Ktor).\n                  - Key functions (e.g., suspend functions for async operations).\n                - Incorporate Kotlin Idioms: Use Kotlin-specific features like coroutines, sealed classes, extension functions, and type-safe builders to ensure idiomatic code.\n                - Address Non-Functional Requirements: Detail implementations for performance, security, scalability, etc. (e.g., caching strategies, encryption methods).\n                - Generate Pseudo-Code: Provide Kotlin pseudo-code snippets for critical components (e.g., repository methods, ViewModel logic).\n                - Handle Assumptions and Risks: Build on assumptions from the input and mitigate identified risks through design choices.\n                - Structure Output: Create a standardized, machine-readable YAML document with detailed designs, ready for validation.\n            \n              processing_steps:\n                - Parse Input: Read and validate the YAML high-level architecture document.\n                - Detail Components: For each module, define classes, interfaces, and data models, ensuring alignment with the architecture pattern (e.g., MVVM, Clean Architecture).\n                - Specify Interactions: Detail how components interact (e.g., via interfaces, Kotlin Flow, or dependency injection with Koin/Hilt).\n                - Define APIs: If applicable, specify endpoints with request/response structures.\n                - Generate Pseudo-Code: Write concise Kotlin pseudo-code snippets for key functionalities.\n                - Validate Design: Ensure the detailed design meets all requirements, is consistent with the high-level architecture, and addresses constraints/assumptions.\n                - Format Output: Output only in YAML format with a clear structure, including pseudo-code as strings.\n            \n              input_format:\n                - A YAML document from the High-Level Architect Agent with the following structure:\n                  ```yaml\n                  high_level_architecture:\n                    architecture_pattern: \"Selected pattern (e.g., 'Clean Architecture')\"\n                    modules:\n                      - name: \"Module name\"\n                        description: \"Purpose and responsibilities\"\n                        components: []\n                    interactions:\n                      - description: \"Interaction description\"\n                        source: \"Module name\"\n                        target: \"Module name\"\n                    tech_stack: []\n                    diagram:\n                      type: \"PlantUML or Mermaid\"\n                      content: \"Diagram content\"\n                    constraints_addressed: []\n                    assumptions: []\n                    risks: []\n                  ```\n            \n              output_format: |\n                Respond ONLY with a YAML-structured document. Do not include any additional text, explanations, or chit-chat outside the YAML. Use the following structure:\n            \n                ```yaml\n                detailed_design:\n                  architecture_pattern: \"Selected pattern (e.g., 'Clean Architecture')\"\n                  modules:\n                    - name: \"Module name (e.g., 'UI Layer')\"\n                      description: \"Purpose and responsibilities\"\n                      components:\n                        - name: \"Component name (e.g., 'MainViewModel')\"\n                          type: \"Class or Interface\"\n                          description: \"Purpose and responsibilities\"\n                          code_snippet: |\n                            // Kotlin pseudo-code\n                            class MainViewModel : ViewModel() {\n                              // Example implementation\n                            }\n                        - name: \"Data model (e.g., 'User')\"\n                          type: \"Data Class\"\n                          description: \"Purpose and fields\"\n                          code_snippet: |\n                            data class User(val id: String, val name: String)\n                    - name: \"Module name (e.g., 'Data Layer')\"\n                      description: \"Purpose and responsibilities\"\n                      components: []\n                  api_endpoints:\n                    - path: \"/endpoint/path\"\n                      method: \"GET or POST\"\n                      request: \"Request structure (e.g., JSON schema)\"\n                      response: \"Response structure (e.g., JSON schema)\"\n                  interactions:\n                    - description: \"Detailed interaction (e.g., 'ViewModel fetches data from Repository')\"\n                      source: \"Component name\"\n                      target: \"Component name\"\n                  tech_stack:\n                    - \"Technology 1 (e.g., 'Kotlin Coroutines for async')\"\n                    - \"Technology 2 (e.g., 'Room for persistence')\"\n                  constraints_addressed:\n                    - \"Constraint 1 (e.g., 'Use open-source libraries')\"\n                  assumptions:\n                    - \"Assumption 1 (e.g., 'Assumes cloud-based backend')\"\n                  risks:\n                    - \"Risk 1 (e.g., 'Complex queries may impact performance')\"\n                ```\n            \n                - If a section is irrelevant or empty, omit it or use an empty list [].\n                - Keep descriptions concise yet detailed; aim for clarity and brevity.\n                - Ensure YAML is valid and indented properly.\n                - Include pseudo-code as strings under `code_snippet` fields, using idiomatic Kotlin syntax.\n            \n              guidelines:\n                - Objectivity: Base the design strictly on the input YAML. Do not invent requirements or deviate from the high-level architecture.\n                - Completeness: Ensure the detailed design covers all modules, components, and interactions specified in the input.\n                - Kotlin Best Practices: Use idiomatic Kotlin (e.g., suspend functions, Flow for reactive data, avoid nulls with Elvis operator, sealed interfaces for state).\n                - Modularity: Ensure components are loosely coupled and reusable.\n                - Error Handling: If input is invalid or incomplete, output a YAML with an \"error\" section explaining briefly.\n                - No External Tools: Process based on input alone; no web searches or code execution.\n                - No Clarifications: Do not generate clarifying questions. Use assumptions from the input or make reasonable ones, documenting them explicitly.\n                - Iterative Mindset: Your output feeds the Validator & Optimizer Agent, so ensure it is robust, complete, and extensible.\n                - Professional Tone: Ensure output is neutral and technical.\n            \n              notes:\n                - Your response must be purely the YAML output. Do not include any requests for clarification or additional text outside the YAML.\n           \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ChatMessage.Companion.ROLE_SYSTEM,\n            content = prompt\n        )\n    }\n}","chunkType":"CLASS","tokens":1000,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.agents.workers.architecture","imports":["com.example.mindweaverstudio.data.ai.agents.Agent","com.example.mindweaverstudio.data.ai.agents.DETAILED_ARCHITECT_DESIGNER_AGENT","com.example.mindweaverstudio.data.ai.agents.HIGH_LEVEL_ARCHITECT_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineUtils.kt","className":null,"methodName":null,"startLine":3,"endLine":3,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nconst val GITHUB_RELEASE_PIPELINE = \"github_release_pipeline\"","chunkType":"PROPERTY","tokens":29,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineUtils.kt","className":null,"methodName":null,"startLine":4,"endLine":4,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nconst val ARCHITECTURE_PIPELINE = \"architecture_pipeline\"","chunkType":"PROPERTY","tokens":28,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineUtils.kt","className":null,"methodName":null,"startLine":5,"endLine":5,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nconst val CODE_CREATOR_PIPELINE = \"code_creator_pipeline\"","chunkType":"PROPERTY","tokens":28,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineUtils.kt","className":null,"methodName":null,"startLine":6,"endLine":6,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nconst val CODE_REVIEW_PIPELINE = \"code_review_pipeline\"","chunkType":"PROPERTY","tokens":27,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":[],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/common/Pipeline.kt","className":null,"methodName":null,"startLine":6,"endLine":17,"content":"package com.example.mindweaverstudio.data.ai.pipelines.common\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.models.pipeline.PipelineStep\n\ninterface Pipeline {\n    val agentsRegistry: AgentsRegistry\n    val description: String\n    val name: String\n\n    fun steps(): List<PipelineStep>\n\n//    suspend fun run(\n//        input: ChatMessage,\n//        options: PipelineOptions,\n//    ): PipelineResult\n}","chunkType":"INTERFACE","tokens":115,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.common","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.models.pipeline.PipelineStep"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineRunner.kt","className":null,"methodName":null,"startLine":13,"endLine":62,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nimport com.example.mindweaverstudio.data.ai.memory.MemoryStore\nimport com.example.mindweaverstudio.data.ai.memory.getLastCompletedStep\n\nclass PipelineRunner(\n    private val memoryStore: MemoryStore\n) {\n    suspend fun execute(\n        pipeline: Pipeline,\n        input: ChatMessage,\n        options: PipelineOptions\n    ): PipelineResult {\n        val steps = pipeline.steps()\n        val lastCompletedStep = if (options.resumeFromLast) {\n            try {\n                memoryStore.getLastCompletedStep(pipeline.name) ?: 0\n            } catch (e: Exception) {\n                return errorPipelineResult(e)\n            }\n        } else 0\n\n        var result: PipelineResult? = null\n\n        for (step in steps) {\n            if (step.id <= lastCompletedStep) continue\n\n            val stepInput = if (step.id == 1) {\n                input.content\n            } else {\n                val inpuuuut = result?.message\n                    ?: memoryStore.getStepOutput(pipeline.name, step.id - 1)\n                    ?: return errorPipelineResult(\"Missing input for step ${step.id} in ${pipeline.name}\")\n                inpuuuut\n            }\n\n            result = step.action(stepInput)\n\n            try {\n                memoryStore.saveStepResult(\n                    pipelineName = pipeline.name,\n                    stepId = step.id,\n                    agentName = step.agentName,\n                    result = result\n                )\n            } catch (e: Exception) {\n                return errorPipelineResult(e)\n            }\n\n            if (result.isError) return result\n        }\n\n        return result ?: errorPipelineResult(\"Pipeline ${pipeline.name} has no steps\")\n    }\n}","chunkType":"CLASS","tokens":436,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":["com.example.mindweaverstudio.data.ai.memory.MemoryStore","com.example.mindweaverstudio.data.ai.memory.getLastCompletedStep","com.example.mindweaverstudio.data.ai.memory.getStepOutput"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineFactory.kt","className":null,"methodName":null,"startLine":16,"endLine":23,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nimport com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT\nimport com.example.mindweaverstudio.data.ai.agents.CHAT_AGENT\n\nclass PipelineFactory {\n    val codeFixerPipelineAgents = listOf(CODE_FIXER_AGENT, CODE_TESTER_AGENT)\n    val chatPipelineAgents = listOf(CHAT_AGENT, REASONING_AGENT)\n    val codeCreatorPipelineAgents = listOf(CODE_CREATOR_AGENT)\n    val codeReviewPipelineAgents = listOf(CODE_REVIEWER_AGENT)\n    val githubReleasePipelineAgents = listOf(RELEASE_NOTES_GENERATION_AGENT, GITHUB_RELEASE_AGENT)\n    val architecturePipelineAgents = listOf(REQUIREMENTS_ANALYST_AGENT, HIGH_LEVEL_ARCHITECT_AGENT, DETAILED_ARCHITECT_DESIGNER_AGENT, ARCHITECT_VALIDATOR_OPTIMIZER_AGENT)\n}","chunkType":"CLASS","tokens":192,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":["com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT","com.example.mindweaverstudio.data.ai.agents.CHAT_AGENT","com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/GithubReleasePipeline.kt","className":null,"methodName":null,"startLine":11,"endLine":39,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.ai.agents.GITHUB_RELEASE_AGENT\n\nclass GithubReleasePipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = GITHUB_RELEASE_PIPELINE\n    override val description: String = \"Pipeline, responsible for create github release\"\n\n\n    override fun steps() = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Generate release notes\",\n            agentName = RELEASE_NOTES_GENERATION_AGENT,\n            action = { input ->\n                agentsRegistry.get(RELEASE_NOTES_GENERATION_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $RELEASE_NOTES_GENERATION_AGENT not found\")\n            }\n        ),\n        PipelineStep(\n            id = 2,\n            name = \"Create GitHub release\",\n            agentName = GITHUB_RELEASE_AGENT,\n            action = { notes ->\n                agentsRegistry.get(GITHUB_RELEASE_AGENT)\n                    ?.run(\"Create github release with: $notes\")\n                    ?: errorPipelineResult(\"Error during $name running. Agent $GITHUB_RELEASE_AGENT not found\")\n            }\n        )\n    )\n}","chunkType":"CLASS","tokens":326,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.GITHUB_RELEASE_AGENT","com.example.mindweaverstudio.data.ai.agents.RELEASE_NOTES_GENERATION_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/ChatPipeline.kt","className":null,"methodName":null,"startLine":11,"endLine":28,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.ai.agents.CHAT_AGENT\n\nclass ChatPipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = CHAT_PIPELINE\n    override val description: String = \"Pipeline, responsible for default chat with user\"\n\n    override fun steps(): List<PipelineStep> = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Reasoning\",\n            agentName = REASONING_AGENT,\n            action = { input ->\n                agentsRegistry.get(REASONING_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $CHAT_AGENT not found\")\n            }\n        ),\n    )\n}","chunkType":"CLASS","tokens":203,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.CHAT_AGENT","com.example.mindweaverstudio.data.ai.agents.REASONING_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/CodeFixPipeline.kt","className":null,"methodName":null,"startLine":18,"endLine":44,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.ai.agents.CODE_FIXER_AGENT\n\nclass CodeFixPipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = CODE_FIX_PIPELINE\n    override val description: String = \"Pipeline, ответственностью которого является фикс багов\"\n\n    override fun steps(): List<PipelineStep> = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Code fix\",\n            agentName = CODE_FIXER_AGENT,\n            action = { input ->\n                agentsRegistry.get(CODE_FIXER_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $CODE_FIXER_AGENT not found\")\n            }\n        ),\n        PipelineStep(\n            id = 2,\n            name = \"Code test\",\n            agentName = CODE_TESTER_AGENT,\n            action = { message ->\n                agentsRegistry.get(CODE_TESTER_AGENT)?.run(message)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $CODE_TESTER_AGENT not found\")\n            }\n        )\n    )\n}","chunkType":"CLASS","tokens":297,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.CODE_FIXER_AGENT","com.example.mindweaverstudio.data.ai.agents.CODE_TESTER_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/ArchitecturePipeline.kt","className":null,"methodName":null,"startLine":13,"endLine":57,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\n\nclass ArchitecturePipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = ARCHITECTURE_PIPELINE\n    override val description: String = \"Pipeline responsible for create project architecture\"\n\n    override fun steps(): List<PipelineStep> = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Requirements analyst\",\n            agentName = REQUIREMENTS_ANALYST_AGENT,\n            action = { input ->\n                agentsRegistry.get(REQUIREMENTS_ANALYST_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $REQUIREMENTS_ANALYST_AGENT not found\")\n            }\n        ),\n        PipelineStep(\n            id = 2,\n            name = \"High level architect\",\n            agentName = HIGH_LEVEL_ARCHITECT_AGENT,\n            action = { message ->\n                agentsRegistry.get(HIGH_LEVEL_ARCHITECT_AGENT)?.run(message)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $HIGH_LEVEL_ARCHITECT_AGENT not found\")\n            }\n        ),\n        PipelineStep(\n            id = 3,\n            name = \"Detailed architect designer\",\n            agentName = DETAILED_ARCHITECT_DESIGNER_AGENT,\n            action = { message ->\n                agentsRegistry.get(DETAILED_ARCHITECT_DESIGNER_AGENT)?.run(message)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $DETAILED_ARCHITECT_DESIGNER_AGENT not found\")\n            }\n        ),\n        PipelineStep(\n            id = 4,\n            name = \"Architect validation and optimization\",\n            agentName = ARCHITECT_VALIDATOR_OPTIMIZER_AGENT,\n            action = { message ->\n                agentsRegistry.get(ARCHITECT_VALIDATOR_OPTIMIZER_AGENT)?.run(message)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $ARCHITECT_VALIDATOR_OPTIMIZER_AGENT not found\")\n            }\n        ),\n    )\n}","chunkType":"CLASS","tokens":537,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.ARCHITECT_VALIDATOR_OPTIMIZER_AGENT","com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.DETAILED_ARCHITECT_DESIGNER_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/CodeCreatorPipeline.kt","className":null,"methodName":null,"startLine":14,"endLine":31,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT\n\nclass CodeCreatorPipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = CODE_CREATOR_PIPELINE\n    override val description: String = \"Pipeline, который отвечает за генерацию кода по запросу\"\n\n    override fun steps(): List<PipelineStep> = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Code create\",\n            agentName = CODE_CREATOR_AGENT,\n            action = { input ->\n                agentsRegistry.get(CODE_CREATOR_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $CODE_CREATOR_AGENT not found\")\n            }\n        ),\n    )\n}","chunkType":"CLASS","tokens":214,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT","com.example.mindweaverstudio.data.ai.agents.CODE_FIXER_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/flows/CodeReviewPipeline.kt","className":null,"methodName":null,"startLine":16,"endLine":33,"content":"package com.example.mindweaverstudio.data.ai.pipelines.flows\n\nimport com.example.mindweaverstudio.data.ai.agents.AgentsRegistry\nimport com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT\n\nclass CodeReviewPipeline(\n    override val agentsRegistry: AgentsRegistry,\n) : Pipeline {\n    override val name: String = CODE_REVIEW_PIPELINE\n    override val description: String = \"Pipeline responsible for review of project\"\n\n    override fun steps(): List<PipelineStep> = listOf(\n        PipelineStep(\n            id = 1,\n            name = \"Code review\",\n            agentName = CODE_REVIEWER_AGENT,\n            action = { input ->\n                agentsRegistry.get(CODE_REVIEWER_AGENT)?.run(input)\n                    ?: errorPipelineResult(\"Error during $name running. Agent $CODE_REVIEWER_AGENT not found\")\n            }\n        ),\n    )\n}","chunkType":"CLASS","tokens":211,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines.flows","imports":["com.example.mindweaverstudio.data.ai.agents.AgentsRegistry","com.example.mindweaverstudio.data.ai.agents.CODE_CREATOR_AGENT","com.example.mindweaverstudio.data.ai.agents.CODE_FIXER_AGENT"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/pipelines/PipelineRegistry.kt","className":null,"methodName":null,"startLine":5,"endLine":19,"content":"package com.example.mindweaverstudio.data.ai.pipelines\n\nimport com.example.mindweaverstudio.data.ai.pipelines.common.Pipeline\n\nclass PipelineRegistry {\n    private val agents = mutableMapOf<String, Pipeline>()\n\n    fun register(name: String, agent: Pipeline) {\n        agents[name] = agent\n    }\n\n    fun get(name: String): Pipeline? = agents[name]\n\n    fun getPresentableList(): List<String> {\n        return agents.map { (name, pipeline) ->\n            \"Name: $name, description: ${pipeline.description}\"\n        }\n    }\n}","chunkType":"CLASS","tokens":131,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.pipelines","imports":["com.example.mindweaverstudio.data.ai.pipelines.common.Pipeline"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/ai/orchestrator/CodeOrchestrator.kt","className":null,"methodName":null,"startLine":17,"endLine":88,"content":"package com.example.mindweaverstudio.data.ai.orchestrator\n\nimport com.example.mindweaverstudio.data.ai.aiClients.AiClient\nimport com.example.mindweaverstudio.data.ai.memory.MemoryStore\n\nclass CodeOrchestrator(\n    private val registry: PipelineRegistry,\n    private val aiClient: AiClient,\n    private val memoryStore: MemoryStore\n) {\n    private val systemPrompt: ChatMessage = generateSystemPrompt()\n    private var messagesHistory: List<ChatMessage> = listOf(systemPrompt)\n    private val json: Json = Json {\n        ignoreUnknownKeys = true\n        explicitNulls = false\n        isLenient = true\n    }\n    private val pipelineRunner = PipelineRunner(memoryStore)\n\n    suspend fun handleMessage(userInput: String): PipelineResult {\n        val userMessage = ChatMessage(ROLE_USER, userInput)\n        messagesHistory += userMessage\n\n        val aiResult = aiClient.createChatCompletion(\n            messages = messagesHistory,\n            temperature = 0.3,\n            maxTokens = 1024\n        )\n\n        return aiResult.fold(\n            onSuccess = { result ->\n                val decision = json.decodeFromStringOrNull<CodeOrchestratorCommand>(result.message)\n                    ?: return@fold errorPipelineResult(message = \"Не получилось распарсить ответ от оркестратора\")\n                val pipeline = registry.get(decision.pipeline)\n                    ?: return@fold errorPipelineResult(message = \"Неизвестный агент\")\n\n                val result = pipelineRunner.execute(\n                    pipeline = pipeline,\n                    input = userMessage,\n                    options = PipelineOptions(resumeFromLast = false),\n                )\n\n                return result\n            },\n            onFailure = {\n                return errorPipelineResult(error = it)\n            }\n        )\n    }\n\n    private fun generateSystemPrompt(): ChatMessage {\n        val prompt = \"\"\"\n           You are a pipeline orchestrator.\n            Your task is to analyze the user message and decide which of the available pipelines should handle this request.\n            You never execute any request yourself.\n            You always respond strictly in JSON format.\n            \n            Here is the list of available pipelines and their purposes:\n            ${registry.getPresentableList()}\n            \n            JSON response format:\n            {\"pipeline\": \"<pipeline_name_from_the_list>\"}\n            \n            Rules:\n              - If the user message matches the functionality of one of the pipelines → specify that pipeline.\n              - If it does not match any pipeline → use \"chat_pipeline\".\n              - No comments, no text, no markdown formatting outside of JSON.\n \n        \"\"\".trimIndent()\n\n        return ChatMessage(\n            role = ROLE_SYSTEM,\n            content = prompt,\n        )\n    }\n\n}","chunkType":"CLASS","tokens":708,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.ai.orchestrator","imports":["com.example.mindweaverstudio.data.ai.aiClients.AiClient","com.example.mindweaverstudio.data.ai.memory.MemoryStore","com.example.mindweaverstudio.data.ai.pipelines.PipelineRegistry"],"classSignature":null,"relatedPrivateMethods":[]}},{"filePath":"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/voiceModels/SpeechRecognizer.kt","className":null,"methodName":null,"startLine":20,"endLine":65,"content":"package com.example.mindweaverstudio.data.voiceModels\n\nimport com.sun.jna.Native\nimport org.vosk.LibVosk\n\nclass SpeechRecognizer() {\n    private val modelPath: String = \"/Users/nikitaradionov/IdeaProjects/MindWeaver Studio/composeApp/src/jvmMain/kotlin/com/example/mindweaverstudio/data/voiceModels/vosk-model-small-ru-0.22\"\n\n    private var model: Model? = null\n    private var recognizer: Recognizer? = null\n    private var line: TargetDataLine? = null\n    private var job: Job? = null\n    val textChannel = Channel<String>(Channel.UNLIMITED)  // Канал для передачи распознанного текста агенту\n\n    init {\n        LibVosk.setLogLevel(LogLevel.WARNINGS)\n        Native.setProtected(true)  // Для JNA\n        model = Model(modelPath)\n        recognizer = Recognizer(model, 16000f)  // 16000 Hz — стандарт для Vosk\n    }\n\n    fun startRecognition(scope: CoroutineScope) {\n        job = scope.launch(Dispatchers.IO) {\n            val format = AudioFormat(16000f, 16, 1, true, false)  // Mono, 16-bit, 16kHz\n            val info = DataLine.Info(TargetDataLine::class.java, format)\n            line = AudioSystem.getLine(info) as TargetDataLine\n            line?.open(format)\n            line?.start()\n\n            val buffer = ByteArray(4096)\n            while (isActive) {\n                val bytesRead = line?.read(buffer, 0, buffer.size) ?: 0\n                if (bytesRead > 0 && recognizer?.acceptWaveForm(buffer, bytesRead) == true) {\n                    val result = recognizer?.result ?: \"\"\n                    val text = result.substringAfter(\"\\\"text\\\" : \\\"\").substringBeforeLast(\"\\\"\")  // Парсинг JSON-результата\n                    if (text.isNotBlank()) {\n                        textChannel.send(text)  // Отправляем текст агенту\n                    }\n                }\n            }\n        }\n    }\n\n    fun stopRecognition() {\n        job?.cancel()\n        line?.stop()\n        line?.close()\n        recognizer?.close()\n        model?.close()\n    }\n}","chunkType":"CLASS","tokens":490,"overlapsWithPrevious":false,"contextualInfo":{"packageDeclaration":"com.example.mindweaverstudio.data.voiceModels","imports":["com.sun.jna.Native","org.vosk.LibVosk","org.vosk.LogLevel"],"classSignature":null,"relatedPrivateMethods":[]}}]}